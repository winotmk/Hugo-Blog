<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=12371&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行 | ExampleSite</title>
<meta name=keywords content="hexo,next,docker,阿里云,eci"><meta name=description content="

一口气步子迈得有大，慢慢记录一下,如果你碰巧看到这个文章，希望这个文章的某些部分对你有帮助，来源我已尽量在文章中标出，还有很多部分是自己敲的
了解ECI弹性容器：https://www.aliyun.com/product/eci
了解阿里云NAS文件存储：https://www.aliyun.com/product/nas
为什么要用eci来运行hexo？
因为好玩，同时来学习从pull到发布到运行整个docker镜像的流程，也想给自己的hexo博客找个新家，酷酷的那种
本博客之前是由树莓派上的hexo生成，部署到github上的
最近在捣鼓docker，一时想不起来有什么灵活小巧的服务拿来用docker玩，那么想着干脆把树莓派上hexo这部分服务做成镜像，需要用的时候拿出来用用想必是极好的（这么一来好像树莓派又要吃灰了）
恰巧最近又在琢磨阿里云ECI容器服务，所以理论上是可以用我自己打包好的镜像的
最后成品的结构大致如下图：

这里挂了3个镜像：
1.node.js+git+ssh+hexo
主要是此镜像——由node.js+hexo组成的运行hexo环境，用过的都了解hexo是基于node.js的，每次我们生成文章的时候都会hexo g -d，而运行这套需要一个环境容器
git和ssh主要是部署在github上用的，同时我习惯用VSCode的SSH FS来管理远程文件和写博客，主要是ssh连接，也方便我拿PuTTY和WinSCP远程登录管理
2.vsftpd
一个常用的ftp服务，我是在本地些完再上传的，用这个是因为我发现如果要给文章插入图片，我还需要手动用ssh上传到hexo对应目录里。而用VSCode的SSH FS可以帮我自动同步本地工作目录和云上即将生成静态网页的hexo目录，非常方便！
3.ddns
因为容器是即用即开，用完就释放的，每次开会新分配一个弹性IP做为外网接口，但是不想每次都去复制这个新的ip地址，那么就要用到动态域名解析，刚好我在阿里云上购买过一个我自己的域名，所以ddns这部分服务就拉出来做个镜像
还挂了一个NAS盘：

挂载以后：

可见我的hexo，主题，文章，图片等等都存放在里面，服务容器可以随便释放拉取，数据不会受到影响，几百M的NAS容量价格抹零后可以忽略不计
文章后面（第三部分）会说如何按我的需求构建定制这几个镜像，并上传到阿里云容器镜像ARK仓库以方便调用
vsftpd还有ddns可以与主镜像node.js+hexo合并成一个大镜像吗？
当然可以，但我实际做了几次以后发现把ftp，ddns这样常用的服务功能单独拿出来会方便得多的多，毕竟我想起别得服务，也可以给他们挂上ftp等常用服务，我也可以选择不挂，这样容器的优势就体现出来了。我可以把单一的服务都做成单独的小镜像，需要哪个挂哪个，性能消耗也很小
整套下来有这些部分：

docker基本操作
已经启动的本地容器修改端口，启动容器时即启动服务等
打包制作自己的docker镜像(dockerfile)
docker镜像打包并上传到阿里云镜像库ARK
eci容器创建模板和eci命令行工具使用
hexo本地编辑环境设置————如何用VSCode舒服的写MD文档

附表：
群晖搭建私有镜像仓库和dockerengine设置
eci价格计算表

1. docker 基本操作
博主吐槽一下，总觉得一些类似run，commit操作完全可以做成一个美观好用的UI控制软件，但是docker destop就是不做，然后大家都默认敲命令行是方便的，好用的。十分不解，可能需要ui的不会写ui，熟练使用命令行的也不需要什么ui吧，诶
——后面随着对docker了解的深入，明白它不是虚拟机，用得还是linux内核，这么一想，处处真是浓浓的linux味，现在能提供一个windows下的Docker Desktop桌面程序，已经非常得不错了！
资料网站：
官方命令大全
基于Docker的Hexo博客搭建
这个基本操作写得还行下次爬一篇下来吧：
[小抄] Docker 基本命令
1.1 运行容器
docker run -it -d --name [container-name] -p 8088:80 [image-name]
这里是将容器内的80端口映射到宿主机的8088端口"><meta name=author content="Me"><link rel=canonical href=http://localhost:12371/posts/docker01/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.9de45e225101e4f99701d2b68fc6b8a1ef6027928be6391fa15bf7f56326c909.css integrity="sha256-neReIlEB5PmXAdK2j8a4oe9gJ5KL5jkfoVv39WMmyQk=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:12371/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:12371/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:12371/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:12371/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:12371/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:12371/posts/docker01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:12371/posts/docker01/"><meta property="og:site_name" content="ExampleSite"><meta property="og:title" content="Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行"><meta property="og:description" content=" 一口气步子迈得有大，慢慢记录一下,如果你碰巧看到这个文章，希望这个文章的某些部分对你有帮助，来源我已尽量在文章中标出，还有很多部分是自己敲的
了解ECI弹性容器：https://www.aliyun.com/product/eci 了解阿里云NAS文件存储：https://www.aliyun.com/product/nas
为什么要用eci来运行hexo？ 因为好玩，同时来学习从pull到发布到运行整个docker镜像的流程，也想给自己的hexo博客找个新家，酷酷的那种 本博客之前是由树莓派上的hexo生成，部署到github上的 最近在捣鼓docker，一时想不起来有什么灵活小巧的服务拿来用docker玩，那么想着干脆把树莓派上hexo这部分服务做成镜像，需要用的时候拿出来用用想必是极好的（这么一来好像树莓派又要吃灰了） 恰巧最近又在琢磨阿里云ECI容器服务，所以理论上是可以用我自己打包好的镜像的 最后成品的结构大致如下图：
这里挂了3个镜像： 1.node.js+git+ssh+hexo 主要是此镜像——由node.js+hexo组成的运行hexo环境，用过的都了解hexo是基于node.js的，每次我们生成文章的时候都会hexo g -d，而运行这套需要一个环境容器 git和ssh主要是部署在github上用的，同时我习惯用VSCode的SSH FS来管理远程文件和写博客，主要是ssh连接，也方便我拿PuTTY和WinSCP远程登录管理 2.vsftpd 一个常用的ftp服务，我是在本地些完再上传的，用这个是因为我发现如果要给文章插入图片，我还需要手动用ssh上传到hexo对应目录里。而用VSCode的SSH FS可以帮我自动同步本地工作目录和云上即将生成静态网页的hexo目录，非常方便！ 3.ddns 因为容器是即用即开，用完就释放的，每次开会新分配一个弹性IP做为外网接口，但是不想每次都去复制这个新的ip地址，那么就要用到动态域名解析，刚好我在阿里云上购买过一个我自己的域名，所以ddns这部分服务就拉出来做个镜像
还挂了一个NAS盘： 挂载以后： 可见我的hexo，主题，文章，图片等等都存放在里面，服务容器可以随便释放拉取，数据不会受到影响，几百M的NAS容量价格抹零后可以忽略不计
文章后面（第三部分）会说如何按我的需求构建定制这几个镜像，并上传到阿里云容器镜像ARK仓库以方便调用
vsftpd还有ddns可以与主镜像node.js+hexo合并成一个大镜像吗？ 当然可以，但我实际做了几次以后发现把ftp，ddns这样常用的服务功能单独拿出来会方便得多的多，毕竟我想起别得服务，也可以给他们挂上ftp等常用服务，我也可以选择不挂，这样容器的优势就体现出来了。我可以把单一的服务都做成单独的小镜像，需要哪个挂哪个，性能消耗也很小
整套下来有这些部分：
docker基本操作 已经启动的本地容器修改端口，启动容器时即启动服务等 打包制作自己的docker镜像(dockerfile) docker镜像打包并上传到阿里云镜像库ARK eci容器创建模板和eci命令行工具使用 hexo本地编辑环境设置————如何用VSCode舒服的写MD文档 附表： 群晖搭建私有镜像仓库和dockerengine设置 eci价格计算表
1. docker 基本操作 博主吐槽一下，总觉得一些类似run，commit操作完全可以做成一个美观好用的UI控制软件，但是docker destop就是不做，然后大家都默认敲命令行是方便的，好用的。十分不解，可能需要ui的不会写ui，熟练使用命令行的也不需要什么ui吧，诶 ——后面随着对docker了解的深入，明白它不是虚拟机，用得还是linux内核，这么一想，处处真是浓浓的linux味，现在能提供一个windows下的Docker Desktop桌面程序，已经非常得不错了！ 资料网站：
官方命令大全
基于Docker的Hexo博客搭建
这个基本操作写得还行下次爬一篇下来吧：
[小抄] Docker 基本命令
1.1 运行容器 docker run -it -d --name [container-name] -p 8088:80 [image-name] 这里是将容器内的80端口映射到宿主机的8088端口"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:tag" content="Hexo"><meta property="article:tag" content="Next"><meta property="article:tag" content="Docker"><meta property="article:tag" content="阿里云"><meta property="article:tag" content="Eci"><meta property="og:image" content="http://localhost:12371/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:12371/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行"><meta name=twitter:description content="

一口气步子迈得有大，慢慢记录一下,如果你碰巧看到这个文章，希望这个文章的某些部分对你有帮助，来源我已尽量在文章中标出，还有很多部分是自己敲的
了解ECI弹性容器：https://www.aliyun.com/product/eci
了解阿里云NAS文件存储：https://www.aliyun.com/product/nas
为什么要用eci来运行hexo？
因为好玩，同时来学习从pull到发布到运行整个docker镜像的流程，也想给自己的hexo博客找个新家，酷酷的那种
本博客之前是由树莓派上的hexo生成，部署到github上的
最近在捣鼓docker，一时想不起来有什么灵活小巧的服务拿来用docker玩，那么想着干脆把树莓派上hexo这部分服务做成镜像，需要用的时候拿出来用用想必是极好的（这么一来好像树莓派又要吃灰了）
恰巧最近又在琢磨阿里云ECI容器服务，所以理论上是可以用我自己打包好的镜像的
最后成品的结构大致如下图：

这里挂了3个镜像：
1.node.js+git+ssh+hexo
主要是此镜像——由node.js+hexo组成的运行hexo环境，用过的都了解hexo是基于node.js的，每次我们生成文章的时候都会hexo g -d，而运行这套需要一个环境容器
git和ssh主要是部署在github上用的，同时我习惯用VSCode的SSH FS来管理远程文件和写博客，主要是ssh连接，也方便我拿PuTTY和WinSCP远程登录管理
2.vsftpd
一个常用的ftp服务，我是在本地些完再上传的，用这个是因为我发现如果要给文章插入图片，我还需要手动用ssh上传到hexo对应目录里。而用VSCode的SSH FS可以帮我自动同步本地工作目录和云上即将生成静态网页的hexo目录，非常方便！
3.ddns
因为容器是即用即开，用完就释放的，每次开会新分配一个弹性IP做为外网接口，但是不想每次都去复制这个新的ip地址，那么就要用到动态域名解析，刚好我在阿里云上购买过一个我自己的域名，所以ddns这部分服务就拉出来做个镜像
还挂了一个NAS盘：

挂载以后：

可见我的hexo，主题，文章，图片等等都存放在里面，服务容器可以随便释放拉取，数据不会受到影响，几百M的NAS容量价格抹零后可以忽略不计
文章后面（第三部分）会说如何按我的需求构建定制这几个镜像，并上传到阿里云容器镜像ARK仓库以方便调用
vsftpd还有ddns可以与主镜像node.js+hexo合并成一个大镜像吗？
当然可以，但我实际做了几次以后发现把ftp，ddns这样常用的服务功能单独拿出来会方便得多的多，毕竟我想起别得服务，也可以给他们挂上ftp等常用服务，我也可以选择不挂，这样容器的优势就体现出来了。我可以把单一的服务都做成单独的小镜像，需要哪个挂哪个，性能消耗也很小
整套下来有这些部分：

docker基本操作
已经启动的本地容器修改端口，启动容器时即启动服务等
打包制作自己的docker镜像(dockerfile)
docker镜像打包并上传到阿里云镜像库ARK
eci容器创建模板和eci命令行工具使用
hexo本地编辑环境设置————如何用VSCode舒服的写MD文档

附表：
群晖搭建私有镜像仓库和dockerengine设置
eci价格计算表

1. docker 基本操作
博主吐槽一下，总觉得一些类似run，commit操作完全可以做成一个美观好用的UI控制软件，但是docker destop就是不做，然后大家都默认敲命令行是方便的，好用的。十分不解，可能需要ui的不会写ui，熟练使用命令行的也不需要什么ui吧，诶
——后面随着对docker了解的深入，明白它不是虚拟机，用得还是linux内核，这么一想，处处真是浓浓的linux味，现在能提供一个windows下的Docker Desktop桌面程序，已经非常得不错了！
资料网站：
官方命令大全
基于Docker的Hexo博客搭建
这个基本操作写得还行下次爬一篇下来吧：
[小抄] Docker 基本命令
1.1 运行容器
docker run -it -d --name [container-name] -p 8088:80 [image-name]
这里是将容器内的80端口映射到宿主机的8088端口"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:12371/posts/"},{"@type":"ListItem","position":2,"name":"Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行","item":"http://localhost:12371/posts/docker01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行","name":"Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行","description":" 一口气步子迈得有大，慢慢记录一下,如果你碰巧看到这个文章，希望这个文章的某些部分对你有帮助，来源我已尽量在文章中标出，还有很多部分是自己敲的\n了解ECI弹性容器：https://www.aliyun.com/product/eci 了解阿里云NAS文件存储：https://www.aliyun.com/product/nas\n为什么要用eci来运行hexo？ 因为好玩，同时来学习从pull到发布到运行整个docker镜像的流程，也想给自己的hexo博客找个新家，酷酷的那种 本博客之前是由树莓派上的hexo生成，部署到github上的 最近在捣鼓docker，一时想不起来有什么灵活小巧的服务拿来用docker玩，那么想着干脆把树莓派上hexo这部分服务做成镜像，需要用的时候拿出来用用想必是极好的（这么一来好像树莓派又要吃灰了） 恰巧最近又在琢磨阿里云ECI容器服务，所以理论上是可以用我自己打包好的镜像的 最后成品的结构大致如下图：\n这里挂了3个镜像： 1.node.js+git+ssh+hexo 主要是此镜像——由node.js+hexo组成的运行hexo环境，用过的都了解hexo是基于node.js的，每次我们生成文章的时候都会hexo g -d，而运行这套需要一个环境容器 git和ssh主要是部署在github上用的，同时我习惯用VSCode的SSH FS来管理远程文件和写博客，主要是ssh连接，也方便我拿PuTTY和WinSCP远程登录管理 2.vsftpd 一个常用的ftp服务，我是在本地些完再上传的，用这个是因为我发现如果要给文章插入图片，我还需要手动用ssh上传到hexo对应目录里。而用VSCode的SSH FS可以帮我自动同步本地工作目录和云上即将生成静态网页的hexo目录，非常方便！ 3.ddns 因为容器是即用即开，用完就释放的，每次开会新分配一个弹性IP做为外网接口，但是不想每次都去复制这个新的ip地址，那么就要用到动态域名解析，刚好我在阿里云上购买过一个我自己的域名，所以ddns这部分服务就拉出来做个镜像\n还挂了一个NAS盘： 挂载以后： 可见我的hexo，主题，文章，图片等等都存放在里面，服务容器可以随便释放拉取，数据不会受到影响，几百M的NAS容量价格抹零后可以忽略不计\n文章后面（第三部分）会说如何按我的需求构建定制这几个镜像，并上传到阿里云容器镜像ARK仓库以方便调用\nvsftpd还有ddns可以与主镜像node.js+hexo合并成一个大镜像吗？ 当然可以，但我实际做了几次以后发现把ftp，ddns这样常用的服务功能单独拿出来会方便得多的多，毕竟我想起别得服务，也可以给他们挂上ftp等常用服务，我也可以选择不挂，这样容器的优势就体现出来了。我可以把单一的服务都做成单独的小镜像，需要哪个挂哪个，性能消耗也很小\n整套下来有这些部分：\ndocker基本操作 已经启动的本地容器修改端口，启动容器时即启动服务等 打包制作自己的docker镜像(dockerfile) docker镜像打包并上传到阿里云镜像库ARK eci容器创建模板和eci命令行工具使用 hexo本地编辑环境设置————如何用VSCode舒服的写MD文档 附表： 群晖搭建私有镜像仓库和dockerengine设置 eci价格计算表\n1. docker 基本操作 博主吐槽一下，总觉得一些类似run，commit操作完全可以做成一个美观好用的UI控制软件，但是docker destop就是不做，然后大家都默认敲命令行是方便的，好用的。十分不解，可能需要ui的不会写ui，熟练使用命令行的也不需要什么ui吧，诶 ——后面随着对docker了解的深入，明白它不是虚拟机，用得还是linux内核，这么一想，处处真是浓浓的linux味，现在能提供一个windows下的Docker Desktop桌面程序，已经非常得不错了！ 资料网站：\n官方命令大全\n基于Docker的Hexo博客搭建\n这个基本操作写得还行下次爬一篇下来吧：\n[小抄] Docker 基本命令\n1.1 运行容器 docker run -it -d --name [container-name] -p 8088:80 [image-name] 这里是将容器内的80端口映射到宿主机的8088端口\n","keywords":["hexo","next","docker","阿里云","eci"],"articleBody":" 一口气步子迈得有大，慢慢记录一下,如果你碰巧看到这个文章，希望这个文章的某些部分对你有帮助，来源我已尽量在文章中标出，还有很多部分是自己敲的\n了解ECI弹性容器：https://www.aliyun.com/product/eci 了解阿里云NAS文件存储：https://www.aliyun.com/product/nas\n为什么要用eci来运行hexo？ 因为好玩，同时来学习从pull到发布到运行整个docker镜像的流程，也想给自己的hexo博客找个新家，酷酷的那种 本博客之前是由树莓派上的hexo生成，部署到github上的 最近在捣鼓docker，一时想不起来有什么灵活小巧的服务拿来用docker玩，那么想着干脆把树莓派上hexo这部分服务做成镜像，需要用的时候拿出来用用想必是极好的（这么一来好像树莓派又要吃灰了） 恰巧最近又在琢磨阿里云ECI容器服务，所以理论上是可以用我自己打包好的镜像的 最后成品的结构大致如下图：\n这里挂了3个镜像： 1.node.js+git+ssh+hexo 主要是此镜像——由node.js+hexo组成的运行hexo环境，用过的都了解hexo是基于node.js的，每次我们生成文章的时候都会hexo g -d，而运行这套需要一个环境容器 git和ssh主要是部署在github上用的，同时我习惯用VSCode的SSH FS来管理远程文件和写博客，主要是ssh连接，也方便我拿PuTTY和WinSCP远程登录管理 2.vsftpd 一个常用的ftp服务，我是在本地些完再上传的，用这个是因为我发现如果要给文章插入图片，我还需要手动用ssh上传到hexo对应目录里。而用VSCode的SSH FS可以帮我自动同步本地工作目录和云上即将生成静态网页的hexo目录，非常方便！ 3.ddns 因为容器是即用即开，用完就释放的，每次开会新分配一个弹性IP做为外网接口，但是不想每次都去复制这个新的ip地址，那么就要用到动态域名解析，刚好我在阿里云上购买过一个我自己的域名，所以ddns这部分服务就拉出来做个镜像\n还挂了一个NAS盘： 挂载以后： 可见我的hexo，主题，文章，图片等等都存放在里面，服务容器可以随便释放拉取，数据不会受到影响，几百M的NAS容量价格抹零后可以忽略不计\n文章后面（第三部分）会说如何按我的需求构建定制这几个镜像，并上传到阿里云容器镜像ARK仓库以方便调用\nvsftpd还有ddns可以与主镜像node.js+hexo合并成一个大镜像吗？ 当然可以，但我实际做了几次以后发现把ftp，ddns这样常用的服务功能单独拿出来会方便得多的多，毕竟我想起别得服务，也可以给他们挂上ftp等常用服务，我也可以选择不挂，这样容器的优势就体现出来了。我可以把单一的服务都做成单独的小镜像，需要哪个挂哪个，性能消耗也很小\n整套下来有这些部分：\ndocker基本操作 已经启动的本地容器修改端口，启动容器时即启动服务等 打包制作自己的docker镜像(dockerfile) docker镜像打包并上传到阿里云镜像库ARK eci容器创建模板和eci命令行工具使用 hexo本地编辑环境设置————如何用VSCode舒服的写MD文档 附表： 群晖搭建私有镜像仓库和dockerengine设置 eci价格计算表\n1. docker 基本操作 博主吐槽一下，总觉得一些类似run，commit操作完全可以做成一个美观好用的UI控制软件，但是docker destop就是不做，然后大家都默认敲命令行是方便的，好用的。十分不解，可能需要ui的不会写ui，熟练使用命令行的也不需要什么ui吧，诶 ——后面随着对docker了解的深入，明白它不是虚拟机，用得还是linux内核，这么一想，处处真是浓浓的linux味，现在能提供一个windows下的Docker Desktop桌面程序，已经非常得不错了！ 资料网站：\n官方命令大全\n基于Docker的Hexo博客搭建\n这个基本操作写得还行下次爬一篇下来吧：\n[小抄] Docker 基本命令\n1.1 运行容器 docker run -it -d --name [container-name] -p 8088:80 [image-name] 这里是将容器内的80端口映射到宿主机的8088端口\n参数说明\n-d 表示后台运行容器 -t 为docker分配一个伪终端并绑定到容器的标准输入上 -i 是让容器的标准输入保持打开状态 -p 指定映射端口\n还能这么写：\ndocker run --name mssql -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=xxxx' \\ -p 1433:1433 \\ -d mssql-2019-with-cimb \\应该是可以换行表述 -e 定义环境变量（通常制作镜像的时候应该已经写好了，或者在容器内做好自动脚本，run时候再写毕竟是不方便的）\n1.2 将此容器 commit 保存为新镜像： 格式：\ndocker commit container-id new-name container-id也可以是已有容器的名字，例如：\ndocker commit node-test nodehexo nodehexo这里是新镜像名\n1.3 启动docker引擎时自动运行docker容器： https://blog.csdn.net/londa/article/details/97611947\nps:上面链接文章还有:修改docker容器的挂载路径，修改docker默认的存储位置\ndocker run --restart=always 有时候，我们创建容器时忘了添加参数 --restart=always ，当 Docker 重启时，容器未能自动启动，\n现在要添加该参数怎么办呢，方法有二：\n1、Docker 命令修改\ndocker container update --restart=always 容器名字 我实际运行时，可以支持同时配置多个容器id，比如（其中container关键字可以忽略不写）\ndocker update 87cd61ad7f7c f488b0479f24 2109903220ce 1fb346ea1a46 --restart=no 2、直接改配置文件\n首先停止容器，不然无法修改配置文件\n配置文件路径为：/var/lib/docker/containers/ 容器ID\n在该目录下找到一个文件 hostconfig.json ，找到该文件中关键字 RestartPolicy\n修改前配置：\"RestartPolicy\":{\"Name\":\"no\",\"MaximumRetryCount\":0}\n修改后配置：\"RestartPolicy\":{\"Name\":\"always\",\"MaximumRetryCount\":0}\n最后启动容器。\n1.4 有关dockerfile dockerfile是用来构建镜像的脚本 主要参考这几篇： https://www.runoob.com/docker/docker-dockerfile.html https://developer.aliyun.com/article/484262 docker容器启动时自动启动脚本\n编写dockerfile 我的第一个dockerfile： 简单做个测试，在之前做的镜像上加了条启动命令 Dockerfile （文件没有后缀)\n## Set the base image to CentOS 基于nodehexo FROM nodehexo:V4 COPY ddnsstart.sh /ddnsstart.sh ENTRYPOINT [\"/bin/bash\", \"/ddnsstart.sh\"] 很简单: FROM基于nodehexo:V4镜像构建 COPY就是拷贝构建目录下的ddnsstart.sh到之后构建好的镜像根目录下 ENTRYPOINT会在用新镜像开启容器时再执行，这里会在执行/bin/bash里执行/ddnsstart.sh\n一个dockerfile只能有一条ENTRYPOINT，多个也只执行最后一个,CMD也是如此 如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。\n关于CMD还有些写法，比如还可以 CMD service ssh start \u0026\u0026 service XXX start \u0026\u0026 tail -f /etc/passwd一起执行多道指令 这在构建镜像的时候会被自动转换为类似： CMD [\"/bin/sh\", \"service ssh start\",\"service XXX start\",\"tail -f /etc/passwd\"]\ntail -f /etc/passwd作用在于防止docker容器开启后立即关闭见下面段落\nCMD格式：\nCMD CMD [\"\u003c可执行文件或命令\u003e\",\"\",\"\",...] CMD [\"\",\"\",...] # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数 推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认是 bin/sh\nddnsstart.sh文件\n#!/bin/bash root/ddnsAPP/ddns -c root/ddnsAPP/config.json echo \"更新mcwrite.winotmk.com解析\" service ssh start tail -f /etc/passwd 这里都是简单的shell命令了 root/ddnsAPP/ddns -c root/ddnsAPP/config.json是执行ddns更新，解析新的ip到域名上，因为我这个镜像打算放到阿里云ECI里跑，每次新拉的IP当然都不一样（一直占着一个IP会产生费用，没必要）\n同时我还执行了启动ssh服务，有的时候会用上ssh，因为我把网盘挂载到了容器内 tail -f /etc/passwd这里起到的比较重要的占着进程的作用，详见下面：\n*关于 CMD 或 entrypoint 构建后 docker run -dit 为何容器依然秒退 https://www.zhihu.com/question/344939968 是因为使用了CMD或者entrypoint去service *** start命令作为容器启动命令，主进程执行完结束了，容器也就结束了\ndockerfile 写清楚 entrypoint 和 cmd，启动脚本如果立刻会退出，那么在最后添加 tail -f 某个日志文件。或者 监听某个端口或者进程。 方法1: 设置容器启动时就启动服务ENTRYPOINT [“flask”, “run”, “-h”, “0.0.0.0”, “-p”, “80”] 方法2:CMD service apache2 start \u0026\u0026 tail -F /var/log/apache2/error.log再极端点 sleep infinite\n用dockerfile构建镜像 docker build -t \u003c新镜像名字:标签\u003e . 比如docker build -t nodehexo:V5 . 请不要忘记最后一个.，这表示在当前目录下构建 用这条指令前先CD到dockerfile文件所放置的目录 比如我先CD ./dockerbuild，因为我的文件放在用户/dockerbuild目录下面 然后就拥有了属于构建的镜像！\n1.4.1 ENTRYPOINT与CMD的区别 Docker 的 ENTRYPOINT 和 CMD 参数探秘 https://aws.amazon.com/cn/blogs/china/demystifying-entrypoint-cmd-docker/\n1.4.2 dockerfile构建镜像时如何选择FROM镜像以减小镜像体积 busybox： https://blog.csdn.net/hknaruto/article/details/70229896 alpine： https://hub.docker.com/_/alpine alpine包管理器APK： https://wangchujiang.com/linux-command/c/apk.html https://wiki.alpinelinux.org/wiki/Alpine_Package_Keeper\n1.5 将已有镜像打包带走/使用将打包来的镜像 https://zhuanlan.zhihu.com/p/348849578\n将镜像保存为本地文件 可以使用Docker save命令\ndocker save -o mssql-2019-with-cimb.tar mssql-2019-with-cimb 会得到一个mssql-2019-with-cimb.tar文件，就可以随身携带啦\n从文件载入镜像\n从文件载入镜像 使用Docker load命令:\ndocker load --input mssql-2019-with-cimb.tar 1.6 docker挂载本地目录 有关volume:https://docs.docker.com/storage/volumes/ https://docs.docker.com/get-started/05_persisting_data/ https://blog.csdn.net/zz00008888/article/details/131924286\n在Docker中，可以使用“-v”选项来挂载本地目录。该选项需要两个参数，分别是本地目录路径和容器内目录路径。例如，以下命令将本地目录“/home/user/app”挂载到容器内的“/app”目录中：\ndocker run -v /home/user/app:/app my_image 这将使得容器可以访问本地目录中的文件，并且任何对该目录的更改也会反映在容器中。\nDocker挂载本地目录到已有容器\n除了在容器启动时挂载本地目录外，还可以在运行时将本地目录挂载到正在运行的容器中。要实现这一点，可以使用“docker cp”命令将本地目录复制到容器中，并使用“docker exec”命令在容器中执行命令。例如，以下命令将本地目录“/home/user/data”挂载到正在运行的容器中：\ndocker cp /home/user/data my_container:/data docker exec -it my_container bash 在容器中，可以访问挂载的目录“/data”，并且任何对该目录的更改也会反映在本地文件系统中。\n1.7 其他一些操作 # ****************************** 容器 ****************************** # # 查看正在运行的容器 $ docker ps # 查看所有容器 $ docker ps -a # 启动/停止某个容器 $ docker start/stop id/name # 以交互方式启动一个容器 $ docker start -i id/name # 进入某个容器(使用exit退出后容器也跟着停止运行) $ docker attach id/name # 启动一个伪终端以交互式的方式进入某个运行的容器（使用exit退出后容器不停止运行） $ docker exec -it id/name # 删除某个容器 $ docker rm id/name # 复制ubuntu容器并且重命名为test且运行，然后以伪终端交互式方式进入容器，运行bash $ docker run --name test -ti ubuntu /bin/bash # ****************************** 镜像 ****************************** # # 查看本地镜像 $ docker images # 删除某个镜像 $ docker rmi id/name # 基于当前目录下的Dockerfile，创建一个名为name:flag的镜像 $ docker build -t name:flag . 2. 已启动容器操作 2.1 win10下docker给已存在的容器添加端口映射的方法 博主再吐槽一下，这个调试阶段如此常用的修改容我端口，改起来却像游戏作弊，不觉得这个要做简单很难，怕只是没做 https://mdnice.com/writing/25822ca29531424d9b68d7feb8273a82 https://blog.csdn.net/Taysuesue/article/details/126706394 https://www.cnblogs.com/kingsonfu/p/11578073.html\n查看容器已映射的端口（dockerdeskUI内也可看见）\ndocker port 容器ID/容器名 先停止容器\ndocker stop {容器的名称或者 id } 查看容器完整的 hash_of_the_container 数值：\ndocker inspect {容器的名称或者 id } | grep Id # 比如： docker inspect cbe26510c276 | grep Id # 会得到如下结果： # \"Id\": \"cbe26510c276fa9a4487a8c2af8cbb49410f2a5305149d2b26eb8ce37c777d00\" 如果主机是linux（mac应该也行没测） 打开 hostconfig.json 配置文件:\nvim /var/lib/docker/containers/{hash_of_the_container}/hostconfig.json 记得还要改 config.v2.json，改法同下面的win10 如果是win10 1.先找到容器的配置文件，首先我的电脑地址栏输\\wsl$\\进入到网络文件夹上,在一步一步找到容器目录\n\\\\wsl$\\docker-desktop-data\\data\\docker\\containers 2.点击进入相应容器ID文件夹，打开后修改其中的 config.v2.json 和 hostconfig.json\nhostconfig.json\n\"PortBindings\":{\"22/tcp\":[{\"HostIp\":\"\",\"HostPort\":\"50022\"}],\"3306/tcp\":[{\"HostIp\":\"\",\"HostPort\":\"53306\"}],\"6379/tcp\":[{\"HostIp\":\"\",\"HostPort\":\"56379\"}]} 这里的HostPort字面意思就是宿主机的端口，所以即： 容器内22\u003e外部5022访问 容器内3306\u003e外部53306访问 容器内6379\u003e外部56379访问\nconfig.v2.json 有两处需要添加，只修改一处不生效\n\"ExposedPorts\":{\"22/tcp\":{},\"3306/tcp\":{},\"6379/tcp\":{}} \"Ports\":{\"22/tcp\":[{\"HostIp\":\"0.0.0.0\",\"HostPort\":\"50022\"}],\"3306/tcp\":[{\"HostIp\":\"0.0.0.0\",\"HostPort\":\"53306\"}],\"6379/tcp\":[{\"HostIp\":\"0.0.0.0\",\"HostPort\":\"56379\"}]} 不过我实际只改了这里的\"ExposedPorts\"貌似就行了\n然后重启docker，注意不只是重启容器，我一开始只重启容器发现白改了\n# 重启 docker service docker restart 或者在系统右下角，点击Restart重启整个 Docker 服务，然后再重启 Container 即可正常使用\n2.2 docker容器内服务开机自启动实现方案（以ssh服务为例） 注意，2.2这段内容随着对docker和linux了解的深入觉得有不妥，但是作为学习的过程还是保留\nhttps://blog.csdn.net/qq_38603541/article/details/124028994\n因为我后续打算用类似vscode里的remote-ssh来管理容器内，也想用winscp等好用的工具可以接进来，还是有必要开个ssh 解决方案 1、正常我们在linux操作系统内设置服务自启动的方法一般都是使用systemctl。\nsystemctl enable ssh 2、但是，一般在docker容器内我们一般不这么干，因为容器内没有systemctl权限……\n3、我们依然还是使用脚本的形式将ssh设为自启，只不过这个的这个脚本和我们使用Dockerfile的脚本不一样。\n4、在 /root 目录下新建一个 start_ssh.sh文件，并给予该文件可执行权限。\ntouch /root/start_ssh.sh vim /root/start_ssh.sh chmod +x /root/start_ssh.sh 5、start_ssh.sh 脚本的内容，如下：\n#!/bin/bash LOGTIME=$(date \"+%Y-%m-%d %H:%M:%S\") echo \"[$LOGTIME] startup run...\" \u003e\u003e/root/start_ssh.log service ssh start \u003e\u003e/root/start_ssh.log #service mysql start \u003e\u003e/root/star_mysql.log //其他服务也可这么实现 6、将start_ssh.sh脚本添加到启动文件中\nvim /root/.bashrc 7、在 .bashrc 文件末尾加入如下内容：\n# startup run if [ -f /root/start_ssh.sh ]; then . /root/start_ssh.sh fi 8、保存后，等下次重启容器的时候，添加的服务也就跟着重启了。\ndocker容器在启动的时候，会自动执行的是~/.bashrc文件，所以，环境变量需要配置在该文件内，这样镜像启动时，可自动执行该文件，使环境变量生效。\n正确的理解是： /root/.bashrc会在容器启动的时候自动执行这句十分欠妥， 准确的来讲是root用户登录bash的时候会执行，每次开新的bash shell也会执行一遍 如果dockerfile内定义了ENTRYPOINT或者CMD执行类似：\nENTRYPOINT [ \"/bin/bash\",\"-c\",\"service apache2 start\" ] 那么对于容器来说PID 1号进程就是bash（apache是bash的子进程），也确实会跑一遍.bashrc内的内容，但是这不代表所有容器启动时一定会启动bash shell，也可能直接是个java进程，也可能是dumb-int，更多时候可能是sh shell，这应该都不会触发.bashrc 所以如果想要在容器启动时自动启动一个服务，推荐写在dockerfile里，比如\nCOPY start.sh / ENTRYPOINT [ \"sh\",\"/start.sh\" ] 然后再在start.sh里写上你需要启动的服务\n#!/bin/sh service ssh restart service apache2 restart 以及如果确实有很多个服务需要启，考虑使用类似docker compose启多个镜像，每个镜像跑单个服务\n2.2.1 拓展：~/.bashrc /etc/bashrc /etc/profile三个文件的区别 https://segmentfault.com/q/1010000003793341\n3 打包制作自己的docker镜像(dockerfile) dockerfile是告诉docker engine如何构建镜像的脚本\n3.1 node.js+git+hexo镜像 其实这部分镜像做了两遍，第一遍直接拉的官方node镜像，然后发现ssh不好装，走了很多弯路，随着对docker了解的加深，最后我自己做了dockerfile重构了这部分镜像\n3.1.1 Dockerfile dockerfileV02（可以没有后缀）\n#这个包将包含：node-v29.5.0 git ssh hexo #hexo环境目录/hexo/Winblog FROM debian:stable-slim LABEL maintainer=\"winotmk\" web=\"md.winotmk.com\" Ver=\"02\" #ADD有自动解压功能 ADD node-v20.5.0-linux-x64.tar.xz / #移动node二进制文件到目录 RUN mkdir -p /usr/local/nodejs \u0026\u0026\\ mv node-v20.5.0-linux-x64 /usr/local/nodejs \u0026\u0026\\ #mk hexo目录 mkdir -p /hexo/Winblog \u0026\u0026\\ apt-get update \u0026\u0026\\ #安装SSH 安装GIT apt-get install -y --no-install-recommends openssh-server git-core \u0026\u0026\\ apt-get autoremove -y \u0026\u0026\\ apt-get clean #node和npm环境变量 ENV PATH=\"/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH\" #安装hexo WORKDIR /hexo/Winblog RUN npm install -g hexo-cli #hexo环境变量 ENV PATH=\"$PATH:/hexo/Winblog/node_modules/.bin\" #更新ssh设置 COPY sshd_config /etc/ssh/ #环境变量设置 COPY .profile /root/ #设置启动脚本 COPY hexo_debian_service_start.sh /service_start.sh CMD [\"/bin/bash\",\"/service_start.sh\"] 基本上都是些安装命令以及配置环境变量 安装了hexo,git,ssh,node 这是优化过了的第二版，主要是第二版使用了ADD，它基本和COPY一样，都可以把某个构建目录下的文件打入正在生成的镜像里，但当用ADD在执行 \u003c源文件\u003e 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 \u003c目标路径\u003e。说白了ADD会帮我自动解压 在这里我还设置了ssh（但是没有配置root密码）\n而我的第一版开头： dockerfileV01\nFROM debian:stable-slim COPY node-v20.5.0-linux-x64.tar.xz /node-v20.5.0-linux-x64.tar.xz RUN apt-get update \u0026\u0026\\ apt-get install -y xz-utils --no-install-recommends \u0026\u0026\\ tar -xvf node-v20.5.0-linux-x64.tar.xz \u0026\u0026\\ mkdir -p /usr/local/nodejs \u0026\u0026\\ mv node-v20.5.0-linux-x64 /usr/local/nodejs \u0026\u0026\\ #删除xz包 apt-get purge -y xz-utils \u0026\u0026 \\ apt-get autoremove -y \u0026\u0026 \\ apt-get clean \u0026\u0026 \\ #删除node-v20.5.0-linux-x64.tar.xz包 rm node-v20.5.0-linux-x64.tar.xz #node和npm环境变量 ENV PATH=\"/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH\" 当时不知道ADD的功能，使用 COPY拷贝整个.tar.xz包结果debian还没有.xz包解压功能，需要安装xz-utils详见，凭空多出好几行\n为什么要用二进制包安装呢node.js呢？ 因为实测如果用apt-get install nodejs安装， 或者curl -fsSL https://deb.nodesource.com/setup_19.x | bash - \u0026\u0026\\ apt-get install -y nodejs命令出处， 安装出来镜像体积就是会楞大出好几百MB\n3.1.2 node.js+git+hexo镜像COPY的文件 .profile\n# ~/.profile: executed by Bourne-compatible login shells. if [ \"$BASH\" ]; then if [ -f ~/.bashrc ]; then . ~/.bashrc fi fi mesg n 2\u003e /dev/null || true export PATH=\"/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH\" export PATH=\"$PATH:/hexo/Winblog/node_modules/.bin\" 为了防止镜像上云后莫名其妙的原因导致环境变量出问题，脚本里再跑一遍，这俩export PATH其实dockerfile里设置过\nsshd_config是什么 ssh的设置 参考：https://blog.csdn.net/weixin_34910922/article/details/125193597 主要改了两条\n#vim /etc/ssh/sshd_config PermitRootLogin yes #root登陆权限 PasswordAuthentication yes #密码权限 等于我们预先改好了配置文件，在构建的时候再把配置放入容器里面\nhexo_debian_service_start.sh\n#!/bin/bash . ~/.profile LOGTIME=$(date \"+%Y-%m-%d %H:%M:%S\") echo \"[$LOGTIME] startup run...\" \u003e\u003e/start_ssh.log service ssh start \u003e\u003e/start_ssh.log tail -f /start_ssh.log 启动脚本，主要启动了ssh服务，并且用tail -f让这个容器一直运行以方便我们来连接\n3.1.3 开始构建镜像 先CD到Dockerfile所在的目录 docker build -t hexo_debian:V02 -f dockerfileV02 . 格式是\ndocker build -t 镜像名:tag -f Dockerfile文件名 . 注意.不要落下！\n这样我们的镜像就做好了！\n本节参考资料： 二进制手动安装node参考： https://github.com/nodejs/help/wiki/Installation https://blog.51cto.com/u_13460811/4901015\n一些关于dockerfile指令的说明： 较详细： https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy https://blog.csdn.net/qq_35528657/article/details/127244194 https://www.runoob.com/docker/docker-dockerfile.html\n在dockerfile里用apt-get包管理的建议： https://ubuntu.com/blog/we-reduced-our-docker-images-by-60-with-no-install-recommends https://www.metricfire.com/blog/how-to-build-optimal-docker-images/\nhexo所需环境安装说明： https://hexo.io/zh-cn/docs/index.html\n3.1.4 测试镜像功能 来启个容器试试！\ndocker run -it -d -p 22:22 --name hexo_debian hexo_debian:V02 这里开放了22端口来方便验证ssh服务和登录ssh没有问题 启动成功！ 容器内执行来验证服务状态都正常：\nssh node -v git -v 输出： 可以看见一切正常！\n3.1.5 设置和再打包镜像 设置 毕竟自用镜像，我习惯直接把比如ssh密钥之类全都配置好，再commit为一个新镜像，以后就再也不用输密码了，这样确实不安全，但是自己的hexo博客而已，何必为难自己呢 接下来设置root密码和重启ssh服务 passwd root #然后敲自己设置的密码 service ssh restart 尝试使用PuTTY进行SSH root@127.0.0.1登录： 成功!!! 接下来配置git和ssh，要生成新的ssh公钥 详见：https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent ssh-keygen -t ed25519 -C \"github邮箱@qq.com\" 得到密钥默认在/root/.ssh/id_ed25519.pub 在Github的头像点Setting然后点右上角击New SSH key，把id_ed25519.pub内容粘贴进即可！ 测试SSH连接：\nssh -T git@github.com 这样就连上了！ 需要进行一个小设置：\ngit config --global user.email \"you@example.com\" 这样以后使用hexo d的时候就能无脑部署了\n再打包 为了存下我们配置好的连接，制作成最终镜像方便eci云上调用，把现有容器再commit一次\ndocker commit hexo_debian hexo_debian:V02-configured 成了！得到了hexo_debian:V02-configured作为我最后准备上传至ECI云的镜像\n3.1.6 附一些命令参考 如何用ssh连接 docker 容器 https://blog.csdn.net/weixin_34910922/article/details/125193597\n1.修改root密码\n$ passwd root 输入密码：123456(自己决定) 2.安装Openssh\nsudo apt-get update # 更新源 sudo apt-get upgrade # 更新系统软件 apt-get install -y openssh-server 3.修改ssh配置,允许root登录 https://blog.csdn.net/weixin_43343144/article/details/102494830 【非常重要】在/etc/ssh/ssh_config中没有PermitRootLogin yes选项的话，就要在sshd_config文件中寻找！\nvim /etc/ssh/sshd_config PermitRootLogin yes #root登陆权限 PasswordAuthentication yes #密码权限 4.启动ssh服务/重启服务\nservice ssh start service ssh restart 安装hexo npm install hexo-cli -g SSH远程登录这个镜像 之前在本机docker内已经配好了ssh服务，讲道理应该启动则开启ssh但是不知为啥没有自动启动，以后再研究吧 打开Workbench远程连接，启动ssh 由于我启用ECI时开通了弹性公网IP，所以我可以通过这个IP:22用ssh来登录 使用PuTTY工具登录成功！！ 多么令人振奋的一刻\n3.2 vsftpd镜像 这个镜像比较简单，只跑ftp服务，主要在写作的时候方便上传图片\n3.2.1 Dockerfile vsftpd_dockerfileV01\n#这个包将包含：vsftp（root登录） FROM debian:stable-slim LABEL maintainer=\"winotmk\" web=\"md.winotmk.com\" Ver=\"01\" RUN apt-get update \u0026\u0026\\ apt-get install -y vsftpd --no-install-recommends \u0026\u0026\\ apt-get autoremove -y \u0026\u0026\\ apt-get clean \u0026\u0026\\ echo \"root:yourpasswd\" | chpasswd COPY ftpusers /etc/ COPY vsftpd.conf /etc/ COPY service_start.sh /service_start.sh CMD [\"/bin/bash\",\"/service_start.sh\"] 比较简单的dockerfile，就装了个vsftpd服务，然后拷贝了一些设置文件 如果要在dockerfile里配置用户密码可以这么写：\necho \"root:yourpasswd\" | chpasswd 3.2.2 vsftpd镜像COPY的文件 service_start.sh\n#!/bin/bash LOGTIME=$(date \"+%Y-%m-%d %H:%M:%S\") echo \"[$LOGTIME] startup run...\" \u003e\u003e/start_vsftpd.log service vsftpd start \u003e\u003e/start_vsftpd.log tail -f /start_vsftpd.log 简单的服务启动脚本，使用tail -f来维持住进程\nftpusers root前加个#以启用root登录\n# /etc/ftpusers: list of users disallowed FTP access. See ftpusers(5). #root daemon bin sys sync games man lp mail news uucp nobody vsftpd.conf ftp设置文件，这个文件内容很多只些下修改的部分\nlisten=NO listen_ipv6=YES anonymous_enable=NO local_enable=YES write_enable=YES dirmessage_enable=YES use_localtime=YES connect_from_port_20=YES pam_service_name=vsftpd utf8_filesystem=YES *关于修改vsftpd的端口 https://askubuntu.com/questions/37058/how-to-change-vsftpd-default-port vsftpd.conf里的设置不是完全设置，可以自己增加字段\nlisten_port=234 ftp_data_port=235 pasv_min_port=30000 pasv_max_port=31000 来设置端口 注意FTP默认20传输数据，21用来listen，所以改得话干脆两个都改吧\n*这里遇到过一个小坑坑 构建器报错，一直卡在Starting FTP server: vsftpdvsftpd failed - probably invalid config. ... (warning). 自己在容器内运行service vsftpd start的时候同样如此，一般这样是因为vsftpd.conf文件设置错了，可神奇的是我只要打开dockerDesktop的Files文件管理把vsftpd.conf打开再保存一下就可以成功运行service vsftpd start 我发现这个文件的格式是UTF-8 CRLF 修改为LF 即可顺利启动vsftpd服务\n参考： https://www.cnblogs.com/Dreamcho/p/10805690.html\n如果要在dockerfile里加用户： https://blog.csdn.net/u010275850/article/details/120587850\n3.3 ddns镜像 这个镜像更简单？只在启动的时候跑一个ddns 但是我却在这里卡了很久 原因之一是因为一开始选用的ddns软件本地跑得好好的，在阿里云上总是报错，log显示已经修改了a记录但是自己去一看啥也没有，很是困惑，所以换了个软件实现 最开始使用的是这个软件，配置方便 https://github.com/NewFuture/DDNS 参考： https://blog.csdn.net/biao0309/article/details/117202951 无奈阿里云上即便是用官方提供的镜像newfuture/ddns也会报错（恼\n所以我改用ddns-go: https://github.com/jeessy2/ddns-go 先贴上官方镜像的层： jeessy/ddns-go 我们的新镜像将基于官方镜像来做\n3.3.1 dockerfile ddns-go_dockerfileV01\nFROM jeessy/ddns-go LABEL maintainer=\"winotmk\" web=\"md.winotmk.com\" Ver=\"01\" COPY ddns_start.sh / COPY ddns_go_config.yaml / ENV DDNS_URL= ENTRYPOINT [ \"sh\",\"/ddns_start.sh\" ] CMD [ \"\" ] 这里做了一个变量$DDNS_URL来定义我想要dns的域名(当然这个域名我得拥有) ENTRYPOINT和CMD的设置会覆盖掉的之前镜像内的设置 我不确定CMD [ \"\" ]是否有必要，但总之我想使官方镜像里的CMD失效，从结果上来看管用\n3.3.2 ddns镜像COPY的文件 ddns_go_config.yaml\ndnsconf: - ipv4: enable: true gettype: url url: https://myip4.ipip.net,https://ddns.oray.com/checkip,https://ip.3322.net,https://4.ipw.cn netinterface: \"\" cmd: \"\" domains: - null.winotmk.com ipv6: enable: false gettype: netInterface url: https://speed.neu6.edu.cn/getIP.php,https://v6.ident.me,https://6.ipw.cn netinterface: \"\" cmd: \"\" ipv6reg: \"\" domains: - \"\" dns: name: alidns id: 阿里云的AccessKey ID secret: 阿里云的AccessKey secret ttl: \"\" user: username: \"\" password: \"\" webhook: webhookurl: \"\" webhookrequestbody: \"\" webhookheaders: \"\" notallowwanaccess: true 这个是ddns-go的配置文件，第一次启动会在本地:9876打开个web界面，保存设置后会在root中生成这个文件，这里我直接引入这个文件是希望后面能用sed命令对文件的domains字段进行修改\nddns_start.sh\n#!/bin/sh LOGTIME=$(date \"+%Y-%m-%d %H:%M:%S\") echo \"[$LOGTIME] startup run...\" \u003e\u003e/start_ddns.log cd / if [ \"$DDNS_URL\" = \"\" ] then echo \"DDNS_URL is not set!\" \u003e\u003e/start_ddns.log tail -f /start_ddns.log else sed -i \"s/null.winotmk.com/$DDNS_URL/g\" ddns_go_config.yaml #chmod 777 ddns_go_config.yaml sleep 3 /app/ddns-go -l :9876 -f 300 -c /ddns_go_config.yaml echo \"已执行更新[$DDNS_URL]解析\" \u003e\u003e/start_ddns.log tail -f /start_ddns.log fi 在这个脚本里会判断$DDNS_URL是否为空，空的话直接输出需要$DDNS_URL设置 如果不为空的话会通过sed替换字符，这里设置文件内默认写得是null.winotmk.com 用这种方式去直接修改设置文件，是因为我没找到这个软件是否能直接用环境变量来定义解析到的域名\n关于用sed替换congif.json设置内的字段： 如何使用sed: https://linux.cn/article-11367-1.html 如何在sed命令内使用变量 https://www.cnblogs.com/muahao/p/6874412.html 判断变量是否为空的方法： https://cloud.tencent.com/developer/article/1721905\n4 docker镜像打包并上传到阿里云镜像库ARK 将自己的镜像上传至阿里云： 阿里云提供容器镜像服务，我自己玩开通个人实例即可 https://cr.console.aliyun.com/cn-shanghai/instances\n建立一个自己的仓库，然后就能看到示例说明，我们就能把自己的镜像上传了\n4.1 将镜像推送到Registry $ docker login --username=*****@qq.com registry.cn-shanghai.aliyuncs.com $ docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/******:[镜像版本号] $ docker push registry.cn-shanghai.aliyuncs.com/******:[镜像版本号] tag是类似复制一份且重命名镜像，push是上传（不知道为什么要重命名\n针对上面的3个镜像，分别是：node.js+git+hexo,vsftpd,ddns-go 我分别tag成了：\nregistry-vpc.cn-shanghai.aliyuncs.com/******:debian_V02_configured #应该写成:hexo_debian_V02_configured的，漏了。。算了 registry-vpc.cn-shanghai.aliyuncs.com/******:vsftpd_debian_V01 registry-vpc.cn-shanghai.aliyuncs.com/******:ddns_go_V01 再分别push即可\n4.2 在阿里云上使用容器实例（ECI）运行镜像 阿里云ECI提供这个服务，你可以直接用现有的镜像也可以自己上传（就是上一步镜像服务里上传的镜像）按秒收费！不过作为hexo这种启用\u003e生成\u003e部署\u003e关闭的服务来说，花不了几毛钱\n然后就能看到我们上传的镜像 5 eci容器创建模板和eci命令行工具使用 参考文章这两篇足够: https://github.com/aliyuneci/eci-client-doc/blob/main/eci_run.md https://help.aliyun.com/document_detail/186961.html\n5.1 eci简介 https://www.aliyun.com/product/eci ECI是 Serverless 和容器化的弹性计算服务。您无需管理底层 ECS 服务器，只需要提供打包好的镜像，即可运行容器，与阿里云容器服务无缝对接并仅为容器实际运行消耗的资源付费。\n博主：比ECS云服务器灵活得多，本地用docker制作好镜像以后，上传，随启随用，用完就释放，成本可以很低,但如果连开一个月，并不会比ECS划算，详见本站ECI价格计算附表\n5.2 用模板创建eci 询问过阿里云客服，说在web控制面版里的这个功能已经下线了 不过没关系，我们还有命令行工具！ 安装：\nsudo bash -c \"$(curl -s https://eci-docs.oss-cn-beijing.aliyuncs.com/eci-client/1.0/install.sh)\" 然后配置你的阿里云信息\neci config set-context \\ --access-key-id **** \\ --access-secret **** \\ --region-id cn-shanghai \\ --security-group-id sg-**** \\ --v-switch-id vsw-**** 要指定自己的access-key-id和access-secret，地区以及安全组和虚拟交换机 建议这些东西在web上的控制台里准备好，会直观很多\n然后就可以直接创建一个容器了\neci run -n myeci centos:7 sleep 3600 指令很像docker run喝！很好，很有精神\n我们还可以编写yaml模板文件 然后执行\neci run -f eci.yaml -w 20 需要注意的事，如果使用了-f xxxx.yaml模板文件，除了-f和-w选项以外，其他选项都将被忽略，因为这些选项都是针对实例中某个容器的，如果模板中定义了多个容器，ECI将不知道这些选项应该作用于哪个容器 那么我自己的启动模板是这样的： hexo_debian_eci.yaml\nContainerGroupName: eci-hexo Cpu: \"0.5\" Memory: \"1\" Container: - Name: hexo Image: registry-vpc.cn-shanghai.aliyuncs.com/****:debian_V02_configured Command: [\"/bin/bash\",\"/service_start.sh\"] ImagePullPolicy: IfNotPresent Cpu: \"0.5\" Memory: \"1\" VolumeMount: - Name: hexo MountPath: /hexo ReadOnly: false - Name: vsftpd Image: registry-vpc.cn-shanghai.aliyuncs.com/****:vsftpd_debian_V01 Command: [\"/bin/bash\",\"/service_start.sh\"] ImagePullPolicy: IfNotPresent VolumeMount: - Name: hexo MountPath: /hexo ReadOnly: false - Name: ddns Image: registry-vpc.cn-shanghai.aliyuncs.com/****:ddns_go_V01 ImagePullPolicy: IfNotPresent EnvironmentVar: - FieldRefFieldPath: \"\" Key: DDNS_URL Value: mdwrite.winotmk.com Volume: - Name: hexo Type: NFSVolume NFSVolume: Server: ****.cn-shanghai.nas.aliyuncs.com Path: / ReadOnly: false 是不是挺像docker compose~\ncpu只给了0.5,Memory 1G，足够了，之前这套可是在树莓派3B上跑得溜溜得呢 对于阿里云ECI，CPU和Memory直接和成本挂钩，能少就少吧\n这里启了上面做好的3个镜像，分别实现hexo，ftp，还有ddns Command:写法目测类似dockerfile里的CMD，我习惯做好启动sh脚本就是为了方便这里再调用 最后一段声明了我的一个阿里云NAS卷，卷里的内容就是我的hexo目录 然后把它挂到hexo和ftp镜像上就好了\n值得一提的是ddns镜像还写了个环境变量DDNS_URL值为mdwrite.winotmk.com，这会修改ddns-go的解析配置\n然后执行\neci run -f hexo_debian_eci.yaml -w 20 不出意外的话会返回一个eci的id编号，打开web会发现已经创建成功了！ 6 hexo本地编辑环境设置————如何用VSCode舒服的写MD文档 6.1 VSCodeSSH FS插件配置 简单配置一下服务器地址和用户密码就可以把远程目录映射到工作区里，很方便 这里可以看到/root/hexo/Winblog目录下是我挂载的阿里云NAS网盘了\n6.2 Markdown Paste插件配置 一个很方便的在VScode里直接粘图的插件\n配置： 会用时间来命名图片 然后会将图片放入MD文件目录下的images下\n然后文件》首选项》键盘快捷方式 我将快捷键设置为ctrl+alt+a 配置完成！\n使用： 截图我习惯用Sinpaste，按F1就能截图 然后点右下角复制按钮 在VScode的markdown文档里ctrl+alt+a就能粘图了！ 图片文件会自动保存!\n6.2 VSCode的SFTP插件配置 先把images文件夹单独放到工作区里 然后在Ctrl+Shift+P打开命令面板，运行SFTP: config命令 sftp.json目录下会出现一个名为的基本配置文件.vscode 然后编辑 sftp.json\n{ \"name\": \"Hexo_images\", \"host\": \"mdwrite.winotmk.com\", \"protocol\": \"ftp\", \"port\": 21, \"username\": \"root\", \"password\": \"****\", \"remotePath\": \"/hexo/Winblog/source/images\", \"useTempFile\": false, \"openSsh\": false, \"uploadOnSave\": false, \"watcher\": { \"files\": \"**/*\", \"autoUpload\": true, \"autoDelete\": true }, \"syncOption\": { \"delete\": true } } \"watcher\"是用来设置自动更新的 这样我们在md里粘了图，就会自动上传到到ftp目录上\n参考： https://marketplace.visualstudio.com/items?itemName=Natizyskunk.sftp#remote-explorer 开启watcher模式，实现增加文件时自动上传目录同步 https://github.com/Natizyskunk/vscode-sftp/blob/master/FAQ.md#automatically-sync-both-ways-without-user-interaction\n","wordCount":"1602","inLanguage":"en","image":"http://localhost:12371/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:12371/posts/docker01/"},"publisher":{"@type":"Organization","name":"ExampleSite","logo":{"@type":"ImageObject","url":"http://localhost:12371/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:12371/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:12371/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:12371/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:12371/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:12371/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:12371/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行</h1><div class=post-meta>8 min&nbsp;·&nbsp;1602 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/Docker01.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>一口气步子迈得有大，慢慢记录一下,如果你碰巧看到这个文章，希望这个文章的某些部分对你有帮助，来源我已尽量在文章中标出，还有很多部分是自己敲的</p><p>了解ECI弹性容器：https://www.aliyun.com/product/eci
了解阿里云NAS文件存储：https://www.aliyun.com/product/nas</p><p><strong>为什么要用eci来运行hexo？</strong>
因为好玩，同时来学习从pull到发布到运行整个docker镜像的流程，也想给自己的hexo博客找个新家，酷酷的那种
本博客之前是由树莓派上的hexo生成，部署到github上的
最近在捣鼓docker，一时想不起来有什么灵活小巧的服务拿来用docker玩，那么想着干脆把树莓派上hexo这部分服务做成镜像，需要用的时候拿出来用用想必是极好的（这么一来好像树莓派又要吃灰了）
恰巧最近又在琢磨阿里云ECI容器服务，所以理论上是可以用我自己打包好的镜像的
最后成品的结构大致如下图：</p><p><img loading=lazy src=images/20230829140549.png></p><p>这里挂了3个镜像：
<strong>1.node.js+git+ssh+hexo</strong>
主要是此镜像——由node.js+hexo组成的运行hexo环境，用过的都了解hexo是基于node.js的，每次我们生成文章的时候都会<code>hexo g -d</code>，而运行这套需要一个环境容器
git和ssh主要是部署在github上用的，同时我习惯用VSCode的SSH FS来管理远程文件和写博客，主要是ssh连接，也方便我拿PuTTY和WinSCP远程登录管理
<strong>2.vsftpd</strong>
一个常用的ftp服务，我是在本地些完再上传的，用这个是因为我发现如果要给文章插入图片，我还需要手动用ssh上传到hexo对应目录里。而用VSCode的SSH FS可以帮我自动同步本地工作目录和云上即将生成静态网页的hexo目录，非常方便！
<strong>3.ddns</strong>
因为容器是即用即开，用完就释放的，每次开会新分配一个弹性IP做为外网接口，但是不想每次都去复制这个新的ip地址，那么就要用到动态域名解析，刚好我在阿里云上购买过一个我自己的域名，所以ddns这部分服务就拉出来做个镜像</p><p>还挂了一个NAS盘：
<img loading=lazy src=images/20230829142400.png>
挂载以后：
<img loading=lazy src=images/20230829142501.png>
可见我的hexo，主题，文章，图片等等都存放在里面，服务容器可以随便释放拉取，数据不会受到影响，几百M的NAS容量价格抹零后可以忽略不计</p><p>文章后面（第三部分）会说如何按我的需求构建定制这几个镜像，并上传到阿里云容器镜像ARK仓库以方便调用</p><p><strong>vsftpd</strong>还有<strong>ddns</strong>可以与主镜像<strong>node.js+hexo</strong>合并成一个大镜像吗？
<strong>当然可以</strong>，但我实际做了几次以后发现把ftp，ddns这样常用的服务功能单独拿出来会方便得多的多，毕竟我想起别得服务，也可以给他们挂上ftp等常用服务，我也可以选择不挂，这样容器的优势就体现出来了。我可以把单一的服务都做成单独的小镜像，需要哪个挂哪个，性能消耗也很小</p><p>整套下来有这些部分：</p><ol><li><strong>docker基本操作</strong></li><li><strong>已经启动的本地容器修改端口，启动容器时即启动服务等</strong></li><li><strong>打包制作自己的docker镜像(dockerfile)</strong></li><li><strong>docker镜像打包并上传到阿里云镜像库ARK</strong></li><li><strong>eci容器创建模板和eci命令行工具使用</strong></li><li><strong>hexo本地编辑环境设置————如何用VSCode舒服的写MD文档</strong></li></ol><p>附表：
群晖搭建私有镜像仓库和dockerengine设置
eci价格计算表</p><hr><h2 id=1-docker-基本操作>1. docker 基本操作<a hidden class=anchor aria-hidden=true href=#1-docker-基本操作>#</a></h2><p>博主吐槽一下，总觉得一些类似run，commit操作完全可以做成一个美观好用的UI控制软件，但是docker destop就是不做，然后大家都默认敲命令行是方便的，好用的。十分不解，可能需要ui的不会写ui，熟练使用命令行的也不需要什么ui吧，诶
——后面随着对docker了解的深入，明白它不是虚拟机，用得还是linux内核，这么一想，处处真是浓浓的linux味，现在能提供一个windows下的Docker Desktop桌面程序，已经非常得不错了！
资料网站：</p><p><a href=https://docs.docker.com/engine/reference/commandline/cli/>官方命令大全</a></p><p><a href=https://chunchengwei.github.io/ruan-jian/ji-yu-docker-de-hexo-bo-ke-da-jian/>基于Docker的Hexo博客搭建</a></p><p>这个基本操作写得还行下次爬一篇下来吧：</p><p><a href=https://yingclin.github.io/2018/docker-basic.html>[小抄] Docker 基本命令</a></p><h3 id=11-运行容器>1.1 运行容器<a hidden class=anchor aria-hidden=true href=#11-运行容器>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -it -d --name <span class=o>[</span>container-name<span class=o>]</span> -p 8088:80 <span class=o>[</span>image-name<span class=o>]</span>
</span></span></code></pre></div><p>这里是将容器内的80端口映射到宿主机的8088端口</p><p>参数说明</p><p><code>-d</code> 表示后台运行容器
<code>-t</code> 为docker分配一个伪终端并绑定到容器的标准输入上
<code>-i</code> 是让容器的标准输入保持打开状态
<code>-p</code> 指定映射端口</p><p>还能这么写：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run --name mssql -e <span class=s1>&#39;ACCEPT_EULA=Y&#39;</span> -e <span class=s1>&#39;SA_PASSWORD=xxxx&#39;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>     -p 1433:1433  <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>     -d mssql-2019-with-cimb
</span></span></code></pre></div><p><code>\</code>应该是可以换行表述
<code>-e</code> 定义环境变量（通常制作镜像的时候应该已经写好了，或者在容器内做好自动脚本，run时候再写毕竟是不方便的）</p><h3 id=12-将此容器-commit-保存为新镜像>1.2 将此容器 commit 保存为新镜像：<a hidden class=anchor aria-hidden=true href=#12-将此容器-commit-保存为新镜像>#</a></h3><p>格式：</p><pre tabindex=0><code>docker commit container-id new-name
</code></pre><p>container-id也可以是已有容器的名字，例如：</p><pre tabindex=0><code>docker commit node-test nodehexo
</code></pre><p>nodehexo这里是新镜像名</p><h3 id=13-启动docker引擎时自动运行docker容器>1.3 启动docker引擎时自动运行docker容器：<a hidden class=anchor aria-hidden=true href=#13-启动docker引擎时自动运行docker容器>#</a></h3><p><a href=https://blog.csdn.net/londa/article/details/97611947>https://blog.csdn.net/londa/article/details/97611947</a></p><p>ps:上面链接文章还有:修改docker容器的挂载路径，修改docker默认的存储位置</p><pre tabindex=0><code>docker run --restart=always
</code></pre><p>有时候，我们创建容器时忘了添加参数 <code>--restart=always</code> ，当 Docker 重启时，容器未能自动启动，</p><p>现在要添加该参数怎么办呢，方法有二：</p><p>1、Docker 命令修改</p><pre tabindex=0><code>docker container update --restart=always 容器名字
</code></pre><p>我实际运行时，可以支持同时配置多个容器id，比如（其中container关键字可以忽略不写）</p><pre tabindex=0><code>docker update 87cd61ad7f7c f488b0479f24 2109903220ce 1fb346ea1a46 --restart=no
</code></pre><p>2、直接改配置文件</p><p>首先停止容器，不然无法修改配置文件</p><p>配置文件路径为：<code>/var/lib/docker/containers/</code> 容器ID</p><p>在该目录下找到一个文件 hostconfig.json ，找到该文件中关键字 RestartPolicy</p><p>修改前配置：<code>"RestartPolicy":{"Name":"no","MaximumRetryCount":0}</code></p><p>修改后配置：<code>"RestartPolicy":{"Name":"always","MaximumRetryCount":0}</code></p><p>最后启动容器。</p><h3 id=14-有关dockerfile>1.4 有关dockerfile<a hidden class=anchor aria-hidden=true href=#14-有关dockerfile>#</a></h3><p>dockerfile是用来构建镜像的脚本
主要参考这几篇：
<a href=https://www.runoob.com/docker/docker-dockerfile.html>https://www.runoob.com/docker/docker-dockerfile.html</a>
<a href=https://developer.aliyun.com/article/484262>https://developer.aliyun.com/article/484262</a>
<a href=https://juejin.cn/s/docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC>docker容器启动时自动启动脚本</a></p><h4 id=编写dockerfile>编写dockerfile<a hidden class=anchor aria-hidden=true href=#编写dockerfile>#</a></h4><p>我的第一个dockerfile：
简单做个测试，在之前做的镜像上加了条启动命令
<strong>Dockerfile</strong> （文件没有后缀)</p><pre tabindex=0><code>## Set the base image to CentOS  基于nodehexo
FROM nodehexo:V4
COPY ddnsstart.sh /ddnsstart.sh
ENTRYPOINT [&#34;/bin/bash&#34;, &#34;/ddnsstart.sh&#34;]
</code></pre><p>很简单:
<code>FROM</code>基于<code>nodehexo:V4</code>镜像构建
<code>COPY</code>就是拷贝构建目录下的<code>ddnsstart.sh</code>到之后构建好的镜像根目录下
<code>ENTRYPOINT</code>会在用新镜像开启容器时再执行，这里会在执行<code>/bin/bash</code>里执行<code>/ddnsstart.sh</code></p><p>一个dockerfile只能有一条<code>ENTRYPOINT</code>，多个也只执行最后一个,<code>CMD</code>也是如此
如果 Dockerfile 中如果存在多个 <code>CMD</code> 指令，仅最后一个生效。</p><p>关于<code>CMD</code>还有些写法，比如还可以
<code>CMD service ssh start && service XXX start && tail -f /etc/passwd</code>一起执行多道指令
这在构建镜像的时候会被自动转换为类似：
<code>CMD ["/bin/sh", "service ssh start","service XXX start","tail -f /etc/passwd"]</code></p><p><code>tail -f /etc/passwd</code>作用在于防止docker容器开启后立即关闭见下面段落</p><p>CMD格式：</p><pre tabindex=0><code>CMD &lt;shell 命令&gt; 
CMD [&#34;&lt;可执行文件或命令&gt;&#34;,&#34;&lt;param1&gt;&#34;,&#34;&lt;param2&gt;&#34;,...] 
CMD [&#34;&lt;param1&gt;&#34;,&#34;&lt;param2&gt;&#34;,...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数
</code></pre><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认是 <code>bin/sh</code></p><p><strong>ddnsstart.sh文件</strong></p><pre tabindex=0><code>#!/bin/bash
root/ddnsAPP/ddns -c root/ddnsAPP/config.json
echo &#34;更新mcwrite.winotmk.com解析&#34;
service ssh start
tail -f /etc/passwd
</code></pre><p>这里都是简单的shell命令了
<code>root/ddnsAPP/ddns -c root/ddnsAPP/config.json</code>是执行ddns更新，解析新的ip到域名上，因为我这个镜像打算放到阿里云ECI里跑，每次新拉的IP当然都不一样（一直占着一个IP会产生费用，没必要）</p><p>同时我还执行了启动ssh服务，有的时候会用上ssh，因为我把网盘挂载到了容器内
<code>tail -f /etc/passwd</code>这里起到的比较重要的占着进程的作用，详见下面：</p><p>*关于 <code>CMD</code> 或 <code>entrypoint</code> 构建后 <code>docker run -dit</code> 为何容器依然秒退
<a href=https://www.zhihu.com/question/344939968>https://www.zhihu.com/question/344939968</a>
是因为使用了CMD或者entrypoint去service *** start命令作为容器启动命令，主进程执行完结束了，容器也就结束了</p><blockquote><p>dockerfile 写清楚 entrypoint 和 cmd，启动脚本如果立刻会退出，那么在最后添加 tail -f 某个日志文件。或者 监听某个端口或者进程。
方法1: 设置容器启动时就启动服务ENTRYPOINT [&ldquo;flask&rdquo;, &ldquo;run&rdquo;, &ldquo;-h&rdquo;, &ldquo;0.0.0.0&rdquo;, &ldquo;-p&rdquo;, &ldquo;80&rdquo;]
方法2:CMD service apache2 start && tail -F /var/log/apache2/error.log再极端点 sleep infinite</p></blockquote><h4 id=用dockerfile构建镜像>用dockerfile构建镜像<a hidden class=anchor aria-hidden=true href=#用dockerfile构建镜像>#</a></h4><p><code>docker build -t &lt;新镜像名字:标签> .</code>
比如<code>docker build -t nodehexo:V5 .</code>
请不要忘记最后一个<code>.</code>，这表示在当前目录下构建
用这条指令前先<code>CD</code>到dockerfile文件所放置的目录
比如我先<code>CD ./dockerbuild</code>，因为我的文件放在<code>用户/dockerbuild</code>目录下面
然后就拥有了属于构建的镜像！</p><h4 id=141-entrypoint与cmd的区别>1.4.1 ENTRYPOINT与CMD的区别<a hidden class=anchor aria-hidden=true href=#141-entrypoint与cmd的区别>#</a></h4><p>Docker 的 ENTRYPOINT 和 CMD 参数探秘
<a href=https://aws.amazon.com/cn/blogs/china/demystifying-entrypoint-cmd-docker/>https://aws.amazon.com/cn/blogs/china/demystifying-entrypoint-cmd-docker/</a></p><h4 id=142-dockerfile构建镜像时如何选择from镜像以减小镜像体积>1.4.2 dockerfile构建镜像时如何选择FROM镜像以减小镜像体积<a hidden class=anchor aria-hidden=true href=#142-dockerfile构建镜像时如何选择from镜像以减小镜像体积>#</a></h4><p>busybox：
<a href=https://blog.csdn.net/hknaruto/article/details/70229896>https://blog.csdn.net/hknaruto/article/details/70229896</a>
alpine：
<a href=https://hub.docker.com/_/alpine>https://hub.docker.com/_/alpine</a>
alpine包管理器APK：
<a href=https://wangchujiang.com/linux-command/c/apk.html>https://wangchujiang.com/linux-command/c/apk.html</a>
<a href=https://wiki.alpinelinux.org/wiki/Alpine_Package_Keeper>https://wiki.alpinelinux.org/wiki/Alpine_Package_Keeper</a></p><h3 id=15-将已有镜像打包带走使用将打包来的镜像>1.5 将已有镜像打包带走/使用将打包来的镜像<a hidden class=anchor aria-hidden=true href=#15-将已有镜像打包带走使用将打包来的镜像>#</a></h3><p><a href=https://zhuanlan.zhihu.com/p/348849578>https://zhuanlan.zhihu.com/p/348849578</a></p><h4 id=将镜像保存为本地文件>将镜像保存为本地文件<a hidden class=anchor aria-hidden=true href=#将镜像保存为本地文件>#</a></h4><p>可以使用Docker save命令</p><pre tabindex=0><code>docker save -o mssql-2019-with-cimb.tar mssql-2019-with-cimb
</code></pre><p>会得到一个<code>mssql-2019-with-cimb.tar</code>文件，就可以随身携带啦</p><p>从文件载入镜像</p><h4 id=从文件载入镜像>从文件载入镜像<a hidden class=anchor aria-hidden=true href=#从文件载入镜像>#</a></h4><p>使用Docker load命令:</p><pre tabindex=0><code>docker load --input mssql-2019-with-cimb.tar
</code></pre><h3 id=16-docker挂载本地目录>1.6 docker挂载本地目录<a hidden class=anchor aria-hidden=true href=#16-docker挂载本地目录>#</a></h3><p>有关volume:https://docs.docker.com/storage/volumes/
<a href=https://docs.docker.com/get-started/05_persisting_data/>https://docs.docker.com/get-started/05_persisting_data/</a>
<a href=https://blog.csdn.net/zz00008888/article/details/131924286>https://blog.csdn.net/zz00008888/article/details/131924286</a></p><p>在Docker中，可以使用“-v”选项来挂载本地目录。该选项需要两个参数，分别是本地目录路径和容器内目录路径。例如，以下命令将本地目录“/home/user/app”挂载到容器内的“/app”目录中：</p><pre tabindex=0><code>docker run -v /home/user/app:/app my_image
</code></pre><p>这将使得容器可以访问本地目录中的文件，并且任何对该目录的更改也会反映在容器中。</p><p><strong>Docker挂载本地目录到已有容器</strong></p><p>除了在容器启动时挂载本地目录外，还可以在运行时将本地目录挂载到正在运行的容器中。要实现这一点，可以使用“docker cp”命令将本地目录复制到容器中，并使用“docker exec”命令在容器中执行命令。例如，以下命令将本地目录“/home/user/data”挂载到正在运行的容器中：</p><pre tabindex=0><code>docker cp /home/user/data my_container:/data
docker exec -it my_container bash
</code></pre><p>在容器中，可以访问挂载的目录“/data”，并且任何对该目录的更改也会反映在本地文件系统中。</p><h3 id=17-其他一些操作>1.7 其他一些操作<a hidden class=anchor aria-hidden=true href=#17-其他一些操作>#</a></h3><pre tabindex=0><code># ****************************** 容器 ****************************** #
# 查看正在运行的容器
$ docker ps
# 查看所有容器
$ docker ps -a
# 启动/停止某个容器
$ docker start/stop id/name
# 以交互方式启动一个容器
$ docker start -i id/name
# 进入某个容器(使用exit退出后容器也跟着停止运行)
$ docker attach id/name
# 启动一个伪终端以交互式的方式进入某个运行的容器（使用exit退出后容器不停止运行）
$ docker exec -it id/name
# 删除某个容器
$ docker rm id/name
# 复制ubuntu容器并且重命名为test且运行，然后以伪终端交互式方式进入容器，运行bash
$ docker run --name test -ti ubuntu /bin/bash

# ****************************** 镜像 ****************************** #
# 查看本地镜像
$ docker images
# 删除某个镜像
$ docker rmi id/name
# 基于当前目录下的Dockerfile，创建一个名为name:flag的镜像
$ docker build -t name:flag .
</code></pre><h2 id=2-已启动容器操作>2. 已启动容器操作<a hidden class=anchor aria-hidden=true href=#2-已启动容器操作>#</a></h2><h3 id=21-win10下docker给已存在的容器添加端口映射的方法>2.1 win10下docker给已存在的容器添加端口映射的方法<a hidden class=anchor aria-hidden=true href=#21-win10下docker给已存在的容器添加端口映射的方法>#</a></h3><p>博主再吐槽一下，这个调试阶段如此常用的修改容我端口，改起来却像游戏作弊，不觉得这个要做简单很难，怕只是没做
<a href=https://mdnice.com/writing/25822ca29531424d9b68d7feb8273a82>https://mdnice.com/writing/25822ca29531424d9b68d7feb8273a82</a>
<a href=https://blog.csdn.net/Taysuesue/article/details/126706394>https://blog.csdn.net/Taysuesue/article/details/126706394</a>
<a href=https://www.cnblogs.com/kingsonfu/p/11578073.html>https://www.cnblogs.com/kingsonfu/p/11578073.html</a></p><p>查看容器已映射的端口（dockerdeskUI内也可看见）</p><pre tabindex=0><code>docker port 容器ID/容器名
</code></pre><p>先停止容器</p><pre tabindex=0><code>docker stop {容器的名称或者 id }
</code></pre><p>查看容器完整的 <code>hash_of_the_container</code> 数值：</p><pre tabindex=0><code>docker inspect {容器的名称或者 id } | grep Id

# 比如：
docker inspect cbe26510c276 | grep Id
# 会得到如下结果：
# &#34;Id&#34;: &#34;cbe26510c276fa9a4487a8c2af8cbb49410f2a5305149d2b26eb8ce37c777d00&#34;
</code></pre><p><strong>如果主机是linux（mac应该也行没测）</strong>
打开 hostconfig.json 配置文件:</p><pre tabindex=0><code>vim /var/lib/docker/containers/{hash_of_the_container}/hostconfig.json
</code></pre><p>记得还要改 config.v2.json，改法同下面的win10
<strong>如果是win10</strong>
1.先找到容器的配置文件，首先我的电脑地址栏输\wsl$\进入到网络文件夹上,在一步一步找到容器目录</p><pre tabindex=0><code>\\wsl$\docker-desktop-data\data\docker\containers
</code></pre><p>2.点击进入相应容器ID文件夹，打开后修改其中的 <code>config.v2.json</code> 和 <code>hostconfig.json</code></p><p><strong>hostconfig.json</strong></p><pre tabindex=0><code>&#34;PortBindings&#34;:{&#34;22/tcp&#34;:[{&#34;HostIp&#34;:&#34;&#34;,&#34;HostPort&#34;:&#34;50022&#34;}],&#34;3306/tcp&#34;:[{&#34;HostIp&#34;:&#34;&#34;,&#34;HostPort&#34;:&#34;53306&#34;}],&#34;6379/tcp&#34;:[{&#34;HostIp&#34;:&#34;&#34;,&#34;HostPort&#34;:&#34;56379&#34;}]}
</code></pre><p>这里的<code>HostPort</code>字面意思就是宿主机的端口，所以即：
容器内22>外部5022访问
容器内3306>外部53306访问
容器内6379>外部56379访问</p><p><strong>config.v2.json</strong> 有两处需要添加，只修改一处不生效</p><pre tabindex=0><code>&#34;ExposedPorts&#34;:{&#34;22/tcp&#34;:{},&#34;3306/tcp&#34;:{},&#34;6379/tcp&#34;:{}}
</code></pre><pre tabindex=0><code>&#34;Ports&#34;:{&#34;22/tcp&#34;:[{&#34;HostIp&#34;:&#34;0.0.0.0&#34;,&#34;HostPort&#34;:&#34;50022&#34;}],&#34;3306/tcp&#34;:[{&#34;HostIp&#34;:&#34;0.0.0.0&#34;,&#34;HostPort&#34;:&#34;53306&#34;}],&#34;6379/tcp&#34;:[{&#34;HostIp&#34;:&#34;0.0.0.0&#34;,&#34;HostPort&#34;:&#34;56379&#34;}]}
</code></pre><p>不过我实际只改了这里的<code>"ExposedPorts"</code>貌似就行了</p><p>然后重启<strong>docker</strong>，注意不只是重启容器，我一开始只重启容器发现白改了</p><pre tabindex=0><code># 重启 docker
service docker restart
</code></pre><p>或者在系统右下角，点击Restart重启整个 Docker 服务，然后再重启 Container 即可正常使用</p><h3 id=22-docker容器内服务开机自启动实现方案以ssh服务为例>2.2 docker容器内服务开机自启动实现方案（以ssh服务为例）<a hidden class=anchor aria-hidden=true href=#22-docker容器内服务开机自启动实现方案以ssh服务为例>#</a></h3><p><strong>注意，2.2这段内容随着对docker和linux了解的深入觉得有不妥，但是作为学习的过程还是保留</strong></p><p><a href=https://blog.csdn.net/qq_38603541/article/details/124028994>https://blog.csdn.net/qq_38603541/article/details/124028994</a></p><p>因为我后续打算用类似vscode里的remote-ssh来管理容器内，也想用winscp等好用的工具可以接进来，还是有必要开个ssh
<strong>解决方案</strong>
1、正常我们在linux操作系统内设置服务自启动的方法一般都是使用systemctl。</p><p>systemctl enable ssh
2、但是，一般在docker容器内我们一般不这么干，因为容器内没有systemctl权限……</p><p>3、我们依然还是使用脚本的形式将ssh设为自启，只不过这个的这个脚本和我们使用Dockerfile的脚本不一样。</p><p>4、在 /root 目录下新建一个 start_ssh.sh文件，并给予该文件可执行权限。</p><pre tabindex=0><code>touch /root/start_ssh.sh
 
vim /root/start_ssh.sh
 
chmod +x /root/start_ssh.sh
</code></pre><p>5、start_ssh.sh 脚本的内容，如下：</p><pre tabindex=0><code>#!/bin/bash
 
LOGTIME=$(date &#34;+%Y-%m-%d %H:%M:%S&#34;)
echo &#34;[$LOGTIME] startup run...&#34; &gt;&gt;/root/start_ssh.log
service ssh start &gt;&gt;/root/start_ssh.log
#service mysql start &gt;&gt;/root/star_mysql.log   //其他服务也可这么实现
</code></pre><p>6、将start_ssh.sh脚本添加到启动文件中</p><pre tabindex=0><code>vim /root/.bashrc
</code></pre><p>7、在 .bashrc 文件末尾加入如下内容：</p><pre tabindex=0><code># startup run
if [ -f /root/start_ssh.sh ]; then
      . /root/start_ssh.sh
fi
</code></pre><p>8、保存后，等下次重启容器的时候，添加的服务也就跟着重启了。</p><p>docker容器在启动的时候，会自动执行的是~/.bashrc文件，所以，环境变量需要配置在该文件内，这样镜像启动时，可自动执行该文件，使环境变量生效。</p><p><strong>正确的理解是：</strong>
/root/.bashrc会在容器启动的时候自动执行这句十分欠妥，
准确的来讲是<strong>root用户登录bash的时候会执行，每次开新的bash shell也会执行一遍</strong>
如果dockerfile内定义了ENTRYPOINT或者CMD执行类似：</p><pre tabindex=0><code>ENTRYPOINT [ &#34;/bin/bash&#34;,&#34;-c&#34;,&#34;service apache2 start&#34; ]
</code></pre><p>那么对于容器来说PID 1号进程就是bash（apache是bash的子进程），也确实会跑一遍.bashrc内的内容，但是这不代表所有容器启动时一定会启动bash shell，也可能直接是个java进程，也可能是dumb-int，更多时候可能是sh shell，这应该都不会触发.bashrc
所以如果想要在容器启动时自动启动一个服务，推荐写在dockerfile里，比如</p><pre tabindex=0><code>COPY start.sh /
ENTRYPOINT [ &#34;sh&#34;,&#34;/start.sh&#34; ]
</code></pre><p>然后再在start.sh里写上你需要启动的服务</p><pre tabindex=0><code>#!/bin/sh
service ssh restart
service apache2 restart
</code></pre><p>以及如果确实有很多个服务需要启，考虑使用类似docker compose启多个镜像，每个镜像跑单个服务</p><h4 id=221-拓展bashrc-etcbashrc-etcprofile三个文件的区别>2.2.1 拓展：~/.bashrc /etc/bashrc /etc/profile三个文件的区别<a hidden class=anchor aria-hidden=true href=#221-拓展bashrc-etcbashrc-etcprofile三个文件的区别>#</a></h4><p><a href=https://segmentfault.com/q/1010000003793341>https://segmentfault.com/q/1010000003793341</a></p><h2 id=3-打包制作自己的docker镜像dockerfile>3 打包制作自己的docker镜像(dockerfile)<a hidden class=anchor aria-hidden=true href=#3-打包制作自己的docker镜像dockerfile>#</a></h2><p>dockerfile是告诉docker engine如何构建镜像的脚本</p><h3 id=31-nodejsgithexo镜像>3.1 node.js+git+hexo镜像<a hidden class=anchor aria-hidden=true href=#31-nodejsgithexo镜像>#</a></h3><p>其实这部分镜像做了两遍，第一遍直接拉的官方node镜像，然后发现ssh不好装，走了很多弯路，随着对docker了解的加深，最后我自己做了dockerfile重构了这部分镜像</p><h4 id=311-dockerfile>3.1.1 Dockerfile<a hidden class=anchor aria-hidden=true href=#311-dockerfile>#</a></h4><p><strong>dockerfileV02（可以没有后缀）</strong></p><pre tabindex=0><code>#这个包将包含：node-v29.5.0  git ssh hexo
#hexo环境目录/hexo/Winblog
FROM debian:stable-slim
LABEL maintainer=&#34;winotmk&#34; web=&#34;md.winotmk.com&#34; Ver=&#34;02&#34;
#ADD有自动解压功能
ADD node-v20.5.0-linux-x64.tar.xz /
    #移动node二进制文件到目录
RUN mkdir -p /usr/local/nodejs &amp;&amp;\
    mv node-v20.5.0-linux-x64 /usr/local/nodejs &amp;&amp;\
    #mk hexo目录
    mkdir -p /hexo/Winblog &amp;&amp;\
    apt-get update &amp;&amp;\
    #安装SSH 安装GIT
    apt-get install -y --no-install-recommends openssh-server git-core &amp;&amp;\
    apt-get autoremove -y &amp;&amp;\
    apt-get clean
#node和npm环境变量
ENV PATH=&#34;/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH&#34;
#安装hexo
WORKDIR /hexo/Winblog
RUN npm install -g hexo-cli
#hexo环境变量
ENV PATH=&#34;$PATH:/hexo/Winblog/node_modules/.bin&#34;
#更新ssh设置
COPY sshd_config /etc/ssh/
#环境变量设置
COPY .profile /root/
#设置启动脚本
COPY hexo_debian_service_start.sh /service_start.sh
CMD [&#34;/bin/bash&#34;,&#34;/service_start.sh&#34;]
</code></pre><p>基本上都是些安装命令以及配置环境变量
安装了<code>hexo</code>,<code>git</code>,<code>ssh</code>,<code>node</code>
这是优化过了的第二版，主要是第二版使用了<code>ADD</code>，它基本和<code>COPY</code>一样，都可以把某个构建目录下的文件打入正在生成的镜像里，但当用ADD在执行 &lt;源文件> 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径>。说白了ADD会帮我自动解压
在这里我还设置了ssh（但是没有配置root密码）</p><p>而我的第一版开头：
<strong>dockerfileV01</strong></p><pre tabindex=0><code>FROM debian:stable-slim

COPY node-v20.5.0-linux-x64.tar.xz /node-v20.5.0-linux-x64.tar.xz
RUN apt-get update &amp;&amp;\
    apt-get install -y xz-utils --no-install-recommends &amp;&amp;\
    tar -xvf node-v20.5.0-linux-x64.tar.xz &amp;&amp;\
    mkdir -p /usr/local/nodejs &amp;&amp;\
    mv node-v20.5.0-linux-x64 /usr/local/nodejs &amp;&amp;\
    #删除xz包
    apt-get purge -y xz-utils &amp;&amp; \
    apt-get autoremove -y &amp;&amp; \
    apt-get clean &amp;&amp; \
    #删除node-v20.5.0-linux-x64.tar.xz包
    rm node-v20.5.0-linux-x64.tar.xz

#node和npm环境变量
ENV PATH=&#34;/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH&#34;
</code></pre><p>当时不知道<code>ADD</code>的功能，使用 <code>COPY</code>拷贝整个.tar.xz包结果debian还没有.xz包解压功能，需要安装<code>xz-utils</code><a href=https://blog.csdn.net/weixin_43502175/article/details/129547250>详见</a>，凭空多出好几行</p><p><strong>为什么要用二进制包安装呢node.js呢？</strong>
因为实测如果用<code>apt-get install nodejs</code>安装，
或者<code>curl -fsSL https://deb.nodesource.com/setup_19.x | bash - &&\ apt-get install -y nodejs</code><a href=https://github.com/nodesource/distributions>命令出处</a>，
安装出来镜像体积就是会楞大出好几百MB</p><h4 id=312-nodejsgithexo镜像copy的文件>3.1.2 node.js+git+hexo镜像COPY的文件<a hidden class=anchor aria-hidden=true href=#312-nodejsgithexo镜像copy的文件>#</a></h4><p><strong>.profile</strong></p><pre tabindex=0><code># ~/.profile: executed by Bourne-compatible login shells.

if [ &#34;$BASH&#34; ]; then
  if [ -f ~/.bashrc ]; then
    . ~/.bashrc
  fi
fi

mesg n 2&gt; /dev/null || true

export PATH=&#34;/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH&#34;
export PATH=&#34;$PATH:/hexo/Winblog/node_modules/.bin&#34;
</code></pre><p>为了防止镜像上云后莫名其妙的原因导致环境变量出问题，脚本里再跑一遍，这俩<code>export PATH</code>其实dockerfile里设置过</p><p><strong>sshd_config是什么</strong>
ssh的设置
参考：https://blog.csdn.net/weixin_34910922/article/details/125193597
主要改了两条</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#vim /etc/ssh/sshd_config</span>
</span></span><span class=line><span class=cl>PermitRootLogin yes <span class=c1>#root登陆权限</span>
</span></span><span class=line><span class=cl>PasswordAuthentication yes <span class=c1>#密码权限</span>
</span></span></code></pre></div><p>等于我们预先改好了配置文件，在构建的时候再把配置放入容器里面</p><p><strong>hexo_debian_service_start.sh</strong></p><pre tabindex=0><code>#!/bin/bash
. ~/.profile
LOGTIME=$(date &#34;+%Y-%m-%d %H:%M:%S&#34;)
echo &#34;[$LOGTIME] startup run...&#34; &gt;&gt;/start_ssh.log
service ssh start &gt;&gt;/start_ssh.log
tail -f /start_ssh.log
</code></pre><p>启动脚本，主要启动了ssh服务，并且用<code>tail -f</code>让这个容器一直运行以方便我们来连接</p><h4 id=313-开始构建镜像>3.1.3 开始构建镜像<a hidden class=anchor aria-hidden=true href=#313-开始构建镜像>#</a></h4><p>先<code>CD</code>到Dockerfile所在的目录
<img loading=lazy src=images/20230829135356.png></p><pre tabindex=0><code>docker build -t hexo_debian:V02 -f dockerfileV02 .
</code></pre><p>格式是</p><pre tabindex=0><code>docker build -t 镜像名:tag -f Dockerfile文件名 .
</code></pre><p>注意<code>.</code>不要落下！</p><p>这样我们的镜像就做好了！</p><p>本节参考资料：
二进制手动安装node参考：
<a href=https://github.com/nodejs/help/wiki/Installation>https://github.com/nodejs/help/wiki/Installation</a>
<a href=https://blog.51cto.com/u_13460811/4901015>https://blog.51cto.com/u_13460811/4901015</a></p><p>一些关于dockerfile指令的说明：
较详细： <a href=https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy>https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy</a>
<a href=https://blog.csdn.net/qq_35528657/article/details/127244194>https://blog.csdn.net/qq_35528657/article/details/127244194</a>
<a href=https://www.runoob.com/docker/docker-dockerfile.html>https://www.runoob.com/docker/docker-dockerfile.html</a></p><p>在dockerfile里用apt-get包管理的建议：
<a href=https://ubuntu.com/blog/we-reduced-our-docker-images-by-60-with-no-install-recommends>https://ubuntu.com/blog/we-reduced-our-docker-images-by-60-with-no-install-recommends</a>
<a href=https://www.metricfire.com/blog/how-to-build-optimal-docker-images/>https://www.metricfire.com/blog/how-to-build-optimal-docker-images/</a></p><p>hexo所需环境安装说明：
<a href=https://hexo.io/zh-cn/docs/index.html>https://hexo.io/zh-cn/docs/index.html</a></p><h4 id=314-测试镜像功能>3.1.4 测试镜像功能<a hidden class=anchor aria-hidden=true href=#314-测试镜像功能>#</a></h4><p>来启个容器试试！</p><pre tabindex=0><code>docker run -it -d -p 22:22 --name hexo_debian hexo_debian:V02
</code></pre><p>这里开放了22端口来方便验证ssh服务和登录ssh没有问题
启动成功！
容器内执行来验证服务状态都正常：</p><pre tabindex=0><code>ssh
node -v
git -v
</code></pre><p>输出：
<img loading=lazy src=images/20230829124045.png>
可以看见一切正常！</p><h4 id=315-设置和再打包镜像>3.1.5 设置和再打包镜像<a hidden class=anchor aria-hidden=true href=#315-设置和再打包镜像>#</a></h4><h5 id=设置>设置<a hidden class=anchor aria-hidden=true href=#设置>#</a></h5><p>毕竟自用镜像，我习惯直接把比如ssh密钥之类全都配置好，再<code>commit</code>为一个新镜像，以后就再也不用输密码了，这样确实不安全，但是自己的hexo博客而已，何必为难自己呢
接下来设置root密码和重启ssh服务
<img loading=lazy src=images/20230829124114.png></p><pre tabindex=0><code>passwd root
#然后敲自己设置的密码
service ssh restart
</code></pre><p>尝试使用PuTTY进行SSH <a href=mailto:root@127.0.0.1>root@127.0.0.1</a>登录：
<img loading=lazy src=images/20230829123658.png>
成功!!!
接下来配置git和ssh，要生成新的ssh公钥
详见：https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent
<img loading=lazy src=images/20230829124332.png></p><pre tabindex=0><code>ssh-keygen -t ed25519 -C &#34;github邮箱@qq.com&#34;
</code></pre><p>得到密钥默认在<code>/root/.ssh/id_ed25519.pub</code>
<img loading=lazy src=images/20230829124753.png>
在Github的头像点Setting然后点右上角击<strong>New SSH key</strong>，把id_ed25519.pub内容粘贴进即可！
测试SSH连接：</p><pre tabindex=0><code>ssh -T git@github.com
</code></pre><p><img loading=lazy src=images/20230829125208.png>
这样就连上了！
需要进行一个小设置：</p><pre tabindex=0><code>git config --global user.email &#34;you@example.com&#34;
</code></pre><p>这样以后使用<code>hexo d</code>的时候就能无脑部署了</p><h5 id=再打包>再打包<a hidden class=anchor aria-hidden=true href=#再打包>#</a></h5><p>为了存下我们配置好的连接，制作成最终镜像方便eci云上调用，把现有容器再commit一次</p><pre tabindex=0><code>docker commit hexo_debian hexo_debian:V02-configured
</code></pre><p>成了！得到了<code>hexo_debian:V02-configured</code>作为我最后准备上传至ECI云的镜像</p><hr><h4 id=316-附一些命令参考>3.1.6 附一些命令参考<a hidden class=anchor aria-hidden=true href=#316-附一些命令参考>#</a></h4><h5 id=如何用ssh连接-docker-容器>如何用ssh连接 docker 容器<a hidden class=anchor aria-hidden=true href=#如何用ssh连接-docker-容器>#</a></h5><p><a href=https://blog.csdn.net/weixin_34910922/article/details/125193597>https://blog.csdn.net/weixin_34910922/article/details/125193597</a></p><p>1.修改root密码</p><pre tabindex=0><code>$ passwd root
输入密码：123456(自己决定)
</code></pre><p>2.安装Openssh</p><pre tabindex=0><code>sudo apt-get update # 更新源
sudo apt-get upgrade # 更新系统软件
apt-get install -y openssh-server
</code></pre><p>3.修改ssh配置,允许root登录
<a href=https://blog.csdn.net/weixin_43343144/article/details/102494830>https://blog.csdn.net/weixin_43343144/article/details/102494830</a>
<strong>【非常重要】在/etc/ssh/ssh_config中没有PermitRootLogin yes选项的话，就要在sshd_config文件中寻找！</strong></p><pre tabindex=0><code>vim /etc/ssh/sshd_config
PermitRootLogin yes #root登陆权限
PasswordAuthentication yes #密码权限
</code></pre><p>4.启动ssh服务/重启服务</p><pre tabindex=0><code>service ssh start
service ssh restart
</code></pre><h5 id=安装hexo>安装hexo<a hidden class=anchor aria-hidden=true href=#安装hexo>#</a></h5><pre tabindex=0><code>npm install hexo-cli -g
</code></pre><h5 id=ssh远程登录这个镜像>SSH远程登录这个镜像<a hidden class=anchor aria-hidden=true href=#ssh远程登录这个镜像>#</a></h5><p>之前在本机docker内已经配好了ssh服务，讲道理应该启动则开启ssh但是不知为啥没有自动启动，以后再研究吧
打开Workbench远程连接，启动ssh
由于我启用ECI时开通了弹性公网IP，所以我可以通过这个IP:22用ssh来登录
<img loading=lazy src=images/20230811153438.png>
使用PuTTY工具登录成功！！
<img loading=lazy src=images/20230811153400.png>
多么令人振奋的一刻</p><hr><h3 id=32-vsftpd镜像>3.2 vsftpd镜像<a hidden class=anchor aria-hidden=true href=#32-vsftpd镜像>#</a></h3><p>这个镜像比较简单，只跑ftp服务，主要在写作的时候方便上传图片</p><h4 id=321-dockerfile>3.2.1 Dockerfile<a hidden class=anchor aria-hidden=true href=#321-dockerfile>#</a></h4><p><strong>vsftpd_dockerfileV01</strong></p><pre tabindex=0><code>#这个包将包含：vsftp（root登录）
FROM debian:stable-slim
LABEL maintainer=&#34;winotmk&#34; web=&#34;md.winotmk.com&#34; Ver=&#34;01&#34;
RUN apt-get update &amp;&amp;\
    apt-get install -y vsftpd --no-install-recommends &amp;&amp;\
    apt-get autoremove -y &amp;&amp;\
    apt-get clean &amp;&amp;\
    echo &#34;root:yourpasswd&#34; | chpasswd
COPY ftpusers /etc/
COPY vsftpd.conf /etc/
COPY service_start.sh /service_start.sh
CMD [&#34;/bin/bash&#34;,&#34;/service_start.sh&#34;]
</code></pre><p>比较简单的dockerfile，就装了个vsftpd服务，然后拷贝了一些设置文件
如果要在dockerfile里配置用户密码可以这么写：</p><pre tabindex=0><code>echo &#34;root:yourpasswd&#34; | chpasswd
</code></pre><h4 id=322-vsftpd镜像copy的文件>3.2.2 vsftpd镜像COPY的文件<a hidden class=anchor aria-hidden=true href=#322-vsftpd镜像copy的文件>#</a></h4><p><strong>service_start.sh</strong></p><pre tabindex=0><code>#!/bin/bash
LOGTIME=$(date &#34;+%Y-%m-%d %H:%M:%S&#34;)
echo &#34;[$LOGTIME] startup run...&#34; &gt;&gt;/start_vsftpd.log
service vsftpd start &gt;&gt;/start_vsftpd.log
tail -f /start_vsftpd.log
</code></pre><p>简单的服务启动脚本，使用<code>tail -f</code>来维持住进程</p><p><strong>ftpusers</strong>
<code>root</code>前加个<code>#</code>以启用root登录</p><pre tabindex=0><code># /etc/ftpusers: list of users disallowed FTP access. See ftpusers(5).

#root
daemon
bin
sys
sync
games
man
lp
mail
news
uucp
nobody
</code></pre><p><strong>vsftpd.conf</strong>
ftp设置文件，这个文件内容很多只些下修改的部分</p><pre tabindex=0><code>listen=NO
listen_ipv6=YES
anonymous_enable=NO
local_enable=YES
write_enable=YES
dirmessage_enable=YES
use_localtime=YES
connect_from_port_20=YES
pam_service_name=vsftpd
utf8_filesystem=YES
</code></pre><p>*关于修改vsftpd的端口
<a href=https://askubuntu.com/questions/37058/how-to-change-vsftpd-default-port>https://askubuntu.com/questions/37058/how-to-change-vsftpd-default-port</a>
<code>vsftpd.conf</code>里的设置不是完全设置，可以自己增加字段</p><pre tabindex=0><code>listen_port=234
ftp_data_port=235
pasv_min_port=30000
pasv_max_port=31000
</code></pre><p>来设置端口
注意FTP默认20传输数据，21用来listen，所以改得话干脆两个都改吧</p><p>*这里遇到过一个小坑坑
<img loading=lazy src=images/20230829155702.png>
构建器报错，一直卡在<code>Starting FTP server: vsftpdvsftpd failed - probably invalid config. ... (warning).</code>
<img loading=lazy src=images/20230829155358.png>
自己在容器内运行<code>service vsftpd start</code>的时候同样如此，一般这样是因为<code>vsftpd.conf</code>文件设置错了，可神奇的是我只要打开dockerDesktop的Files文件管理把<code>vsftpd.conf</code>打开再保存一下就可以成功运行<code>service vsftpd start</code>
我发现这个文件的格式是UTF-8 CRLF
<img loading=lazy src=images/20230829155602.png>
修改为LF
<img loading=lazy src=images/20230829155623.png>
即可顺利启动vsftpd服务</p><p>参考：
<a href=https://www.cnblogs.com/Dreamcho/p/10805690.html>https://www.cnblogs.com/Dreamcho/p/10805690.html</a></p><p>如果要在dockerfile里加用户：
<a href=https://blog.csdn.net/u010275850/article/details/120587850>https://blog.csdn.net/u010275850/article/details/120587850</a></p><h3 id=33-ddns镜像>3.3 ddns镜像<a hidden class=anchor aria-hidden=true href=#33-ddns镜像>#</a></h3><p>这个镜像更简单？只在启动的时候跑一个ddns
但是我却在这里卡了很久
原因之一是因为一开始选用的ddns软件本地跑得好好的，在阿里云上总是报错，log显示已经修改了a记录但是自己去一看啥也没有，很是困惑，所以换了个软件实现
最开始使用的是这个软件，配置方便
<a href=https://github.com/NewFuture/DDNS>https://github.com/NewFuture/DDNS</a>
参考：
<a href=https://blog.csdn.net/biao0309/article/details/117202951>https://blog.csdn.net/biao0309/article/details/117202951</a>
无奈阿里云上即便是用官方提供的镜像<code>newfuture/ddns</code>也会报错（恼</p><p>所以我改用ddns-go:
<a href=https://github.com/jeessy2/ddns-go>https://github.com/jeessy2/ddns-go</a>
先贴上官方镜像的层：
<strong>jeessy/ddns-go</strong>
<img loading=lazy src=images/20230904184205.png>
我们的新镜像将基于官方镜像来做</p><h4 id=331-dockerfile>3.3.1 dockerfile<a hidden class=anchor aria-hidden=true href=#331-dockerfile>#</a></h4><p><strong>ddns-go_dockerfileV01</strong></p><pre tabindex=0><code>FROM jeessy/ddns-go
LABEL maintainer=&#34;winotmk&#34; web=&#34;md.winotmk.com&#34; Ver=&#34;01&#34;
COPY ddns_start.sh /
COPY ddns_go_config.yaml /
ENV DDNS_URL=
ENTRYPOINT [ &#34;sh&#34;,&#34;/ddns_start.sh&#34; ]
CMD [ &#34;&#34; ]
</code></pre><p>这里做了一个变量<code>$DDNS_URL</code>来定义我想要dns的域名(当然这个域名我得拥有)
ENTRYPOINT和CMD的设置会覆盖掉的之前镜像内的设置
我不确定CMD [ "" ]是否有必要，但总之我想使官方镜像里的CMD失效，从结果上来看管用</p><h4 id=332-ddns镜像copy的文件>3.3.2 ddns镜像COPY的文件<a hidden class=anchor aria-hidden=true href=#332-ddns镜像copy的文件>#</a></h4><p><strong>ddns_go_config.yaml</strong></p><pre tabindex=0><code>dnsconf:
    - ipv4:
        enable: true
        gettype: url
        url: https://myip4.ipip.net,https://ddns.oray.com/checkip,https://ip.3322.net,https://4.ipw.cn
        netinterface: &#34;&#34;
        cmd: &#34;&#34;
        domains:
            - null.winotmk.com
      ipv6:
        enable: false
        gettype: netInterface
        url: https://speed.neu6.edu.cn/getIP.php,https://v6.ident.me,https://6.ipw.cn
        netinterface: &#34;&#34;
        cmd: &#34;&#34;
        ipv6reg: &#34;&#34;
        domains:
            - &#34;&#34;
      dns:
        name: alidns
        id: 阿里云的AccessKey ID
        secret: 阿里云的AccessKey secret
      ttl: &#34;&#34;
user:
    username: &#34;&#34;
    password: &#34;&#34;
webhook:
    webhookurl: &#34;&#34;
    webhookrequestbody: &#34;&#34;
    webhookheaders: &#34;&#34;
notallowwanaccess: true
</code></pre><p>这个是ddns-go的配置文件，第一次启动会在本地:9876打开个web界面，保存设置后会在root中生成这个文件，这里我直接引入这个文件是希望后面能用<code>sed</code>命令对文件的<code>domains</code>字段进行修改</p><p><strong>ddns_start.sh</strong></p><pre tabindex=0><code>#!/bin/sh
LOGTIME=$(date &#34;+%Y-%m-%d %H:%M:%S&#34;)
echo &#34;[$LOGTIME] startup run...&#34; &gt;&gt;/start_ddns.log
cd /
if [ &#34;$DDNS_URL&#34; = &#34;&#34; ]  
then  
    echo &#34;DDNS_URL is not set!&#34; &gt;&gt;/start_ddns.log 
    tail -f /start_ddns.log 
else    
    sed -i &#34;s/null.winotmk.com/$DDNS_URL/g&#34; ddns_go_config.yaml
    #chmod 777 ddns_go_config.yaml
    sleep 3
    /app/ddns-go -l :9876 -f 300 -c /ddns_go_config.yaml
    echo &#34;已执行更新[$DDNS_URL]解析&#34; &gt;&gt;/start_ddns.log
    tail -f /start_ddns.log
fi
</code></pre><p>在这个脚本里会判断<code>$DDNS_URL</code>是否为空，空的话直接输出需要<code>$DDNS_URL</code>设置
如果不为空的话会通过<code>sed</code>替换字符，这里设置文件内默认写得是<code>null.winotmk.com</code>
用这种方式去直接修改设置文件，是因为我没找到这个软件是否能直接用环境变量来定义解析到的域名</p><p>关于用sed替换congif.json设置内的字段：
如何使用sed:
<a href=https://linux.cn/article-11367-1.html>https://linux.cn/article-11367-1.html</a>
如何在sed命令内使用变量
<a href=https://www.cnblogs.com/muahao/p/6874412.html>https://www.cnblogs.com/muahao/p/6874412.html</a>
判断变量是否为空的方法：
<a href=https://cloud.tencent.com/developer/article/1721905>https://cloud.tencent.com/developer/article/1721905</a></p><h2 id=4-docker镜像打包并上传到阿里云镜像库ark>4 docker镜像打包并上传到阿里云镜像库ARK<a hidden class=anchor aria-hidden=true href=#4-docker镜像打包并上传到阿里云镜像库ark>#</a></h2><p>将自己的镜像上传至阿里云：
阿里云提供容器镜像服务，我自己玩开通个人实例即可
<a href=https://cr.console.aliyun.com/cn-shanghai/instances>https://cr.console.aliyun.com/cn-shanghai/instances</a></p><p><img loading=lazy src=images/20230811150239.png></p><p>建立一个自己的仓库，然后就能看到示例说明，我们就能把自己的镜像上传了</p><h3 id=41-将镜像推送到registry>4.1 将镜像推送到Registry<a hidden class=anchor aria-hidden=true href=#41-将镜像推送到registry>#</a></h3><pre tabindex=0><code>$ docker login --username=*****@qq.com registry.cn-shanghai.aliyuncs.com
$ docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/******:[镜像版本号]
$ docker push registry.cn-shanghai.aliyuncs.com/******:[镜像版本号]
</code></pre><p><code>tag</code>是类似复制一份且重命名镜像，<code>push</code>是上传（不知道为什么要重命名</p><p>针对上面的3个镜像，分别是：<code>node.js+git+hexo</code>,<code>vsftpd</code>,<code>ddns-go</code>
我分别tag成了：</p><pre tabindex=0><code>registry-vpc.cn-shanghai.aliyuncs.com/******:debian_V02_configured #应该写成:hexo_debian_V02_configured的，漏了。。算了
registry-vpc.cn-shanghai.aliyuncs.com/******:vsftpd_debian_V01
registry-vpc.cn-shanghai.aliyuncs.com/******:ddns_go_V01
</code></pre><p>再分别<code>push</code>即可</p><h3 id=42-在阿里云上使用容器实例eci运行镜像>4.2 在阿里云上使用容器实例（ECI）运行镜像<a hidden class=anchor aria-hidden=true href=#42-在阿里云上使用容器实例eci运行镜像>#</a></h3><p>阿里云ECI提供这个服务，你可以直接用现有的镜像也可以自己上传（就是上一步镜像服务里上传的镜像）按秒收费！不过作为hexo这种启用>生成>部署>关闭的服务来说，花不了几毛钱</p><p><img loading=lazy src=images/20230811151948.png></p><p>然后就能看到我们上传的镜像
<img loading=lazy src=images/20230811152250.png></p><h2 id=5-eci容器创建模板和eci命令行工具使用>5 eci容器创建模板和eci命令行工具使用<a hidden class=anchor aria-hidden=true href=#5-eci容器创建模板和eci命令行工具使用>#</a></h2><p>参考文章这两篇足够:
<a href=https://github.com/aliyuneci/eci-client-doc/blob/main/eci_run.md>https://github.com/aliyuneci/eci-client-doc/blob/main/eci_run.md</a>
<a href=https://help.aliyun.com/document_detail/186961.html>https://help.aliyun.com/document_detail/186961.html</a></p><h3 id=51-eci简介>5.1 eci简介<a hidden class=anchor aria-hidden=true href=#51-eci简介>#</a></h3><p><a href=https://www.aliyun.com/product/eci>https://www.aliyun.com/product/eci</a>
ECI是 Serverless 和容器化的弹性计算服务。您无需管理底层 ECS 服务器，只需要提供打包好的镜像，即可运行容器，与阿里云容器服务无缝对接并仅为容器实际运行消耗的资源付费。</p><p>博主：比ECS云服务器灵活得多，本地用docker制作好镜像以后，上传，随启随用，用完就释放，成本可以很低,但如果连开一个月，并不会比ECS划算，详见本站<a href=https://winotmk.github.io/Docker01.1_%E4%BB%B7%E6%A0%BC%E8%AE%A1%E7%AE%97%E8%A1%A8/>ECI价格计算附表</a></p><h3 id=52-用模板创建eci>5.2 用模板创建eci<a hidden class=anchor aria-hidden=true href=#52-用模板创建eci>#</a></h3><p><img loading=lazy src=images/20230907171351.png>
询问过阿里云客服，说在web控制面版里的这个功能已经下线了
不过没关系，我们还有命令行工具！
安装：</p><pre tabindex=0><code>sudo bash -c &#34;$(curl -s https://eci-docs.oss-cn-beijing.aliyuncs.com/eci-client/1.0/install.sh)&#34;
</code></pre><p>然后配置你的阿里云信息</p><pre tabindex=0><code>eci config set-context \
--access-key-id **** \
--access-secret **** \
--region-id cn-shanghai \
--security-group-id sg-**** \
--v-switch-id vsw-****
</code></pre><p>要指定自己的<code>access-key-id</code>和<code>access-secret</code>，地区以及安全组和虚拟交换机
建议这些东西在web上的控制台里准备好，会直观很多</p><p>然后就可以直接创建一个容器了</p><pre tabindex=0><code>eci run -n myeci centos:7 sleep 3600
</code></pre><p>指令很像<code>docker run</code>喝！很好，很有精神</p><p>我们还可以编写yaml模板文件
然后执行</p><pre tabindex=0><code>eci run -f eci.yaml -w 20
</code></pre><p>需要注意的事，如果使用了<code>-f xxxx.yaml</code>模板文件，除了-f和-w选项以外，其他选项都将被忽略，因为这些选项都是针对实例中某个容器的，如果模板中定义了多个容器，ECI将不知道这些选项应该作用于哪个容器
那么我自己的启动模板是这样的：
<strong>hexo_debian_eci.yaml</strong></p><pre tabindex=0><code>ContainerGroupName: eci-hexo
Cpu: &#34;0.5&#34;
Memory: &#34;1&#34;
Container:
- Name: hexo
  Image: registry-vpc.cn-shanghai.aliyuncs.com/****:debian_V02_configured
  Command: [&#34;/bin/bash&#34;,&#34;/service_start.sh&#34;]
  ImagePullPolicy: IfNotPresent
  Cpu: &#34;0.5&#34;
  Memory: &#34;1&#34;
  VolumeMount:
  - Name: hexo
    MountPath: /hexo
    ReadOnly: false
- Name: vsftpd
  Image: registry-vpc.cn-shanghai.aliyuncs.com/****:vsftpd_debian_V01
  Command: [&#34;/bin/bash&#34;,&#34;/service_start.sh&#34;]
  ImagePullPolicy: IfNotPresent
  VolumeMount:
  - Name: hexo
    MountPath: /hexo
    ReadOnly: false
- Name: ddns
  Image: registry-vpc.cn-shanghai.aliyuncs.com/****:ddns_go_V01
  ImagePullPolicy: IfNotPresent
  EnvironmentVar:
  - FieldRefFieldPath: &#34;&#34;
    Key: DDNS_URL
    Value: mdwrite.winotmk.com
Volume:
- Name: hexo
  Type: NFSVolume
  NFSVolume:
    Server: ****.cn-shanghai.nas.aliyuncs.com
    Path: /
    ReadOnly: false
</code></pre><p>是不是挺像<code>docker compose</code>~</p><p>cpu只给了0.5,Memory 1G，足够了，之前这套可是在树莓派3B上跑得溜溜得呢
对于阿里云ECI，CPU和Memory直接和成本挂钩，能少就少吧</p><p>这里启了上面做好的3个镜像，分别实现hexo，ftp，还有ddns
<code>Command:</code>写法目测类似dockerfile里的<code>CMD</code>，我习惯做好启动sh脚本就是为了方便这里再调用
最后一段声明了我的一个阿里云NAS卷，卷里的内容就是我的hexo目录
<img loading=lazy src=images/20230829142501.png>
然后把它挂到hexo和ftp镜像上就好了</p><p>值得一提的是ddns镜像还写了个环境变量<code>DDNS_URL</code>值为<code>mdwrite.winotmk.com</code>，这会修改<code>ddns-go</code>的解析配置</p><p>然后执行</p><pre tabindex=0><code>eci run -f hexo_debian_eci.yaml -w 20
</code></pre><p>不出意外的话会返回一个eci的id编号，打开web会发现已经创建成功了！
<img loading=lazy src=images/20230907174209.png></p><h2 id=6-hexo本地编辑环境设置如何用vscode舒服的写md文档>6 hexo本地编辑环境设置————如何用VSCode舒服的写MD文档<a hidden class=anchor aria-hidden=true href=#6-hexo本地编辑环境设置如何用vscode舒服的写md文档>#</a></h2><h3 id=61-vscodessh-fs插件配置>6.1 VSCodeSSH FS插件配置<a hidden class=anchor aria-hidden=true href=#61-vscodessh-fs插件配置>#</a></h3><p><img loading=lazy src=images/20230908113634.png>
简单配置一下服务器地址和用户密码就可以把远程目录映射到工作区里，很方便
<img loading=lazy src=images/20230908113824.png>
这里可以看到<code>/root/hexo/Winblog</code>目录下是我挂载的阿里云NAS网盘了</p><h3 id=62-markdown-paste插件配置>6.2 Markdown Paste插件配置<a hidden class=anchor aria-hidden=true href=#62-markdown-paste插件配置>#</a></h3><p>一个很方便的在VScode里直接粘图的插件</p><h4 id=配置>配置：<a hidden class=anchor aria-hidden=true href=#配置>#</a></h4><p><img loading=lazy src=images/20230908114845.png>
会用时间来命名图片
然后会将图片放入MD文件目录下的<code>images</code>下</p><p><img loading=lazy src=images/20230908115038.png></p><p>然后文件》首选项》键盘快捷方式
<img loading=lazy src=images/20230908115303.png>
我将快捷键设置为<code>ctrl+alt+a</code>
配置完成！</p><h4 id=使用>使用：<a hidden class=anchor aria-hidden=true href=#使用>#</a></h4><p>截图我习惯用Sinpaste，按F1就能截图
<img loading=lazy src=images/20230908115743.png>
然后点右下角复制按钮
在VScode的markdown文档里<code>ctrl+alt+a</code>就能粘图了！
<img loading=lazy src=images/20230908113947.png>
图片文件会自动保存!</p><h3 id=62-vscode的sftp插件配置>6.2 VSCode的SFTP插件配置<a hidden class=anchor aria-hidden=true href=#62-vscode的sftp插件配置>#</a></h3><p>先把images文件夹单独放到工作区里
然后在Ctrl+Shift+P打开命令面板，运行SFTP: config命令
sftp.json目录下会出现一个名为的基本配置文件.vscode
<img loading=lazy src=images/20230908121346.png>
然后编辑
<strong>sftp.json</strong></p><pre tabindex=0><code>{
    &#34;name&#34;: &#34;Hexo_images&#34;,
    &#34;host&#34;: &#34;mdwrite.winotmk.com&#34;,
    &#34;protocol&#34;: &#34;ftp&#34;,
    &#34;port&#34;: 21,
    &#34;username&#34;: &#34;root&#34;,
    &#34;password&#34;: &#34;****&#34;,
    &#34;remotePath&#34;: &#34;/hexo/Winblog/source/images&#34;,
    &#34;useTempFile&#34;: false,
    &#34;openSsh&#34;: false,
    &#34;uploadOnSave&#34;: false, 
    &#34;watcher&#34;: {
      &#34;files&#34;: &#34;**/*&#34;,
      &#34;autoUpload&#34;: true,
      &#34;autoDelete&#34;: true
    },
    &#34;syncOption&#34;: {
      &#34;delete&#34;: true
    }
}
</code></pre><p><code>"watcher"</code>是用来设置自动更新的
这样我们在md里粘了图，就会自动上传到到ftp目录上</p><p>参考：
<a href="https://marketplace.visualstudio.com/items?itemName=Natizyskunk.sftp#remote-explorer">https://marketplace.visualstudio.com/items?itemName=Natizyskunk.sftp#remote-explorer</a>
开启watcher模式，实现增加文件时自动上传目录同步
<a href=https://github.com/Natizyskunk/vscode-sftp/blob/master/FAQ.md#automatically-sync-both-ways-without-user-interaction>https://github.com/Natizyskunk/vscode-sftp/blob/master/FAQ.md#automatically-sync-both-ways-without-user-interaction</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:12371/tags/hexo/>Hexo</a></li><li><a href=http://localhost:12371/tags/next/>Next</a></li><li><a href=http://localhost:12371/tags/docker/>Docker</a></li><li><a href=http://localhost:12371/tags/%E9%98%BF%E9%87%8C%E4%BA%91/>阿里云</a></li><li><a href=http://localhost:12371/tags/eci/>Eci</a></li></ul><nav class=paginav><a class=prev href=http://localhost:12371/posts/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/><span class=title>« Prev</span><br><span>calibre_web的pdf封面提取问题</span>
</a><a class=next href=http://localhost:12371/posts/docker01.1_%E4%BB%B7%E6%A0%BC%E8%AE%A1%E7%AE%97%E8%A1%A8/><span class=title>Next »</span><br><span>Docker01.1_eci价格计算表</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行 on x" href="https://x.com/intent/tweet/?text=Docker01_%e7%94%a8docker%e6%9e%84%e5%bb%bahexo%e5%92%8cvsftpd%e4%b8%8eddns%e9%95%9c%e5%83%8f%e5%b9%b6%e4%b8%94%e7%94%a8%e9%98%bf%e9%87%8c%e4%ba%91%e5%ae%b9%e5%99%a8%e6%9c%8d%e5%8a%a1ECI%e8%bf%90%e8%a1%8c&amp;url=http%3a%2f%2flocalhost%3a12371%2fposts%2fdocker01%2f&amp;hashtags=hexo%2cnext%2cdocker%2c%e9%98%bf%e9%87%8c%e4%ba%91%2ceci"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a12371%2fposts%2fdocker01%2f&amp;title=Docker01_%e7%94%a8docker%e6%9e%84%e5%bb%bahexo%e5%92%8cvsftpd%e4%b8%8eddns%e9%95%9c%e5%83%8f%e5%b9%b6%e4%b8%94%e7%94%a8%e9%98%bf%e9%87%8c%e4%ba%91%e5%ae%b9%e5%99%a8%e6%9c%8d%e5%8a%a1ECI%e8%bf%90%e8%a1%8c&amp;summary=Docker01_%e7%94%a8docker%e6%9e%84%e5%bb%bahexo%e5%92%8cvsftpd%e4%b8%8eddns%e9%95%9c%e5%83%8f%e5%b9%b6%e4%b8%94%e7%94%a8%e9%98%bf%e9%87%8c%e4%ba%91%e5%ae%b9%e5%99%a8%e6%9c%8d%e5%8a%a1ECI%e8%bf%90%e8%a1%8c&amp;source=http%3a%2f%2flocalhost%3a12371%2fposts%2fdocker01%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a12371%2fposts%2fdocker01%2f&title=Docker01_%e7%94%a8docker%e6%9e%84%e5%bb%bahexo%e5%92%8cvsftpd%e4%b8%8eddns%e9%95%9c%e5%83%8f%e5%b9%b6%e4%b8%94%e7%94%a8%e9%98%bf%e9%87%8c%e4%ba%91%e5%ae%b9%e5%99%a8%e6%9c%8d%e5%8a%a1ECI%e8%bf%90%e8%a1%8c"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a12371%2fposts%2fdocker01%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行 on whatsapp" href="https://api.whatsapp.com/send?text=Docker01_%e7%94%a8docker%e6%9e%84%e5%bb%bahexo%e5%92%8cvsftpd%e4%b8%8eddns%e9%95%9c%e5%83%8f%e5%b9%b6%e4%b8%94%e7%94%a8%e9%98%bf%e9%87%8c%e4%ba%91%e5%ae%b9%e5%99%a8%e6%9c%8d%e5%8a%a1ECI%e8%bf%90%e8%a1%8c%20-%20http%3a%2f%2flocalhost%3a12371%2fposts%2fdocker01%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行 on telegram" href="https://telegram.me/share/url?text=Docker01_%e7%94%a8docker%e6%9e%84%e5%bb%bahexo%e5%92%8cvsftpd%e4%b8%8eddns%e9%95%9c%e5%83%8f%e5%b9%b6%e4%b8%94%e7%94%a8%e9%98%bf%e9%87%8c%e4%ba%91%e5%ae%b9%e5%99%a8%e6%9c%8d%e5%8a%a1ECI%e8%bf%90%e8%a1%8c&amp;url=http%3a%2f%2flocalhost%3a12371%2fposts%2fdocker01%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Docker01_%e7%94%a8docker%e6%9e%84%e5%bb%bahexo%e5%92%8cvsftpd%e4%b8%8eddns%e9%95%9c%e5%83%8f%e5%b9%b6%e4%b8%94%e7%94%a8%e9%98%bf%e9%87%8c%e4%ba%91%e5%ae%b9%e5%99%a8%e6%9c%8d%e5%8a%a1ECI%e8%bf%90%e8%a1%8c&u=http%3a%2f%2flocalhost%3a12371%2fposts%2fdocker01%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:12371/>ExampleSite</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>