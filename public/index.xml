<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WinNote</title><link>https://winotmk.github.io/</link><description>Recent content on WinNote</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>winotmk</copyright><lastBuildDate>Mon, 24 Feb 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://winotmk.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>WinNote</title><link>https://winotmk.github.io/posts/winnote/</link><pubDate>Wed, 13 Dec 2023 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/winnote/</guid><description>&lt;img src="http://pictures.winotmk.com/20211101_005742_IMB_3iZZzg_ac4eb74c.gif" alt="Featured image of post WinNote" />&lt;p>&lt;img src="https://winotmk.github.io/images/catcat.png"
loading="lazy"
>&lt;/p>
&lt;p>&lt;img src="http://pictures.winotmk.com/20211101_005742_IMB_3iZZzg_ac4eb74c.gif"
loading="lazy"
alt="20211101_005742_IMB_3iZZzg"
>&lt;/p>
&lt;!--{% asset_img 20211101_005742_IMB_3iZZzg.gif 800 %}-->
&lt;p>一个轻量级MD文档收集博客，不保证阅读性
使用树莓派+hexo构建，定制化next主题，github部署
2023.9.8更新
使用eci容器构建，自制镜像，cdn加速&lt;/p>
&lt;p>一些编辑的Tips:
首页文章预览至：&lt;/p>
&lt;pre>&lt;code>&amp;lt;!-- more --&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>markdown paste粘图：&lt;/p>
&lt;pre>&lt;code>ctrl+art+a
&lt;/code>&lt;/pre>
&lt;p>本站加速域名：&lt;a class="link" href="https://md.winotmk.com/" target="_blank" rel="noopener"
>https://md.winotmk.com/&lt;/a>
正式站：&lt;a class="link" href="https://www.winotmk.com" target="_blank" rel="noopener"
>winotmk.com&lt;/a>&lt;/p>
&lt;p>点击查看更多该网站更新日志&lt;/p>
&lt;!-- more -->
&lt;hr>
&lt;p>2023.12.13更新
为了防止忘记如何写这个博客，特留备忘
NAS上工作台的盘符请设置为T
启动ecistarter容器
然后&lt;code>CD ecistart&lt;/code> 进入目录
使用&lt;code>. ./hexo_s&lt;/code> 来脚本启动阿里云eci上的容器，此脚本包含如果一段时间内没有连接将会自动释放掉eci容器的功能，判断依据是是否有SSH接入
&lt;img src="https://winotmk.github.io/images/20231213183015.png"
loading="lazy"
>
之后通过VSCode的插件SSH FS来接入
md文档的目录是&lt;code>./hexo/Winblog/source/_posts&lt;/code>&lt;/p>
&lt;p>关于图片插入：本地目录&lt;code>T:\博客\md_for_hexo\Images&lt;/code>将会与FTP上的&lt;code>./hexo/Winblog/source/images&lt;/code>自动单向同步&lt;/p>
&lt;hr>
&lt;p>2024.06.17再更新
因为买了阿里99服务器，改用了容器的形式运行
启动组
&lt;code>docker compose -f hexo_debian_DockerCompose.yml up -d &lt;/code>
关闭组
&lt;code>docker compose -f hexo_debian_DockerCompose.yml down -v&lt;/code>
同时配置了本地文章目录&lt;code>T:\博客\md_for_hexo_workspace&lt;/code>和FTP上的&lt;code>./hexo/Winblog/source/_posts&lt;/code>自动同步，终于不会存在本地和服务器上两份文章了
在&lt;code>md_for_hexo_workspace&lt;/code>写好后直接&lt;code>docker exec hexo hexo g -d&lt;/code>即可发布&lt;/p>
&lt;hr>
&lt;p>2025.02.20再更新&lt;/p>
&lt;ol>
&lt;li>忽然发现阿里云OSS每个月要扣3块钱，才发现现在&lt;strong>同城冗余&lt;/strong>和&lt;strong>本地存储&lt;/strong>计价分开了，不能使用资源包扣容量了，&lt;strong>本地存储&lt;/strong>的40G一年才几块钱却不起作用，傻傻交了好几个月的3块钱
那么我忽然想到，现在是用SFTP插件同步本地目录完成上传图片到远程文件存储的，何不直接使用OSS呢，它不就是用来干这个的嘛，拿来做图床想必轻而易举，所以找到了一个插件来完成oss上传图片的工作
&lt;img src="http://pictures.winotmk.com/WinNote/2025-02-20-18-43-03_f587624d.png"
loading="lazy"
alt="2025-02-20-18-43-03"
>
还蛮好用的，绑定了&lt;code>elan upload from clipboard&lt;/code>到**&lt;code>ctrl+shift+art+a&lt;/code>**来粘贴并上传文件到bucket，会按照当前文档名称建文件夹分类&lt;/li>
&lt;li>vscode的账户真是太乱了，能用微软登录，能用github登，甚至能用微软里再用github登，今天统一为用github的550330147邮箱登录&lt;/li>
&lt;/ol></description></item><item><title>Hello World</title><link>https://winotmk.github.io/p/hello-world/</link><pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/p/hello-world/</guid><description>&lt;img src="https://winotmk.github.io/p/hello-world/cover.jpg" alt="Featured image of post Hello World" />&lt;p>Welcome to Hugo theme Stack. This is your first post. Edit or delete it, then start writing!&lt;/p>
&lt;p>For more information about this theme, check the documentation: &lt;a class="link" href="https://stack.jimmycai.com/" target="_blank" rel="noopener"
>https://stack.jimmycai.com/&lt;/a>&lt;/p>
&lt;p>Want a site like this? Check out &lt;a class="link" href="https://github.com/CaiJimmy/hugo-theme-stack-starter" target="_blank" rel="noopener"
>hugo-theme-stack-stater&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>Photo by &lt;a class="link" href="https://unsplash.com/@pawel_czerwinski" target="_blank" rel="noopener"
>Pawel Czerwinski&lt;/a> on &lt;a class="link" href="https://unsplash.com/" target="_blank" rel="noopener"
>Unsplash&lt;/a>&lt;/p>&lt;/blockquote></description></item><item><title>Hugo安装和启用Stack主题</title><link>https://winotmk.github.io/posts/250224_hugo%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E7%94%A8%E4%B8%BB%E9%A2%98/</link><pubDate>Mon, 24 Feb 2025 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/250224_hugo%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E7%94%A8%E4%B8%BB%E9%A2%98/</guid><description>&lt;h2 id="hugo安装与建立新网站">Hugo安装与建立新网站
&lt;/h2>&lt;h3 id="配置环境变量">配置环境变量
&lt;/h3>&lt;p>在这里下载打包好的二进制文件，单文件很方便
&lt;a class="link" href="https://github.com/gohugoio/hugo/releases" target="_blank" rel="noopener"
>https://github.com/gohugoio/hugo/releases&lt;/a>
要注意的是Hugo发行版分3种，标准版，extended扩展版，和代deploy功能的extended扩展版
而Stack需要extended扩展版&lt;/p>
&lt;p>下好以后配置环境变量PATH到hugo单文件所在的目录，如果可以&lt;code>hugo version&lt;/code>即说明它可以工作啦！&lt;/p>
&lt;p>&lt;img src="http://pictures.winotmk.com/250224_Hugo%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E7%94%A8%E4%B8%BB%E9%A2%98/2025-02-24-14-43-28_23d971d6.png"
loading="lazy"
alt="2025-02-24-14-43-28"
>&lt;/p>
&lt;h3 id="建立一个新站点和stack主题安装">建立一个新站点和Stack主题安装
&lt;/h3>&lt;p>&lt;a class="link" href="https://gohugo.io/getting-started/quick-start/" target="_blank" rel="noopener"
>https://gohugo.io/getting-started/quick-start/&lt;/a>
我是直接新建一个目录到里面打开CMD，然后&lt;/p>
&lt;pre>&lt;code class="language-bash">hugo new site .
&lt;/code>&lt;/pre>
&lt;p>就会在本地生成好网站目录
初始化git（因为需要用git子模块来拉主题的库）&lt;/p>
&lt;pre>&lt;code>git init
&lt;/code>&lt;/pre>
&lt;p>然后加载子模块&lt;/p>
&lt;pre>&lt;code>git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack
&lt;/code>&lt;/pre>
&lt;p>主题文档参见：
&lt;a class="link" href="https://stack.jimmycai.com/guide/getting-started" target="_blank" rel="noopener"
>https://stack.jimmycai.com/guide/getting-started&lt;/a>
&lt;a class="link" href="https://themes.gohugo.io/themes/hugo-theme-stack/" target="_blank" rel="noopener"
>https://themes.gohugo.io/themes/hugo-theme-stack/&lt;/a>&lt;/p>
&lt;p>好了，主题的安装文档居然到这里戛然而止了，令人十分费解，前期工作完成后，最后一步启用居然没说，Stack主题发的文档似乎十分希望用户使用这个库来直接开始用主题和hugo：
&lt;a class="link" href="https://github.com/CaiJimmy/hugo-theme-stack-starter" target="_blank" rel="noopener"
>https://github.com/CaiJimmy/hugo-theme-stack-starter&lt;/a>&lt;/p>
&lt;p>但我偏不，我不喜欢预制用户用法的做法，我只是希望hugo作为一个生成器，部署要在阿里云OSS上做而不是github pages。&lt;/p>
&lt;p>所以摸索了大半天，自己安装的话应当将：
&lt;code>themes\hugo-theme-stack\exampleSite&lt;/code>目录下的&lt;code>hugo.yaml&lt;/code>文件复制到Hugo根目录并且删除原有的&lt;code>hugo.toml&lt;/code>设置文件,注意不是&lt;code>themes\hugo-theme-stack&lt;/code>里的&lt;code>config.yaml&lt;/code>
如果你想看自带的示例文章可以将&lt;code>themes\hugo-theme-stack\exampleSite&lt;/code>下的&lt;code>content&lt;/code>覆盖到根目录的同名目录里
之后就可以启动hugo预览了（不加-p参数默认端口为1313）&lt;/p>
&lt;pre>&lt;code>hugo server -D -p 7512
&lt;/code>&lt;/pre>
&lt;p>打开浏览器你将会看到：
&lt;img src="http://pictures.winotmk.com/250224_Hugo%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E7%94%A8%E4%B8%BB%E9%A2%98/2025-02-24-15-06-17_426311aa.png"
loading="lazy"
alt="2025-02-24-15-06-17"
>&lt;/p>
&lt;p>恭喜你，开始为博客填内容吧~&lt;/p></description></item><item><title>Mac的包管理器homebrew环境变量配置</title><link>https://winotmk.github.io/posts/250223_mac%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8homebrew%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 23 Feb 2025 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/250223_mac%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8homebrew%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</guid><description>&lt;p>按照 &lt;a class="link" href="https://brew.sh" target="_blank" rel="noopener"
>https://brew.sh&lt;/a> 这里的提示：&lt;/p>
&lt;pre>&lt;code class="language-bash">/bin/bash -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>装完brew后，敲brew居然不认得，还得我自己配一下
所以：&lt;/p>
&lt;pre>&lt;code class="language-bash">cd /opt/homebrew/bin/
PATH=$PATH:/opt/homebrew/bin
&lt;/code>&lt;/pre>
&lt;p>然后再&lt;/p>
&lt;pre>&lt;code class="language-bash">cd ~/
touch .zshrc
echo export PATH=$PATH:/opt/homebrew/bin &amp;gt;&amp;gt; .zshrc
&lt;/code>&lt;/pre>
&lt;p>这下就可以用brew啦，我主要是拿来&lt;/p>
&lt;pre>&lt;code class="language-bash">bres install git
&lt;/code>&lt;/pre>
&lt;p>安装git
但是神奇的是当我后面再用&lt;code>vim ~/ .zshrc&lt;/code>想看看它时却似乎打不开这个文件，难道mac的设置是一次性的生效就删&lt;/p></description></item><item><title>Git常用命令</title><link>https://winotmk.github.io/posts/250221_git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Fri, 21 Feb 2025 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/250221_git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>&lt;h3 id="1-进入本地仓库目录">&lt;strong>1. 进入本地仓库目录&lt;/strong>
&lt;/h3>&lt;p>打开终端（或 Git Bash），切换到仓库根目录：&lt;/p>
&lt;pre>&lt;code class="language-bash">cd /path/to/your-repo
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h3 id="2-查看修改状态">&lt;strong>2. 查看修改状态&lt;/strong>
&lt;/h3>&lt;p>检查哪些文件被修改：&lt;/p>
&lt;pre>&lt;code class="language-bash">git status
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>红色显示的文件表示已修改但未添加到暂存区。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="3-将修改添加到暂存区">&lt;strong>3. 将修改添加到暂存区&lt;/strong>
&lt;/h3>&lt;p>添加单个文件：&lt;/p>
&lt;pre>&lt;code class="language-bash">git add 文件名
&lt;/code>&lt;/pre>
&lt;p>或添加所有修改的文件：&lt;/p>
&lt;pre>&lt;code class="language-bash">git add .
&lt;/code>&lt;/pre>
&lt;p>再次运行 &lt;code>git status&lt;/code>，绿色显示的文件表示已添加到暂存区。&lt;/p>
&lt;hr>
&lt;h3 id="4-提交修改到本地仓库">&lt;strong>4. 提交修改到本地仓库&lt;/strong>
&lt;/h3>&lt;pre>&lt;code class="language-bash">git commit -m &amp;quot;描述你的修改内容（例如：修复登录页面样式问题）&amp;quot;
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>-m&lt;/code> 后跟提交信息，需简洁明确（推荐使用英文或中文）。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="5-推送修改到远程仓库">&lt;strong>5. 推送修改到远程仓库&lt;/strong>
&lt;/h3>&lt;p>将本地提交推送到远程仓库（默认分支通常是 &lt;code>main&lt;/code> 或 &lt;code>master&lt;/code>）：&lt;/p>
&lt;pre>&lt;code class="language-bash">git push origin 分支名
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>例如推送到 &lt;code>main&lt;/code> 分支：
&lt;pre>&lt;code class="language-bash">git push origin main
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="6-验证推送结果">&lt;strong>6. 验证推送结果&lt;/strong>
&lt;/h3>&lt;ul>
&lt;li>访问远程仓库页面（如 GitHub），检查文件是否更新。&lt;/li>
&lt;li>或通过命令查看远程状态：
&lt;pre>&lt;code class="language-bash">git log --oneline # 查看本地提交记录
git remote show origin # 检查远程仓库状态
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="常见问题">&lt;strong>常见问题&lt;/strong>
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>提交后发现漏了文件&lt;/strong>：&lt;/p>
&lt;pre>&lt;code class="language-bash"># 继续修改文件，然后再次添加并提交
git add 漏掉的文件名
git commit --amend # 合并到上一次提交
git push -f origin 分支名 # 强制推送（仅限自己的分支）
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>推送冲突&lt;/strong>（多人协作时可能发生）：&lt;/p>
&lt;pre>&lt;code class="language-bash">git pull origin 分支名 # 先拉取远程最新代码，解决冲突后再推送
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>默认情况下直接使用 &lt;code>git clone&lt;/code> 不会自动克隆子模块（submodule）。子模块信息虽然记录在 &lt;code>.gitmodules&lt;/code> 文件中，但其代码需要额外操作才能同步到本地。&lt;/p>
&lt;hr>
&lt;h3 id="如何完整克隆包含子模块的仓库">&lt;strong>如何完整克隆包含子模块的仓库？&lt;/strong>
&lt;/h3>&lt;h4 id="方法-1递归克隆推荐">&lt;strong>方法 1：递归克隆（推荐）&lt;/strong>
&lt;/h4>&lt;p>在克隆时添加 &lt;code>--recurse-submodules&lt;/code> 参数，&lt;strong>一次性递归克隆主仓库和所有子模块&lt;/strong>：&lt;/p>
&lt;pre>&lt;code class="language-bash">git clone --recurse-submodules 仓库URL
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h4 id="方法-2克隆后初始化子模块">&lt;strong>方法 2：克隆后初始化子模块&lt;/strong>
&lt;/h4>&lt;p>如果已经用普通方式克隆了主仓库，后续可以手动拉取子模块：&lt;/p>
&lt;pre>&lt;code class="language-bash"># 进入主仓库目录
cd your-repo
# 初始化子模块配置（从 .gitmodules 读取）
git submodule init
# 拉取子模块代码
git submodule update
# 或者合并成一步：
git submodule update --init
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h3 id="验证子模块">&lt;strong>验证子模块&lt;/strong>
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>查看子模块目录是否包含文件（不再是空文件夹）：&lt;/p>
&lt;pre>&lt;code class="language-bash">ls -la path/to/submodule
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>检查子模块状态：&lt;/p>
&lt;pre>&lt;code class="language-bash">git submodule status
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="常见问题-1">&lt;strong>常见问题&lt;/strong>
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>子模块更新失败&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>确保子模块的仓库地址可访问（尤其是私有仓库）。&lt;/li>
&lt;li>如果子模块本身也有嵌套子模块，使用：
&lt;pre>&lt;code class="language-bash">git submodule update --init --recursive
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>切换分支后子模块内容异常&lt;/strong>：
主仓库切换分支时，子模块可能需要同步更新到对应提交：&lt;/p>
&lt;pre>&lt;code class="language-bash">git submodule update --remote
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="子模块工作原理">&lt;strong>子模块工作原理&lt;/strong>
&lt;/h3>&lt;ul>
&lt;li>主仓库只记录子模块的&lt;strong>具体提交哈希&lt;/strong>，不保存子模块的代码。&lt;/li>
&lt;li>子模块是独立的仓库，需要单独拉取和更新。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="设置代理">设置代理
&lt;/h2>&lt;p>git config &amp;ndash;global http.proxy http://127.0.0.1:7080
git config &amp;ndash;global https.proxy https://127.0.0.1:7080
取消设置代理
git config &amp;ndash;global &amp;ndash;unset http.proxy
git config &amp;ndash;global &amp;ndash;unset https.proxy
可以通过
git config -l
查看设置状态&lt;/p></description></item><item><title>Hugo_GithubAction自动部署到阿里云OSS</title><link>https://winotmk.github.io/posts/250221_hugo_githubaction%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91oss/</link><pubDate>Thu, 20 Feb 2025 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/250221_hugo_githubaction%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91oss/</guid><description>&lt;p>整了大半天，总算明白GithubAction是怎么用的了，给人感觉其实有那么些像docker，而需要为其写的action规则又像dockerfile或者dockercompose，它们都是去调用一些已经做好的功能/镜像，来按步骤去一步步达成一些事
参考文章：
&lt;a class="link" href="https://thooooor.github.io/posts/%E8%84%B1%E5%9D%91%E8%AE%B0%E5%BD%95/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener"
>https://thooooor.github.io/posts/%E8%84%B1%E5%9D%91%E8%AE%B0%E5%BD%95/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/&lt;/a>
&lt;a class="link" href="https://kingtuo123.com/posts/hugo-deploy/" target="_blank" rel="noopener"
>https://kingtuo123.com/posts/hugo-deploy/&lt;/a>
&lt;a class="link" href="https://zhuanlan.zhihu.com/p/367426039" target="_blank" rel="noopener"
>https://zhuanlan.zhihu.com/p/367426039&lt;/a>&lt;/p>
&lt;h2 id="参考链接">参考链接
&lt;/h2>&lt;p>action：
&lt;a class="link" href="https://github.com/manyuanrong/setup-ossutil" target="_blank" rel="noopener"
>https://github.com/manyuanrong/setup-ossutil&lt;/a>
&lt;a class="link" href="https://github.com/peaceiris/actions-hugo" target="_blank" rel="noopener"
>https://github.com/peaceiris/actions-hugo&lt;/a>&lt;/p>
&lt;p>hugo和其主题：
&lt;a class="link" href="https://gohugo.io/getting-started/quick-start/" target="_blank" rel="noopener"
>https://gohugo.io/getting-started/quick-start/&lt;/a>
&lt;a class="link" href="https://github.com/adityatelange/hugo-PaperMod" target="_blank" rel="noopener"
>https://github.com/adityatelange/hugo-PaperMod&lt;/a>&lt;/p>
&lt;p>当你通过 &lt;code>git push&lt;/code> 触发 GitHub Actions 流程时，需要将 &lt;strong>Hugo 博客的源代码&lt;/strong>推送到仓库。以下是具体操作步骤和本地准备：&lt;/p>
&lt;hr>
&lt;h3 id="一本地准备工作">&lt;strong>一、本地准备工作&lt;/strong>
&lt;/h3>&lt;h4 id="1-项目结构要求">1. &lt;strong>项目结构要求&lt;/strong>
&lt;/h4>&lt;p>你的本地 Hugo 博客项目需要包含以下内容：&lt;/p>
&lt;pre>&lt;code>your-blog-repo/
├── .github/workflows/deploy.yml # 你的 GitHub Actions 配置文件
├── content/ # 博客文章
├── themes/ # Hugo 主题（通常作为 Git 子模块）
├── config.toml # Hugo 配置文件
└── (其他 Hugo 相关文件)
&lt;/code>&lt;/pre>
&lt;h4 id="2-本地环境配置">2. &lt;strong>本地环境配置&lt;/strong>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>安装 Git&lt;/strong>：确保已安装 Git 并配置好 GitHub 账户。&lt;/li>
&lt;li>&lt;strong>安装 Hugo&lt;/strong>（可选）：&lt;br>
建议本地安装 Hugo 用于测试（与 Actions 中版本一致）：
&lt;pre>&lt;code class="language-bash">brew install hugo # macOS
# 或参考 Hugo 官方文档 https://gohugo.io/installation/
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;h4 id="3-初始化-git-仓库">3. &lt;strong>初始化 Git 仓库&lt;/strong>
&lt;/h4>&lt;pre>&lt;code class="language-bash">cd your-blog-repo
git init
git remote add origin https://github.com/你的用户名/你的仓库名.git
&lt;/code>&lt;/pre>
&lt;h4 id="4-处理子模块主题">4. &lt;strong>处理子模块（主题）&lt;/strong>
&lt;/h4>&lt;p>如果使用了 Hugo 主题（如通过 Git 子模块添加）：&lt;/p>
&lt;pre>&lt;code class="language-bash"># 示例：添加主题为子模块
git submodule add https://github.com/主题作者/主题仓库.git themes/主题名
&lt;/code>&lt;/pre>
&lt;p>确保 &lt;code>.gitmodules&lt;/code> 文件已提交。&lt;/p>
&lt;hr>
&lt;h3 id="二触发-actions-的-push-内容">&lt;strong>二、触发 Actions 的 Push 内容&lt;/strong>
&lt;/h3>&lt;p>你需要将以下内容推送到 GitHub 仓库：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Hugo 源文件&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>config.toml&lt;/code>（Hugo 配置）&lt;/li>
&lt;li>&lt;code>content/&lt;/code>（文章）&lt;/li>
&lt;li>&lt;code>themes/&lt;/code>（主题，通常以子模块形式存在）&lt;/li>
&lt;li>&lt;code>archetypes/&lt;/code>、&lt;code>static/&lt;/code> 等其他 Hugo 所需文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>GitHub Actions 配置文件&lt;/strong>&lt;br>
确保 &lt;code>.github/workflows/deploy.yml&lt;/code> 文件存在于仓库中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>不包含生成的文件&lt;/strong>&lt;br>
&lt;strong>不要推送&lt;/strong> &lt;code>public/&lt;/code> 目录（Hugo 生成的静态文件会被 Actions 自动构建）。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="三操作流程示例">&lt;strong>三、操作流程示例&lt;/strong>
&lt;/h3>&lt;h4 id="1-本地修改并测试">1. &lt;strong>本地修改并测试&lt;/strong>
&lt;/h4>&lt;pre>&lt;code class="language-bash"># 本地生成静态文件测试（可选）
hugo server -D # 启动本地预览
&lt;/code>&lt;/pre>
&lt;h4 id="2-提交代码">2. &lt;strong>提交代码&lt;/strong>
&lt;/h4>&lt;pre>&lt;code class="language-bash">git add .
git commit -m &amp;quot;更新博客内容&amp;quot;
&lt;/code>&lt;/pre>
&lt;h4 id="3-推送到-github">3. &lt;strong>推送到 GitHub&lt;/strong>
&lt;/h4>&lt;pre>&lt;code class="language-bash">git push -u origin main # 假设主分支是 main
&lt;/code>&lt;/pre>
&lt;h4 id="4-触发-actions">4. &lt;strong>触发 Actions&lt;/strong>
&lt;/h4>&lt;p>推送后，到 GitHub 仓库的 &lt;strong>Actions&lt;/strong> 标签页查看运行状态。&lt;br>
若流程成功，阿里云 OSS 的存储桶中会自动出现 &lt;code>public/&lt;/code> 的内容。&lt;/p>
&lt;hr>
&lt;h3 id="四关键注意事项">&lt;strong>四、关键注意事项&lt;/strong>
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>分支匹配&lt;/strong>&lt;br>
确保工作流配置中的 &lt;code>push&lt;/code> 事件分支（默认所有分支）与你推送的分支一致。&lt;br>
（若需限制分支，可在配置中指定：&lt;code>on.push.branches: [main]&lt;/code>）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>密钥安全&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>阿里云的 &lt;code>OSS_KEY_ID&lt;/code> 和 &lt;code>OSS_KEY_SECRET&lt;/code> 必须通过 GitHub 仓库的 &lt;strong>Settings → Secrets&lt;/strong> 添加，&lt;strong>不要明文写在代码中&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>子模块更新&lt;/strong>&lt;br>
如果主题子模块有更新，需在本地执行：&lt;/p>
&lt;pre>&lt;code class="language-bash">git submodule update --remote --merge
git add themes/主题名
git commit -m &amp;quot;更新主题&amp;quot;
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>调试失败问题&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>若 Actions 运行失败，检查日志中的报错信息（如 Hugo 版本冲突、OSS 权限不足等）。&lt;/li>
&lt;li>本地可通过 &lt;code>hugo --minify&lt;/code> 命令预验证构建是否正常。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="五流程图解">&lt;strong>五、流程图解&lt;/strong>
&lt;/h3>&lt;pre>&lt;code>本地修改博客内容 → 提交并推送 → GitHub 触发 Actions → 自动构建 Hugo → 上传到 OSS
（无需手动操作部署）
&lt;/code>&lt;/pre>
&lt;p>通过这种方式，你只需专注于内容创作和本地代码修改，部署过程会完全自动化。&lt;/p>
&lt;h2 id="其他">其他
&lt;/h2>&lt;p>hexo的GithubAction自动部署，用了两个仓库——github.io与hexo项目仓库区分操作
&lt;a class="link" href="https://hackergavin.com/2024/01/11/hexo-automate-deploy/#%E5%88%9B%E5%BB%BA-Github-Actions-%E8%84%9A%E6%9C%AC" target="_blank" rel="noopener"
>https://hackergavin.com/2024/01/11/hexo-automate-deploy/#%E5%88%9B%E5%BB%BA-Github-Actions-%E8%84%9A%E6%9C%AC&lt;/a>&lt;/p>
&lt;p>另外一种hexo部署
&lt;a class="link" href="https://cloud.tencent.com/developer/article/2369534" target="_blank" rel="noopener"
>https://cloud.tencent.com/developer/article/2369534&lt;/a>&lt;/p></description></item><item><title>SSL证书手动更新</title><link>https://winotmk.github.io/posts/250220_ssl%E8%AF%81%E4%B9%A6%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0/</link><pubDate>Thu, 20 Feb 2025 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/250220_ssl%E8%AF%81%E4%B9%A6%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0/</guid><description>&lt;p>我要先吐槽一下是真麻烦，以前一年续签一次的免费证书多好，和服务器续费周期一致，一年维护一次就好了，现在搞得像交房租，每季度都要维护，听说Let’s Encrypt上可以发免费证书，然后通过类似Certbot或者httpsok来自动获取和部署，回头再研究了，似乎我用的这种老式虚拟云主机不能整这个，回头想换成容器服务，这官网价格一年500是逼着你转型网站服务器的节奏&lt;/p>
&lt;h2 id="获取新的证书">获取新的证书
&lt;/h2>&lt;p>&lt;a class="link" href="https://yundun.console.aliyun.com/?spm=5176.12818093_47.console-base_product-drawer-left.dcas.3be916d0TsU2HG&amp;amp;p=cas#/certExtend/free/cn-hangzhou?currentPage=1&amp;amp;pageSize=10&amp;amp;keyword=&amp;amp;statusCode=" target="_blank" rel="noopener"
>阿里云SSL证书管理&lt;/a>
这里点个人测试证书，然后申请域名&lt;code>winotmk.com&lt;/code>与&lt;code>md.winotmk.com&lt;/code>&lt;/p>
&lt;h2 id="部署证书">部署证书
&lt;/h2>&lt;h3 id="部署全站加速的证书">部署全站加速的证书
&lt;/h3>&lt;p>由于都是一个号里买的阿里云的产品，所以可以一键部署
&lt;img src="http://pictures.winotmk.com/250220_SSL%E8%AF%81%E4%B9%A6%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0/2025-02-20-21-32-48_ae56f6ac.png"
loading="lazy"
alt="2025-02-20-21-32-48"
>&lt;/p>
&lt;h3 id="部署到别的平台">部署到别的平台
&lt;/h3>&lt;p>先下载证书，点更多
&lt;img src="http://pictures.winotmk.com/250220_SSL%E8%AF%81%E4%B9%A6%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0/2025-02-20-21-41-10_324634aa.png"
loading="lazy"
alt="2025-02-20-21-41-10"
>&lt;/p>
&lt;p>这里选下载tab，下载第一个pem/key格式的证书即可，解压下来会是两个文件
&lt;img src="http://pictures.winotmk.com/250220_SSL%E8%AF%81%E4%B9%A6%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0/2025-02-20-21-43-04_7196ba9d.png"
loading="lazy"
alt="2025-02-20-21-43-04"
>&lt;/p>
&lt;p>winotmk.com 是我在新万网买的，所以这里登录后台
&lt;a class="link" href="https://www.xinwanwang.com/login.asp" target="_blank" rel="noopener"
>www.xinwanwang.com/login.asp&lt;/a>
&lt;img src="http://pictures.winotmk.com/250220_SSL%E8%AF%81%E4%B9%A6%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0/2025-02-20-21-36-55_f6ef3881.png"
loading="lazy"
alt="2025-02-20-21-36-55"
>&lt;/p>
&lt;p>用他给的管理员账号密码在控制面板里登录
&lt;img src="http://pictures.winotmk.com/250220_SSL%E8%AF%81%E4%B9%A6%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0/2025-02-20-21-38-38_2334f30f.png"
loading="lazy"
alt="2025-02-20-21-38-38"
>&lt;/p>
&lt;p>登录上以后在域名绑定这里选关闭强制http访问再打开，把刚才下载下来的证书密钥文件两个分别复制到对话框里即可完成部署啦！&lt;/p></description></item><item><title>投影仪推nas</title><link>https://winotmk.github.io/posts/250128_%E6%8A%95%E5%BD%B1%E6%94%BEnas%E8%B5%84%E6%BA%90/</link><pubDate>Tue, 28 Jan 2025 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/250128_%E6%8A%95%E5%BD%B1%E6%94%BEnas%E8%B5%84%E6%BA%90/</guid><description>&lt;h2 id="投影仪侧解码的软件">投影仪侧解码的软件
&lt;/h2>&lt;p>&lt;a class="link" href="https://www.zhihu.com/tardis/zm/art/408177850" target="_blank" rel="noopener"
>https://www.zhihu.com/tardis/zm/art/408177850&lt;/a>
KODI软件，可以直接这里
&lt;a class="link" href="https://kodi.tv/download/android/" target="_blank" rel="noopener"
>https://kodi.tv/download/android/&lt;/a>
下载到能直接安装的软件，试了极米的投影可直接装，然后要设置nas的文件目录，从而通过局域网读取视频文件，显然这是通过投影里解码的，卡得飞起，很快就出现了音话不同步的问题&lt;/p>
&lt;h2 id="nas解码的软件">nas解码的软件
&lt;/h2>&lt;p>群晖自己有video station，有nas内的软件，也提供客户端，还有专为tv提供的软件：
&lt;a class="link" href="https://www.synology.cn/zh-cn/support/download/DS720&amp;#43;?version=7.2#androids" target="_blank" rel="noopener"
>https://www.synology.cn/zh-cn/support/download/DS720+?version=7.2#androids&lt;/a>&lt;/p>
&lt;p>但是这里的tv版装会出现装完了但是会有看不到图标的问题，多半是因为极影用的安卓并不是安卓tv而是魔改的安卓，所以要使用群晖的这个客户端，要么自己重新编一下
&lt;a class="link" href="https://blog.csdn.net/hx7013/article/details/103764083" target="_blank" rel="noopener"
>https://blog.csdn.net/hx7013/article/details/103764083&lt;/a>&lt;/p>
&lt;p>要么下这个改过入口app的软件——DSVideo GO!，配合群晖官方的客户端即可使用!
&lt;a class="link" href="http://nasyun.com/thread-63924-1-1.html" target="_blank" rel="noopener"
>http://nasyun.com/thread-63924-1-1.html&lt;/a>&lt;/p></description></item><item><title>新的macbook air</title><link>https://winotmk.github.io/posts/241031_%E6%96%B0mac/</link><pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/241031_%E6%96%B0mac/</guid><description>&lt;p>泰香辣，24年10月31，入了垂涎已久的macbook air M3，之前买的m1pro的macbookpro给了女票剪视频用了，自己平常用台式还是想入个轻便的本本，然后补贴价格入的，真香真香
&lt;img src="https://winotmk.github.io/images/20241031133508.png"
loading="lazy"
>&lt;/p>
&lt;p>现在的mac下截图有Longshot（和win下的snipaste完全平替），vscode也一样的用，svn也很好使，群晖nas上的也很好使，还能iphone投屏了！很适合带到图书馆公司里，开盖就做点东西用，重要的是重量和大小，仿佛一个大号的ipad但是x86pc能做的基本都可以做~&lt;/p></description></item><item><title>外网访问群晖NAS的文件</title><link>https://winotmk.github.io/posts/241008_%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%E7%BE%A4%E6%99%96nas%E7%9A%84%E6%96%87%E4%BB%B6/</link><pubDate>Tue, 08 Oct 2024 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/241008_%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%E7%BE%A4%E6%99%96nas%E7%9A%84%E6%96%87%E4%BB%B6/</guid><description>&lt;h2 id="方法一开smb文件服务再映射端口">方法一：开SMB文件服务再映射端口
&lt;/h2>&lt;p>在这里打开SMB
&lt;img src="https://winotmk.github.io/images/20241008142104.png"
loading="lazy"
>&lt;/p>
&lt;p>然后在路由器里打开端口转发，需要&lt;code>137-139,445&lt;/code>这么几个端口，我是路由拨号已有公网IP
&lt;img src="https://winotmk.github.io/images/20241008142043.png"
loading="lazy"
>&lt;/p>
&lt;p>这样的好处就是相对简单，不需要客户端再装软件windows自带即可连接，当然需要NAS有公网IP（或者再做穿透）&lt;/p>
&lt;p>缺点：坏处就是，这个几个端口似乎非常&lt;strong>不安全&lt;/strong>，在我转发这几个端口后，可以看到一直有IP尝试钻进来被NAS封，而且如果想要改这几个端口似乎不是那么容易的懒得研究啦
&lt;img src="https://winotmk.github.io/images/20241008142823.png"
loading="lazy"
>&lt;/p>
&lt;p>某天在公司忽然死活连不上后（内网还可以访问，说明SMB服务没问题，也许被运营商封端口了？），尝试另一种访问文件的方法&lt;/p>
&lt;h2 id="方法二weadavraidrive客户端">方法二：WeaDAV+RaiDrive客户端
&lt;/h2>&lt;p>首先NAS上装WeaDAV，设置一下：
&lt;img src="https://winotmk.github.io/images/20241008143718.png"
loading="lazy"
>
路由器里转发这俩端口就可以
然后pc安装RaiDrive这个软件，设置如下：
&lt;img src="https://winotmk.github.io/images/20241008143914.png"
loading="lazy"
>
&lt;img src="https://winotmk.github.io/images/20241008143024.png"
loading="lazy"
>
即可成功挂载一个带盘符的网络驱动器，试了下稳定性还是不错的，速度和SMB无异，用起来也没啥区别
缺点：开机得启动RaiDrive这个软件，而且似乎读不了正确的NAS容量大小（500g是我自己填的)
&lt;img src="https://winotmk.github.io/images/20241008143359.png"
loading="lazy"
>&lt;/p></description></item><item><title>calibre_web的pdf封面提取问题</title><link>https://winotmk.github.io/posts/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 25 Sep 2024 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/</guid><description>&lt;p>在用&lt;code>johngong/calibre-web:latest&lt;/code>这个镜像 &lt;a class="link" href="https://hub.docker.com/r/johngong/calibre-web" target="_blank" rel="noopener"
>https://hub.docker.com/r/johngong/calibre-web&lt;/a>
作为自己nas上的图书馆时发现pdf文件无法生成封面，
&lt;img src="https://winotmk.github.io/images/20240925124359.png"
loading="lazy"
>&lt;/p>
&lt;p>断断续续排查了两周，百思不得解，尝试过：&lt;/p>
&lt;ul>
&lt;li>设置imagemagick的&lt;code>policy.xml&lt;/code>文件(&lt;code>/etc/Imagemagick/policy.xml&lt;/code>)&lt;/li>
&lt;li>使用lscr.io/linuxserver/calibre-web:latest的镜像&lt;/li>
&lt;li>自己重新构建镜像&lt;/li>
&lt;li>重新安装calibre-web包和重装imagemagick包
都解决不了，总之是十分折腾，最后认为可能是&lt;code>johngong/calibre-web:latest&lt;/code>可能是里少了一个&lt;code>imagemagick-pdf&lt;/code>包&lt;/li>
&lt;/ul>
&lt;h2 id="最终有效的解决方法的折腾流程">最终有效的解决方法的折腾流程
&lt;/h2>&lt;p>我尝试上传pdf文件，然后打开日志（日志级别设置为DEBUG）
&lt;img src="https://winotmk.github.io/images/20240925123504.png"
loading="lazy"
>
查看文件：/config/calbre-web/calbre-web.log
有这么一行：
&lt;img src="https://winotmk.github.io/images/20240925123738.png"
loading="lazy"
>&lt;/p>
&lt;pre>&lt;code>[2024-09-25 12:10:22,144] WARN {cps.uploader:237} Cannot extract cover image, using default: no decode delegate for this image format `PDF' @ error/constitute.c/ReadImage/746
[2024-09-25 12:10:22,145] WARN {cps.uploader:238} On Windows this error could be caused by missing ghostscript
&lt;/code>&lt;/pre>
&lt;p>PDF转就转不出来
所以找到了：
&lt;img src="https://winotmk.github.io/images/20240925123303.png"
loading="lazy"
>
&lt;a class="link" href="https://github.com/ImageMagick/ImageMagick/issues/6148" target="_blank" rel="noopener"
>https://github.com/ImageMagick/ImageMagick/issues/6148&lt;/a>&lt;/p>
&lt;pre>&lt;code>apk add --no-cache imagemagick imagemagick-pdf
&lt;/code>&lt;/pre>
&lt;p>安装完以后，再次尝试上传pdf格式的书，就看见封面辣！！
&lt;img src="https://winotmk.github.io/images/20240925123414.png"
loading="lazy"
>&lt;/p>
&lt;!-- more -->
&lt;h2 id="johngongcalibre-web的一些设置">johngong/calibre-web的一些设置
&lt;/h2>&lt;p>&lt;a class="link" href="https://github.com/gshang2017/docker/issues/133" target="_blank" rel="noopener"
>https://github.com/gshang2017/docker/issues/133&lt;/a>
如果一编辑图书的元数据就卡死，可用尝试：
&lt;img src="https://winotmk.github.io/images/20240925134344.png"
loading="lazy"
>
这两条设置为true,则
&lt;img src="https://winotmk.github.io/images/20240925134613.png"
loading="lazy"
>
这里不会出现google等选项，家里的nas没有梯子环境，反而会导致卡死，所以禁用google吧。。也没啥用&lt;/p>
&lt;h2 id="弯路">弯路
&lt;/h2>&lt;p>这里想记一下这个弯路，在calibre-web的FAQ里赫然记着有关pdf文件转不出封面的解决办法，说要改
&lt;img src="https://winotmk.github.io/images/20240925140205.png"
loading="lazy"
>
&lt;a class="link" href="https://github.com/janeczku/calibre-web/wiki/FAQ#what-to-do-if-cover-pictures-are-not-extracted-from-pdf-files" target="_blank" rel="noopener"
>https://github.com/janeczku/calibre-web/wiki/FAQ#what-to-do-if-cover-pictures-are-not-extracted-from-pdf-files&lt;/a>
所以可以有&lt;code>/etc/Imagemagick/policy.xml&lt;/code>:&lt;/p>
&lt;pre>&lt;code>&amp;lt;policymap&amp;gt;
&amp;lt;policy domain=&amp;quot;coder&amp;quot; rights=&amp;quot;read | write&amp;quot; pattern=&amp;quot;{MSVG,MVG,PS,PDF,RSVG,SVG,XPS}&amp;quot; /&amp;gt;
&amp;lt;/policymap&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>这是最容易找到的一种解法，但我自己试了无用，没有上面的装&lt;code>apk add imagemagick-pdf&lt;/code>好使&lt;/p>
&lt;h2 id="尝试出来的另一种pdf封面提取可行方法">尝试出来的另一种PDF封面提取可行方法
&lt;/h2>&lt;p>这样做出来的calibre-web镜像可以实现PDF转换，但是没有电子书格式转换，没有禁用google元数据搜索，没有中文环境，懒得自己做了，还是修修用&lt;code>johngong/calibre-web&lt;/code>包吧
为了试验，我用&lt;code>FROM ubuntu:latest&lt;/code>作为镜像基底，然后：&lt;/p>
&lt;h3 id="装calibre-web">装calibre-web
&lt;/h3>&lt;p>安装calibre-web：
&lt;img src="https://winotmk.github.io/images/20240925132535.png"
loading="lazy"
>
&lt;a class="link" href="https://github.com/janeczku/calibre-web?tab=readme-ov-file#installation" target="_blank" rel="noopener"
>https://github.com/janeczku/calibre-web?tab=readme-ov-file#installation&lt;/a>
&lt;a class="link" href="https://github.com/janeczku/calibre-web/wiki/Dependencies-in-Calibre-Web-Linux-and-Windows" target="_blank" rel="noopener"
>https://github.com/janeczku/calibre-web/wiki/Dependencies-in-Calibre-Web-Linux-and-Windows&lt;/a>
这里也有提到
&lt;a class="link" href="https://chenjiehua.me/others/calibre-web-personal-book-store.html" target="_blank" rel="noopener"
>https://chenjiehua.me/others/calibre-web-personal-book-store.html&lt;/a>&lt;/p>
&lt;pre>&lt;code>pip install calibreweb
pip install calibreweb[metadata]
&lt;/code>&lt;/pre>
&lt;h3 id="装imagemagick">装imagemagick
&lt;/h3>&lt;p>然后安装imagemagick
官方：
&lt;a class="link" href="https://imagemagick.org/script/download.php" target="_blank" rel="noopener"
>https://imagemagick.org/script/download.php&lt;/a>
也有提到：
&lt;a class="link" href="https://www.cnblogs.com/echohye/p/17727865.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/echohye/p/17727865.html&lt;/a>&lt;/p>
&lt;pre>&lt;code>apt install imagemagick
&lt;/code>&lt;/pre>
&lt;p>装完后&lt;code>convert&lt;/code>和&lt;code>magick&lt;/code>命令应当是可用的&lt;/p>
&lt;h3 id="手动装imagemagick">手动装imagemagick
&lt;/h3>&lt;p>或者我用上面官方的magick文件手动配貌似也行：
先把magick文件放入根目录&lt;/p>
&lt;pre>&lt;code>./magick --appimage-extract
&lt;/code>&lt;/pre>
&lt;p>&lt;a class="link" href="https://docs.appimage.org/user-guide/troubleshooting/fuse.html" target="_blank" rel="noopener"
>https://docs.appimage.org/user-guide/troubleshooting/fuse.html&lt;/a>
提到了可以用&lt;code>--appimage-extract&lt;/code>直接释放出软件包来
会发现释放出来文件在&lt;code>/squashfs-root&lt;/code>目录里
设置环境变量：&lt;/p>
&lt;pre>&lt;code>export MAGICK_HOME=&amp;quot;/squashfs-root/usr&amp;quot;
export PATH=&amp;quot;$MAGICK_HOME/bin:$PATH&amp;quot;
export LD_LIBRARY_PATH=&amp;quot;${LD_LIBRARY_PATH:+$LD_LIBRARY_PATH:}$MAGICK_HOME/lib&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>然后imagemagick应该就能用了。。&lt;/p>
&lt;h3 id="其他">其他
&lt;/h3>&lt;p>&lt;code>lscr.io/linuxserver/calibre-web:latest&lt;/code>
这个镜像也不小，但功能还算完整，上传pdf可直接显示封面，但不是中文环境，而且部署到我的nas上后死活传不了新书说什么无法写入，懒得深究了，弃之&lt;/p></description></item><item><title>给docker容器内配置中文环境(minecraft开服相关)</title><link>https://winotmk.github.io/posts/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/</link><pubDate>Thu, 15 Aug 2024 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/</guid><description>&lt;p>最近找到个整合包（因为懒得一个个翻bbs
&lt;a class="link" href="https://www.bilibili.com/read/cv7403697/?spm_id_from=333.999.collection.opus.click" target="_blank" rel="noopener"
>https://www.bilibili.com/read/cv7403697/?spm_id_from=333.999.collection.opus.click&lt;/a>
&lt;img src="https://winotmk.github.io/images/20240815141238.png"
loading="lazy"
>
这包里的mod和之前自己开的服务器高度相似，太棒啦，从1.7.10直升1.12.2，基本还都是熟悉的味道
才知道mcbbs已经无了，然后才可发现mc百科已经这么好用了，连接直连发布curseforge和github，省去搬运步骤，也蛮好的！
服务端有了，想通过docker容器部署到我的群晖NAS上，DS720+扩容了根16G内存条放着也是放着&lt;/p>
&lt;h2 id="选取docker镜像">选取docker镜像
&lt;/h2>&lt;p>docker hub里有官方镜像，用的是这个，体积精简，只运行环境jre就够了
&lt;a class="link" href="https://hub.docker.com/_/openjdk/tags?page=1&amp;amp;page_size=&amp;amp;name=8u342&amp;amp;ordering=" target="_blank" rel="noopener"
>https://hub.docker.com/_/openjdk/tags?page=1&amp;page_size=&amp;name=8u342&amp;ordering=&lt;/a>
&lt;img src="https://winotmk.github.io/images/20240815121544.png"
loading="lazy"
>
所以直接&lt;/p>
&lt;pre>&lt;code>docker pull openjdk:8u342-jre-slim
&lt;/code>&lt;/pre>
&lt;p>然后直接这样运行就好了&lt;/p>
&lt;pre>&lt;code>docker run -it -d \
-p 25565:25565 \
-v E:\game\MC\1.12.2mohist_服务端:/mc \
-w /mc \
--name MC1122 \
openjdk:8u342-jre-slim \
java -Xms2G -Xmx8G -XX:+UseG1GC -XX:+AggressiveOpts -XX:+UseCompressedOops -jar Mohist-1.12.2-c950429-server.jar nogui
&lt;/code>&lt;/pre>
&lt;p>虽然长，但是总的来说挺简单，用&lt;code>openjdk:8u342-jre-slim&lt;/code>镜像运行&lt;code>java&lt;/code>命令罢了，但是！
出现了一个人让人感觉不爽的小问题，服务端的log输出以及游戏内服务端来的输出都是英文的，这在之前直接windows运行时不是这样的，所以第一反应是语言环境问题
&lt;img src="https://winotmk.github.io/images/20240815123217.png"
loading="lazy"
>
&lt;img src="https://winotmk.github.io/images/20240815123240.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="设置环境变量">设置环境变量
&lt;/h2>&lt;p>在&lt;code>docker run&lt;/code>的时候加上个参数&lt;code>-e LANG=&amp;quot;zh_CN.UTF-8&amp;quot;&lt;/code>，类似&lt;code>export LANG=zh_CN.UTF-8&lt;/code>
确定环境变量生效了：
&lt;img src="https://winotmk.github.io/images/20240815123341.png"
loading="lazy"
>
但没解决问题，反而似乎导致启动的时候不认识中文的mod文件名了&lt;/p>
&lt;p>在查找这个之后：&lt;a class="link" href="https://blog.csdn.net/myli92/article/details/139909499?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22139909499%22%2C%22source%22%3A%22unlogin%22%7D" target="_blank" rel="noopener"
>docker 容器设置中文环境&lt;/a>
发现单纯设置&lt;code>LANG&lt;/code>的变量不行，容器里就没有中文字符集的&lt;/p>
&lt;h3 id="查看已有语言">查看已有语言
&lt;/h3>&lt;pre>&lt;code>locale -a
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240815123200.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="安装中文环境">安装中文环境
&lt;/h3>&lt;p>&lt;a class="link" href="https://blog.csdn.net/star1210644725/article/details/108747049" target="_blank" rel="noopener"
>使用DockerFile的方式快速构建一个基础镜像，解决中文环境问题&lt;/a>
所以安装中文环境的命令可以是：&lt;/p>
&lt;pre>&lt;code>apt-get install -y language-pack-zh-hans
&lt;/code>&lt;/pre>
&lt;p>但这样不行！因为这个是ubuntu的命令，查看我的docker镜像的信息发现是以debian基底的
&lt;img src="https://winotmk.github.io/images/20240815132128.png"
loading="lazy"
>&lt;/p>
&lt;p>看到:&lt;a class="link" href="https://blog.csdn.net/forever_008/article/details/103720389" target="_blank" rel="noopener"
>Debian系统安装中文包&lt;/a>&lt;/p>
&lt;pre>&lt;code>dpkg-reconfigure locales
&lt;/code>&lt;/pre>
&lt;p>然后再选&lt;code>zh_CN.UTF-8&lt;/code>，可行，但是集成到镜像里没那么好使，还好有别的方法&lt;/p>
&lt;h2 id="制作新镜像">制作新镜像
&lt;/h2>&lt;p>参考：&lt;a class="link" href="https://blog.csdn.net/wyazyf/article/details/90676364" target="_blank" rel="noopener"
>dockerfile文件中给debian设置中文支持&lt;/a>&lt;/p>
&lt;h3 id="dockerfile">dockerfile
&lt;/h3>&lt;pre>&lt;code>FROM openjdk:8u342-jre-slim
RUN apt-get clean &amp;amp;&amp;amp; apt-get update &amp;amp;&amp;amp; apt-get install -y locales &amp;amp;&amp;amp; localedef -c -f UTF-8 -i zh_CN zh_CN.utf8
WORKDIR /mc
ENV LANG zh_CN.UTF-8
&lt;/code>&lt;/pre>
&lt;p>保存为dockerfile文件然后&lt;/p>
&lt;pre>&lt;code>docker build -t jre8u342_ch .
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240815123827.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="测试运行">测试运行
&lt;/h3>&lt;pre>&lt;code>docker run -it -d \
-p 25565:25565 \
-v E:\game\MC\1.12.2mohist_服务端:/mc \
--name MC1122 \
jre8u342_ch:latest \
java -Xms2G -Xmx8G -XX:+UseG1GC -XX:+AggressiveOpts -XX:+UseCompressedOops -jar Mohist-1.12.2-c950429-server.jar nogui
&lt;/code>&lt;/pre>
&lt;p>因为dockerfile里已经设置过&lt;code>WORKDIR&lt;/code>了所以不需要&lt;code>-w&lt;/code>参数&lt;/p>
&lt;p>这下不会报英文了
&lt;img src="https://winotmk.github.io/images/20240815124038.png"
loading="lazy"
>
&lt;img src="https://winotmk.github.io/images/20240815124056.png"
loading="lazy"
>
游戏里也是中文环境的返回信息
&lt;img src="https://winotmk.github.io/images/20240815124137.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="部署到群晖">部署到群晖
&lt;/h2>&lt;p>先把做好的镜像打包出来，方便传到群晖NAS里&lt;/p>
&lt;pre>&lt;code>docker save -o jre8u342_ch.tar jre8u342_ch:latest
&lt;/code>&lt;/pre>
&lt;p>先导入这个镜像
&lt;img src="https://winotmk.github.io/images/20240815132343.png"
loading="lazy"
>
然后简单配置一下端口和mc服务器目录就可以了,和上面的&lt;code>docker run&lt;/code>其实是一样的
&lt;img src="https://winotmk.github.io/images/20240815132446.png"
loading="lazy"
>
端口的&lt;code>25565&lt;/code>是游戏端口&lt;code>25575&lt;/code>用作管理，下面会提到&lt;/p>
&lt;h2 id="服务器远程管理">服务器远程管理
&lt;/h2>&lt;p>用容器托管运行了，上哪去敲&lt;code>/op xxxx&lt;/code>和&lt;code>/stop&lt;/code>之类的管理命令呢？
可以用rcon方案！
&lt;a class="link" href="https://wiki.vg/RCON" target="_blank" rel="noopener"
>https://wiki.vg/RCON&lt;/a>
具体就是用这个软件：
&lt;a class="link" href="https://github.com/Tiiffi/mcrcon" target="_blank" rel="noopener"
>https://github.com/Tiiffi/mcrcon&lt;/a>&lt;/p>
&lt;h3 id="安装和服务端配置">安装和服务端配置：
&lt;/h3>&lt;pre>&lt;code>git clone https://github.com/Tiiffi/mcrcon.git
cd mcrcon
make
sudo make install
&lt;/code>&lt;/pre>
&lt;p>然后服务端也要配置一下，在&lt;code>server.properties&lt;/code>里的&lt;/p>
&lt;pre>&lt;code>enable-rcon=false
&lt;/code>&lt;/pre>
&lt;p>改为&lt;/p>
&lt;pre>&lt;code>enable-rcon=true
rcon.password=your_passwd
rcon.port=25575
&lt;/code>&lt;/pre>
&lt;h3 id="用法">用法：
&lt;/h3>&lt;p>先连接&lt;/p>
&lt;pre>&lt;code>mcrcon -H 服务器地址 -p your_passwd
&lt;/code>&lt;/pre>
&lt;p>然后就可以一样敲各种minecraft管理命令了&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240815125134.png"
loading="lazy"
>&lt;/p>
&lt;p>好了不说了博主我要去挖矿开荒了
&lt;img src="https://winotmk.github.io/images/20240815133408.png"
loading="lazy"
>
&lt;img src="https://winotmk.github.io/images/20240815133429.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="参考">参考
&lt;/h2>&lt;p>debian文档，第 8 章 国际化和本地化：
&lt;a class="link" href="https://www.debian.org/doc/manuals/debian-reference/ch08.zh-cn.html#_rationale_for_utf_8_locale" target="_blank" rel="noopener"
>https://www.debian.org/doc/manuals/debian-reference/ch08.zh-cn.html#_rationale_for_utf_8_locale&lt;/a>&lt;/p>
&lt;p>类似的打包好的docker环境MC服务器镜像有：
&lt;a class="link" href="https://github.com/itzg/docker-minecraft-server/tree/master" target="_blank" rel="noopener"
>https://github.com/itzg/docker-minecraft-server/tree/master&lt;/a>
对我来说功能有点多，只是参考参考&lt;/p></description></item><item><title>python格式化字符串的方法</title><link>https://winotmk.github.io/posts/240810_python%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Sat, 10 Aug 2024 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/240810_python%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>&lt;p>问题:
例如
&lt;code>print(&amp;quot;位置过期:%-6.0f秒&amp;quot;%cachetime)&lt;/code>的&lt;code>%-6.0f&lt;/code>是什么意思？
&lt;code>%-6.0f&lt;/code>里的每一个字符都是有意义的&lt;/p>
&lt;p>在 Python 中，%-6.0f 是一种格式化字符串的方法，用于格式化浮点数 cachetime 的值。让我们来逐部分解释：&lt;/p>
&lt;h2 id="解释">解释
&lt;/h2>&lt;h3 id="heading">%：
&lt;/h3>&lt;p>&lt;code>%&lt;/code> 是格式化操作符，用于将后面指定的变量格式化并插入到字符串中。&lt;/p>
&lt;h3 id="-6">-6：
&lt;/h3>&lt;p>&lt;code>-6&lt;/code> 是一个宽度说明符，它指定了格式化后输出的最小宽度为 6 个字符。
&lt;code>-&lt;/code> 表示左对齐。如果没有这个符号（即为默认的右对齐），数字会向右对齐。
如果数字宽度不足 6 个字符，则会在数字右侧补充空格，以达到 6 个字符的总宽度。&lt;/p>
&lt;h3 id="0">.0：
&lt;/h3>&lt;p>&lt;code>.0&lt;/code> 指定了浮点数的小数部分显示 0 位（即不显示小数部分）。因此，浮点数会被显示为整数形式。&lt;/p>
&lt;h3 id="f">f：
&lt;/h3>&lt;p>&lt;code>f&lt;/code> 表示将变量作为浮点数进行格式化。
ps:如果不用格式化字符串，直接&lt;code>print(cachetime)&lt;/code>会报错，因为不能直接打印浮点数，可以&lt;code>print(str(cachetime))&lt;/code>&lt;/p>
&lt;h2 id="例子">例子
&lt;/h2>&lt;p>假设 cachetime 的值是 820.75，则：&lt;/p>
&lt;pre>&lt;code class="language-python">cachetime = 820.75
formatted_string = u&amp;quot;位置过期:%-6.0f秒&amp;quot; % cachetime
print(formatted_string)
&lt;/code>&lt;/pre>
&lt;p>输出：&lt;/p>
&lt;pre>&lt;code class="language-makefile">位置过期:821 秒
&lt;/code>&lt;/pre>
&lt;h2 id="输出解释">输出解释：
&lt;/h2>&lt;p>&lt;code>%-6.0f&lt;/code> 将 &lt;code>820.75&lt;/code> 格式化为 &lt;code>821&lt;/code>（由于 .0 不显示小数部分）。
&lt;code>821&lt;/code> 左对齐，占用至少 6 个字符的位置。如果 &lt;code>821&lt;/code> 只有 3 个字符，右边会填充 3 个空格，使得总宽度为 6 个字符。
如果你将数字换成更小的，比如 10：&lt;/p>
&lt;pre>&lt;code class="language-python">cachetime = 10
formatted_string = u&amp;quot;位置过期:%-6.0f秒&amp;quot; % cachetime
print(formatted_string)
&lt;/code>&lt;/pre>
&lt;p>输出：&lt;/p>
&lt;pre>&lt;code class="language-makefile">位置过期:10 秒
&lt;/code>&lt;/pre>
&lt;p>10 会左对齐，后面会补充 4 个空格，使总长度达到 6 个字符。&lt;/p></description></item><item><title>网站框架收集</title><link>https://winotmk.github.io/posts/240806_%E7%BD%91%E7%AB%99%E6%A1%86%E6%9E%B6%E6%94%B6%E9%9B%86/</link><pubDate>Tue, 06 Aug 2024 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/240806_%E7%BD%91%E7%AB%99%E6%A1%86%E6%9E%B6%E6%94%B6%E9%9B%86/</guid><description>&lt;p>其实自己很长一段（接下来将来可能也会）时间内有两个网站，一个是习惯稍微正式点的东西写在：
&lt;a class="link" href="https://www.winotmk.com/" target="_blank" rel="noopener"
>https://www.winotmk.com/&lt;/a>
是我的第一个网站，基于wordpress的，买的包年虚拟服务器，但很多内容年久失修，而且刚架设的时候什么也不知道，一点点摸通服务器，备案，注册域名之类的，那会儿还挺流行wordpress，似乎也没有别的更多的选择
同时还有一个
&lt;a class="link" href="https://md.winotmk.com/" target="_blank" rel="noopener"
>https://md.winotmk.com/&lt;/a>
(&lt;a class="link" href="https://winotmk.github.io/" target="_blank" rel="noopener"
>https://winotmk.github.io/&lt;/a>)
由hexo驱动的纯静态md文档网站，比较随意，想到啥写啥，构建方式也比较特别，是运行在云服务的容器里，静态文章则是在阿里云nas存储里，网站生成后托管在github，同时cdn加速
似乎md站可以用更放松的心情去记录，慢慢的文章比主站还多了？！&lt;/p>
&lt;p>因为目前主站的各种小毛病（也不是不能用）所以经常考虑要不要把它换套别的结构，网上一搜确实有比如一键wordpress转hugo的方案，总之先记着，不一定用。因为当初20块买了套便宜的wordpress皮肤，然后在此基础上魔改各种css，已然改成了忒修斯之船，全丢弃了还是挺可惜的（沉没成本2333&lt;/p>
&lt;h2 id="网站生成框架">网站生成/框架
&lt;/h2>&lt;h3 id="typecho">typecho
&lt;/h3>&lt;p>&lt;img src="https://winotmk.github.io/images/20240619132246.png"
loading="lazy"
>&lt;/p>
&lt;blockquote>
&lt;p>Typecho 是一款基于 PHP 的博客软件，旨在成为世界上最强大的博客引擎
&lt;a class="link" href="https://github.com/typecho/typecho" target="_blank" rel="noopener"
>https://github.com/typecho/typecho&lt;/a>
&lt;a class="link" href="https://typecho.org/" target="_blank" rel="noopener"
>https://typecho.org/&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240806150559.png"
loading="lazy"
>
这个好在和wordpress一样也是PHP的，想必能很快的迁移过来吧，而且目测更轻量，就是可能还是得租虚拟服务器了&lt;/p>
&lt;!-- more -->
&lt;p>预览博客：
&lt;a class="link" href="https://xhhdd.cc/index.php/archives/27/" target="_blank" rel="noopener"
>https://xhhdd.cc/index.php/archives/27/&lt;/a>
&lt;a class="link" href="https://cfanlost.com/" target="_blank" rel="noopener"
>https://cfanlost.com/&lt;/a>&lt;/p>
&lt;h3 id="hugo">hugo
&lt;/h3>&lt;p>&lt;a class="link" href="https://gohugo.io/" target="_blank" rel="noopener"
>https://gohugo.io/&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240806151141.png"
loading="lazy"
>
似乎是类hexo生成静态网页，然后可以塞到github托管的&lt;/p>
&lt;h3 id="pelican">pelican
&lt;/h3>&lt;blockquote>
&lt;p>Pelican 是一个用Python编写的静态站点生成器，允许您通过编写 Markdown、reStructuredText 和 HTML 等格式的文本文件来创建网站
&lt;a class="link" href="https://github.com/getpelican/pelican" target="_blank" rel="noopener"
>https://github.com/getpelican/pelican&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>听起来类似hexo和hugo，只是一个nodejs，一个go，这个则是python做的（真好啊&lt;/p>
&lt;h3 id="jekyllrb">jekyllrb
&lt;/h3>&lt;blockquote>
&lt;p>将纯文本转换为静态网站和博客
&lt;a class="link" href="https://jekyllrb.com/" target="_blank" rel="noopener"
>https://jekyllrb.com/&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>应该和上面类似，同样是静态文章生成，部署到github&lt;/p>
&lt;p>预览博客：https://jaminzhang.github.io/linux/Change-Linux-System-Locale-Envs/
&lt;img src="https://winotmk.github.io/images/20240814160206.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="皮肤主题">皮肤/主题
&lt;/h2>&lt;h3 id="typecho-1">typecho
&lt;/h3>&lt;h4 id="handsome">handsome
&lt;/h4>&lt;p>&lt;a class="link" href="https://www.ihewro.com/archives/489/" target="_blank" rel="noopener"
>https://www.ihewro.com/archives/489/&lt;/a>
&lt;img src="https://winotmk.github.io/images/20240806150942.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="pelican-1">pelican
&lt;/h3>&lt;h4 id="attila">attila
&lt;/h4>&lt;p>&lt;a class="link" href="https://github.com/arulrajnet/attila" target="_blank" rel="noopener"
>https://github.com/arulrajnet/attila&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240806152032.png"
loading="lazy"
>&lt;/p>
&lt;p>预览博客：https://leonis.cc/sui-sui-nian/2023-10-31-cloudflare-dns-of-blog.html
&lt;img src="https://winotmk.github.io/images/20240806152133.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="hugo-1">hugo
&lt;/h3>&lt;h4 id="papermod">PaperMod
&lt;/h4>&lt;p>&lt;a class="link" href="https://themes.gohugo.io/themes/hugo-papermod/" target="_blank" rel="noopener"
>https://themes.gohugo.io/themes/hugo-papermod/&lt;/a>&lt;/p>
&lt;p>Demo:https://adityatelange.github.io/hugo-PaperMod/&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20241226162048.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="评论系统">评论系统
&lt;/h2>&lt;h3 id="waline">waline
&lt;/h3>&lt;p>&lt;a class="link" href="https://github.com/walinejs/waline" target="_blank" rel="noopener"
>https://github.com/walinejs/waline&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240806152451.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="utterances">utterances
&lt;/h3>&lt;p>是一个基于GitHub issues的轻量级评论，用github登录
&lt;a class="link" href="https://utteranc.es/" target="_blank" rel="noopener"
>https://utteranc.es/&lt;/a>&lt;/p>
&lt;p>&lt;img src="http://pictures.winotmk.com/240806_%E7%BD%91%E7%AB%99%E6%A1%86%E6%9E%B6%E6%94%B6%E9%9B%86/2025-02-21-18-45-31_1781e237.png"
loading="lazy"
alt="2025-02-21-18-45-31"
>&lt;/p></description></item><item><title>段码屏开发—GPT4o带来的一点点震撼</title><link>https://winotmk.github.io/posts/240724_%E6%AE%B5%E7%A0%81%E5%B1%8F%E5%BC%80%E5%8F%91gpt4o%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E9%9C%87%E6%92%BC/</link><pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/240724_%E6%AE%B5%E7%A0%81%E5%B1%8F%E5%BC%80%E5%8F%91gpt4o%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E9%9C%87%E6%92%BC/</guid><description>&lt;h2 id="硬件简介">硬件简介
&lt;/h2>&lt;h3 id="屏幕">屏幕
&lt;/h3>&lt;p>屏幕使用了一块微雪的电子墨水段码屏
&lt;img src="https://winotmk.github.io/images/20240726135400.png"
loading="lazy"
>
文档在这里：
&lt;a class="link" href="https://www.waveshare.net/wiki/1.9inch_Segment_e-Paper_Module_Manual" target="_blank" rel="noopener"
>https://www.waveshare.net/wiki/1.9inch_Segment_e-Paper_Module_Manual&lt;/a>&lt;/p>
&lt;h3 id="mcu">MCU
&lt;/h3>&lt;p>MCU方面就是树莓派的PICO，只不过是物理体积更小的版本，用法是一模一样的
&lt;img src="https://winotmk.github.io/images/20240726135455.png"
loading="lazy"
>
&lt;a class="link" href="https://www.waveshare.net/wiki/RP2040-Zero" target="_blank" rel="noopener"
>https://www.waveshare.net/wiki/RP2040-Zero&lt;/a>&lt;/p>
&lt;h2 id="字节byte和比特bit的对应">字节(byte)和比特(bit)的对应
&lt;/h2>&lt;p>最近买了块高颜值段码屏，电子墨水屏原理的，一直没弄明白这个文档里说得是个啥意思，恰好最近尝试使用GPT来解决我遇到的一些编程问题，
本来只是抱着试试看的态度，因为自从chatgpt火了以后一直持观望态度，印象中还只是能给它设定模仿人格写写小说一类的，然而这次实在小震撼到我
起初这个表对于完全没接触过这块的我完全不动他是什么意思&lt;/p>
&lt;blockquote>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240724185010.png"
loading="lazy"
>&lt;/p>&lt;/blockquote>
&lt;p>疑惑的关键在于0x00怎么就全0，而0xff怎么就全1了呢，于是我问GPT：
&lt;img src="https://winotmk.github.io/images/20240724185139.png"
loading="lazy"
>
*&lt;strong>以下是GPT的回答&lt;/strong>
在这个图表中，每个字节（byte）由 8 个比特（bit）组成，且每个比特都可以存储一个二进制值（0 或 1）。这些比特在图像中对应的像素（pixel）上，决定了每个像素的颜色（例如，黑色或白色）。&lt;/p>
&lt;h3 id="理解图表中的内容">理解图表中的内容
&lt;/h3>&lt;ol>
&lt;li>像素 (pixel): 从 1 到 16 的编号表示每个像素的位置。&lt;/li>
&lt;li>比特 (bit): 每个像素位置对应一个比特，从 7 到 0 代表一个字节中的每一位。&lt;/li>
&lt;li>存储的数据: 存储在比特中的数据值（0 或 1）。&lt;/li>
&lt;li>对应的颜色: 由数据值决定的像素颜色（黑色或白色）。
5。 字节 (byte): 0x00 和 0xff 表示字节的十六进制值。&lt;/li>
&lt;/ol>
&lt;h3 id="字节和比特的对应关系">字节和比特的对应关系
&lt;/h3>&lt;ul>
&lt;li>一个字节有 8 位，每一位可以是 0 或 1。&lt;/li>
&lt;li>0x00 表示 8 个比特全部为 0，转换为二进制是 00000000。&lt;/li>
&lt;li>0xff 表示 8 个比特全部为 1，转换为二进制是 11111111。&lt;/li>
&lt;/ul>
&lt;h3 id="解释示例">解释示例
&lt;/h3>&lt;ul>
&lt;li>0x00 字节:
&lt;ul>
&lt;li>二进制表示：00000000&lt;/li>
&lt;li>每个比特位都是 0，因此对应的像素颜色是黑色。&lt;/li>
&lt;li>从像素 1 到 8 的存储数据都是 0，所以对应颜色都是黑色。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>0xff 字节:
&lt;ul>
&lt;li>二进制表示：11111111&lt;/li>
&lt;li>每个比特位都是 1，因此对应的像素颜色是白色。&lt;/li>
&lt;li>从像素 9 到 16 的存储数据都是 1，所以对应颜色都是白色。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="示例代码解释">示例代码解释
&lt;/h3>&lt;p>如果你想用代码来解释字节和比特之间的关系，可以如下示例：&lt;/p>
&lt;pre>&lt;code class="language-python"># 示例字节
byte_00 = 0x00 # 所有比特位都是 0
byte_ff = 0xff # 所有比特位都是 1
# 打印二进制表示
print(f&amp;quot;0x00 的二进制表示: {bin(byte_00)[2:].zfill(8)}&amp;quot;)
print(f&amp;quot;0xff 的二进制表示: {bin(byte_ff)[2:].zfill(8)}&amp;quot;)
# 转换为像素颜色
pixels_00 = [&amp;quot;■&amp;quot; if bit == '0' else &amp;quot;□&amp;quot; for bit in bin(byte_00)[2:].zfill(8)]
pixels_ff = [&amp;quot;■&amp;quot; if bit == '0' else &amp;quot;□&amp;quot; for bit in bin(byte_ff)[2:].zfill(8)]
print(f&amp;quot;0x00 对应的像素颜色: {''.join(pixels_00)}&amp;quot;)
print(f&amp;quot;0xff 对应的像素颜色: {''.join(pixels_ff)}&amp;quot;)
&lt;/code>&lt;/pre>
&lt;h3 id="输出">输出
&lt;/h3>&lt;pre>&lt;code class="language-plaintext">复制代码
0x00 的二进制表示: 00000000
0xff 的二进制表示: 11111111
0x00 对应的像素颜色: ■■■■■■■■
0xff 对应的像素颜色: □□□□□□□□
&lt;/code>&lt;/pre>
&lt;p>在这里，■ 表示黑色像素，□ 表示白色像素。这个代码示例展示了如何根据字节中的比特值确定像素颜色。&lt;/p>
&lt;!-- more -->
&lt;p>天呐！有理有据条例清晰，秒懂了，原来byte是十六进制要转为二进制的！而8位二进制就可以表示8个数码管的开与关了！&lt;/p>
&lt;h2 id="数字显示与byte的对应">数字显示与byte的对应
&lt;/h2>&lt;p>&lt;img src="https://winotmk.github.io/images/20240724190425.png"
loading="lazy"
>&lt;/p>
&lt;p>*&lt;strong>GPT回答：&lt;/strong>
为了将数字 23.8 和 54.9 表示为 DSPNUM_1in9_off 数组中的十六进制值，我们需要将每一位数字对应的十六进制编码放入数组的正确位置。根据你提供的映射：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>0 ：0xbf, 0x1f&lt;/p>
&lt;/li>
&lt;li>
&lt;p>1 ：0x00, 0x1f&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2 ：0xfd, 0x17&lt;/p>
&lt;/li>
&lt;li>
&lt;p>3 ：0xf5, 0x1f&lt;/p>
&lt;/li>
&lt;li>
&lt;p>4 ：0x47, 0x1f&lt;/p>
&lt;/li>
&lt;li>
&lt;p>5 ：0xf7, 0x1d&lt;/p>
&lt;/li>
&lt;li>
&lt;p>6 ：0xff, 0x1d&lt;/p>
&lt;/li>
&lt;li>
&lt;p>7 ：0x21, 0x1f&lt;/p>
&lt;/li>
&lt;li>
&lt;p>8 ：0xff, 0x1f
-9 ：0xf7, 0x1f
根据你的要求：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数字 A 为 23.8&lt;/p>
&lt;ul>
&lt;li>十位 2 对应 DSPNUM_1in9_off[1] 和 DSPNUM_1in9_off[2]&lt;/li>
&lt;li>个位 3 对应 DSPNUM_1in9_off[3] 和 DSPNUM_1in9_off[4]&lt;/li>
&lt;li>小数点后一位 8 对应 DSPNUM_1in9_off[11] 和 DSPNUM_1in9_off[12]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>数字 B 为 54.9&lt;/p>
&lt;ul>
&lt;li>十位 5 对应 DSPNUM_1in9_off[5] 和 DSPNUM_1in9_off[6]&lt;/li>
&lt;li>个位 4 对应 DSPNUM_1in9_off[7] 和 DSPNUM_1in9_off[8]&lt;/li>
&lt;li>小数点后一位 9 对应 DSPNUM_1in9_off[9] 和 DSPNUM_1in9_off[10]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="替换数组">替换数组
&lt;/h3>&lt;p>将这些值替换到数组 DSPNUM_1in9_off 中：&lt;/p>
&lt;pre>&lt;code class="language-c">unsigned char DSPNUM_1in9_off[] = {
0x00, // [0] 保持为 0x00
0xfd, // [1] 数字 A 的十位 2 对应
0x17, // [2] 数字 A 的十位 2 对应
0xf5, // [3] 数字 A 的个位 3 对应
0x1f, // [4] 数字 A 的个位 3 对应
0xf7, // [5] 数字 B 的十位 5 对应
0x1d, // [6] 数字 B 的十位 5 对应
0x47, // [7] 数字 B 的个位 4 对应
0x1f, // [8] 数字 B 的个位 4 对应
0xf7, // [9] 数字 B 的小数点后一位 9 对应
0x1f, // [10] 数字 B 的小数点后一位 9 对应
0xff, // [11] 数字 A 的小数点后一位 8 对应
0x1f, // [12] 数字 A 的小数点后一位 8 对应
0x00, // [13] 保持为 0x00
0x00, // [14] 保持为 0x00
0x00 // [15] 保持为 0x00
};
&lt;/code>&lt;/pre>
&lt;h3 id="最终数组">最终数组
&lt;/h3>&lt;pre>&lt;code class="language-c">unsigned char DSPNUM_1in9_off[] = {
0x00, 0xfd, 0x17, 0xf5, 0x1f, 0xf7, 0x1d, 0x47, 0x1f, 0xf7, 0x1f, 0xff, 0x1f, 0x00, 0x00, 0x00
};
&lt;/code>&lt;/pre>
&lt;p>这个数组 DSPNUM_1in9_off 现在包含了你要求的数字 A 和 B 的十六进制表示形式。&lt;/p>
&lt;p>GPT准确无误的理解了我的意思，这是这段代码直接得到的结果！！：
&lt;img src="https://winotmk.github.io/images/20240726134530.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="动态将数字转换为对应的段码">动态将数字转换为对应的段码
&lt;/h2>&lt;p>上面一段只是实现了数字到段码的转换，作为一个温度计肯定需要每隔一段时间就将读取的温度传到这个数组里，所以我继续问
&lt;img src="https://winotmk.github.io/images/20240726134819.png"
loading="lazy"
>
GPT又准确无误的给了我方案：&lt;/p>
&lt;h3 id="动态调整数组的代码">动态调整数组的代码
&lt;/h3>&lt;p>为了动态调整 DSPNUM_1in9_off 数组，你可以编写一个函数，根据给定的 A 和 B 数值，动态设置数组的值。这个函数可以使用一个查找表来将数字映射到相应的字节值。&lt;/p>
&lt;p>以下是一个实现示例：&lt;/p>
&lt;pre>&lt;code class="language-c">#include &amp;lt;stdio.h&amp;gt;
// 定义数字对应的字节数组
unsigned char digit_bytes[10][2] = {
{0xbf, 0x1f}, // 0
{0x00, 0x1f}, // 1
{0xfd, 0x17}, // 2
{0xf5, 0x1f}, // 3
{0x47, 0x1f}, // 4
{0xf7, 0x1d}, // 5
{0xff, 0x1d}, // 6
{0x21, 0x1f}, // 7
{0xff, 0x1f}, // 8
{0xf7, 0x1f} // 9
};
// 定义DSPNUM_1in9_off数组
unsigned char DSPNUM_1in9_off[16] = {0};
// 更新数组的函数
void update_display(double A, double B) {
// 提取 A 和 B 的各位数字
int A_tens = (int)(A / 10) % 10;
int A_units = (int)A % 10;
int A_decimal = (int)(A * 10) % 10;
int B_tens = (int)(B / 10) % 10;
int B_units = (int)B % 10;
int B_decimal = (int)(B * 10) % 10;
// 设置数字 A
DSPNUM_1in9_off[1] = digit_bytes[A_tens][0];
DSPNUM_1in9_off[2] = digit_bytes[A_tens][1];
DSPNUM_1in9_off[3] = digit_bytes[A_units][0];
DSPNUM_1in9_off[4] = digit_bytes[A_units][1];
DSPNUM_1in9_off[11] = digit_bytes[A_decimal][0];
DSPNUM_1in9_off[12] = digit_bytes[A_decimal][1];
// 设置数字 B
DSPNUM_1in9_off[5] = digit_bytes[B_tens][0];
DSPNUM_1in9_off[6] = digit_bytes[B_tens][1];
DSPNUM_1in9_off[7] = digit_bytes[B_units][0];
DSPNUM_1in9_off[8] = digit_bytes[B_units][1];
DSPNUM_1in9_off[9] = digit_bytes[B_decimal][0];
DSPNUM_1in9_off[10] = digit_bytes[B_decimal][1];
}
int main() {
double A = 23.8;
double B = 54.9;
// 更新显示
update_display(A, B);
// 打印数组内容以验证
for (int i = 0; i &amp;lt; 16; i++) {
printf(&amp;quot;0x%02x &amp;quot;, DSPNUM_1in9_off[i]);
}
printf(&amp;quot;\n&amp;quot;);
return 0;
}
&lt;/code>&lt;/pre>
&lt;h3 id="解释">解释
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>数字到字节的映射表：&lt;/p>
&lt;ul>
&lt;li>digit_bytes 数组包含了每个数字（0 到 9）对应的两个字节的值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>提取数字位：&lt;/p>
&lt;ul>
&lt;li>使用整数除法和取模运算提取 A 和 B 的十位、个位和小数点后一位。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>更新显示数组：&lt;/p>
&lt;ul>
&lt;li>使用提取到的数字位将 DSPNUM_1in9_off 数组的相应位置更新为查找表中的字节值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>主函数：&lt;/p>
&lt;ul>
&lt;li>定义 A 和 B 的值，调用 update_display 函数更新显示数组，并打印数组内容以验证。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>这样，DSPNUM_1in9_off 数组将根据传入的 A 和 B 值动态更新。&lt;/p>
&lt;h2 id="小数点的处理">小数点的处理
&lt;/h2>&lt;p>上面已经完整实现了两个数字到数组内的转换，但是转出来没有小数点，根据文档：&lt;/p>
&lt;blockquote>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240726135629.png"
loading="lazy"
>&lt;/p>&lt;/blockquote>
&lt;p>所以要在数组的第4，8，10位做些处理&lt;/p>
&lt;p>我继续对GPT说&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240726135810.png"
loading="lazy"
>&lt;/p>
&lt;p>GPT回答：&lt;/p>
&lt;p>为了实现这个功能，我们需要将特定数组位置的十六进制数转换为二进制，修改二进制数中的特定位，然后将其转换回十六进制并存储在数组中。&lt;/p>
&lt;p>以下是修改后的代码，包括处理 DSPNUM_1in9_off[4], DSPNUM_1in9_off[8] 和 DSPNUM_1in9_off[10]：&lt;/p>
&lt;pre>&lt;code class="language-c">#include &amp;lt;stdio.h&amp;gt;
// 定义数字对应的字节数组
unsigned char digit_bytes[10][2] = {
{0xbf, 0x1f}, // 0
{0x00, 0x1f}, // 1
{0xfd, 0x17}, // 2
{0xf5, 0x1f}, // 3
{0x47, 0x1f}, // 4
{0xf7, 0x1d}, // 5
{0xff, 0x1d}, // 6
{0x21, 0x1f}, // 7
{0xff, 0x1f}, // 8
{0xf7, 0x1f} // 9
};
// 定义DSPNUM_1in9_off数组
unsigned char DSPNUM_1in9_off[16] = {0};
// 将第六位从右往左数改成1的函数
unsigned char set_sixth_bit_to_one(unsigned char value) {
return value | (1 &amp;lt;&amp;lt; 5); // 第六位对应的二进制位是 5，从0开始计数
}
// 更新数组的函数
void update_display(double A, double B) {
// 提取 A 和 B 的各位数字
int A_tens = (int)(A / 10) % 10;
int A_units = (int)A % 10;
int A_decimal = (int)(A * 10) % 10;
int B_tens = (int)(B / 10) % 10;
int B_units = (int)B % 10;
int B_decimal = (int)(B * 10) % 10;
// 设置数字 A
DSPNUM_1in9_off[1] = digit_bytes[A_tens][0];
DSPNUM_1in9_off[2] = digit_bytes[A_tens][1];
DSPNUM_1in9_off[3] = digit_bytes[A_units][0];
DSPNUM_1in9_off[4] = set_sixth_bit_to_one(digit_bytes[A_units][1]); // 修改第六位
DSPNUM_1in9_off[11] = digit_bytes[A_decimal][0];
DSPNUM_1in9_off[12] = digit_bytes[A_decimal][1];
// 设置数字 B
DSPNUM_1in9_off[5] = digit_bytes[B_tens][0];
DSPNUM_1in9_off[6] = digit_bytes[B_tens][1];
DSPNUM_1in9_off[7] = digit_bytes[B_units][0];
DSPNUM_1in9_off[8] = set_sixth_bit_to_one(digit_bytes[B_units][1]); // 修改第六位
DSPNUM_1in9_off[9] = digit_bytes[B_decimal][0];
DSPNUM_1in9_off[10] = set_sixth_bit_to_one(digit_bytes[B_decimal][1]); // 修改第六位
}
int main() {
double A = 23.8;
double B = 54.9;
// 更新显示
update_display(A, B);
// 打印数组内容以验证
for (int i = 0; i &amp;lt; 16; i++) {
printf(&amp;quot;0x%02x &amp;quot;, DSPNUM_1in9_off[i]);
}
printf(&amp;quot;\n&amp;quot;);
return 0;
}
&lt;/code>&lt;/pre>
&lt;h3 id="解释-1">解释
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>函数 set_sixth_bit_to_one:&lt;/p>
&lt;ul>
&lt;li>使用位运算将一个字节的第六位（从右数）设置为 1。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>更新 DSPNUM_1in9_off 数组:&lt;/p>
&lt;ul>
&lt;li>按照你的要求更新数字 A 和 B 的各个位数字。&lt;/li>
&lt;li>在设置 DSPNUM_1in9_off[4], DSPNUM_1in9_off[8] 和 DSPNUM_1in9_off[10] 时，调用 set_sixth_bit_to_one 函数将其第六位设置为 1。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="结果">结果
&lt;/h3>&lt;p>运行代码后，DSPNUM_1in9_off 数组将根据 A 和 B 的值动态更新，并且 DSPNUM_1in9_off[4], DSPNUM_1in9_off[8] 和 DSPNUM_1in9_off[10] 的第六位将被设置为 1。&lt;/p>
&lt;p>然后我就得到了：
&lt;img src="https://winotmk.github.io/images/20240726142601.png"
loading="lazy"
>
这里数字是我手动指定的&lt;code>A=73.6&lt;/code>,&lt;code>B=84.9&lt;/code>，可以看到小数点，百分号都已经显示出来了&lt;/p>
&lt;p>再接入传感器读到的数值，温度计就差不多完工啦：
&lt;img src="https://winotmk.github.io/images/20240726142737.png"
loading="lazy"
>&lt;/p>
&lt;p>顺便一提这里的传感器驱动代码也是GPT帮调整的，真是神奇&lt;/p></description></item><item><title>用容器来运行streamlit</title><link>https://winotmk.github.io/posts/240724_%E7%94%A8%E5%AE%B9%E5%99%A8%E6%9D%A5%E8%BF%90%E8%A1%8Cstreamlit/</link><pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/240724_%E7%94%A8%E5%AE%B9%E5%99%A8%E6%9D%A5%E8%BF%90%E8%A1%8Cstreamlit/</guid><description>&lt;p>&lt;img src="https://winotmk.github.io/images/20240724152543.png"
loading="lazy"
>
一开始玩这个的时候就在想用docker跑，因为实在不想在本机里搭各种乱七八糟的环境，也懒得用Anaconda那样的中间环境，总感觉本地跑个模型才用得上那种大玩意儿，于是在dockerhub上找了找
一些已有的可用镜像：
&lt;a class="link" href="https://hub.docker.com/r/aminehy/docker-streamlit-app" target="_blank" rel="noopener"
>https://hub.docker.com/r/aminehy/docker-streamlit-app&lt;/a>
&lt;a class="link" href="https://hub.docker.com/r/samdobson/streamlit" target="_blank" rel="noopener"
>https://hub.docker.com/r/samdobson/streamlit&lt;/a>
就是镜像build都好几年前了，实测目前有些新的例程都跑不了，还是自己做个镜像吧&lt;/p>
&lt;h2 id="制作dockerfile">制作dockerfile
&lt;/h2>&lt;p>&lt;a class="link" href="https://docs.streamlit.io/deploy/tutorials/docker" target="_blank" rel="noopener"
>https://docs.streamlit.io/deploy/tutorials/docker&lt;/a>
好在官网已给出方案
这是我微改后的：&lt;/p>
&lt;pre>&lt;code># app/Dockerfile
FROM python:3.9-slim
WORKDIR /app
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y \
build-essential \
curl \
software-properties-common \
git \
&amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*
RUN git clone https://github.com/streamlit/streamlit-example.git .
RUN pip3 install -r requirements.txt
EXPOSE 8501
HEALTHCHECK CMD curl --fail http://localhost:8501/_stcore/health
CMD [&amp;quot;streamlit&amp;quot;, &amp;quot;run&amp;quot;, &amp;quot;main.py&amp;quot;, &amp;quot;--server.port=8501&amp;quot;, &amp;quot;--server.address=0.0.0.0&amp;quot;]
&lt;/code>&lt;/pre>
&lt;!-- more -->
&lt;p>主要就最后一行并没有用&lt;code>ENTRYPOINT&lt;/code>，因为记得这个不是必须，用&lt;code>CMD&lt;/code>的好处是非常方便的就能修改&lt;code>docker run&lt;/code>时要运行的内容&lt;/p>
&lt;h2 id="构建和使用镜像">构建和使用镜像
&lt;/h2>&lt;p>打开CMD，CD到这个Dockerfile保存的目录下
&lt;code>docker build -t streamlit_winotmk:latest . &lt;/code>点不要落下&lt;/p>
&lt;p>然后就可用来运行任意py的app文件了
&lt;code>docker run -ti --rm -p 8501:8501 -v $(pwd):/app streamlit_winotmk:latest streamlit run name_main_file.py&lt;/code>
&lt;code>$(pwd)&lt;/code>换成宿主机的目录，记得暴露8501的默认端口
我这里目录是&lt;code>C:\Cloud\docker\streamlit\demo3\examples&lt;/code>
所以直接:
&lt;code>docker run -ti --rm -p 8501:8501 -v C:\Cloud\docker\streamlit\demo3\examples:/app streamlit_winotmk:latest streamlit run intro.py&lt;/code>
保持运行并想下次继续用可以
&lt;code>docker run -ti -d -p 8501:8501 -v $(pwd):/app --name MystreamlitAPP streamlit_winotmk:latest&lt;/code>
*用容器跑起来的一些例程APP：
&lt;img src="https://winotmk.github.io/images/20240724152253.png"
loading="lazy"
>
&lt;img src="https://winotmk.github.io/images/20240724152303.png"
loading="lazy"
>&lt;/p></description></item><item><title>Linux和docker常用命令</title><link>https://winotmk.github.io/posts/240619_linux%E5%91%BD%E4%BB%A4/</link><pubDate>Wed, 19 Jun 2024 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/240619_linux%E5%91%BD%E4%BB%A4/</guid><description>&lt;p>还是会有很多不常用的命令要来回查，仅记录，绝非完整命令参考&lt;/p>
&lt;h2 id="文件操作相关">文件操作相关
&lt;/h2>&lt;h3 id="复制目录">复制目录
&lt;/h3>&lt;p>复制目录dir1和dir1目录下的文件到dir2目录里&lt;/p>
&lt;pre>&lt;code>cp -r dir1 dir2
&lt;/code>&lt;/pre>
&lt;p>安装lrzsz实现zmodem串口文件传输&lt;/p>
&lt;pre>&lt;code>rz 下载Zmodem
xz 上传Zmodem
&lt;/code>&lt;/pre>
&lt;p>windterm下支持直接拖拽文件，但是也要安装lrzsz以支持命令
&lt;a class="link" href="https://www.cnblogs.com/lidabo/p/4780866.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/lidabo/p/4780866.html&lt;/a>&lt;/p>
&lt;h3 id="挂载u盘">挂载U盘
&lt;/h3>&lt;pre>&lt;code>fdisk -l
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240619152526.png"
loading="lazy"
>
可以看到一块14.84GB的SD卡，位置在&lt;code>/dev/sda1&lt;/code>
使用&lt;/p>
&lt;pre>&lt;code>mount -t vfat /dev/sda1 /mnt
&lt;/code>&lt;/pre>
&lt;p>来挂载U盘
&lt;img src="https://winotmk.github.io/images/20240619152710.png"
loading="lazy"
>
&lt;code>cd&lt;/code>到&lt;code>/mnt&lt;/code>即可看到U盘里的文件了，另外可以在&lt;code>/mnt&lt;/code>里新建文件夹&lt;code>mkdir xxxxx&lt;/code>，再挂载到文件夹里&lt;/p>
&lt;p>卸载：&lt;/p>
&lt;pre>&lt;code>umount /mnt
&lt;/code>&lt;/pre>
&lt;h3 id="打包压缩和解压">打包压缩和解压
&lt;/h3>&lt;p>压缩&lt;/p>
&lt;pre>&lt;code>tar -czvf ***.tar.gz
&lt;/code>&lt;/pre>
&lt;p>解压&lt;/p>
&lt;pre>&lt;code>tar -xzvf ***.tar.gz
&lt;/code>&lt;/pre>
&lt;h3 id="docker">docker
&lt;/h3>&lt;p>&lt;a class="link" href="https://yeasy.gitbook.io/docker_practice/container/run" target="_blank" rel="noopener"
>https://yeasy.gitbook.io/docker_practice/container/run&lt;/a>&lt;/p>
&lt;p>启动docker:&lt;/p>
&lt;pre>&lt;code>sudo systemctl start docker
&lt;/code>&lt;/pre>
&lt;p>查看已有镜像：&lt;/p>
&lt;pre>&lt;code>docker ps -a
&lt;/code>&lt;/pre>
&lt;p>启动已终止容器:&lt;/p>
&lt;pre>&lt;code>docker container start
&lt;/code>&lt;/pre>
&lt;p>运行新的镜像run：&lt;/p>
&lt;pre>&lt;code>docker run -it -d --name hexo_debian -p 22:22 -p 4000:4000 -v XXX:/hexo/ hexo_debian:V02
&lt;/code>&lt;/pre>
&lt;p>save:
把本地镜像打包成tar方便带走&lt;/p>
&lt;pre>&lt;code>docker save -o jre8u342_ch.tar jre8u342_ch:latest
&lt;/code>&lt;/pre>
&lt;p>打包好的tar用的时候可以：&lt;/p>
&lt;pre>&lt;code>docker load -i {image_name}.tar
docker load --input {image_name}.tar
&lt;/code>&lt;/pre>
&lt;p>如果没有tag可以手动打tag~&lt;/p>
&lt;pre>&lt;code>docker tag {image_id} {image_name}:{image_tag}
&lt;/code>&lt;/pre>
&lt;p>自用的docker run:&lt;/p>
&lt;pre>&lt;code>docker run -d --name=calibre-web -e PUID=1000 -e PGID=1000 -e TZ=Etc/UTC -e DOCKER_MODS=linuxserver/mods:universal-calibre -p 8083:8083 -v D:\calibre_test\config:/config -v D:\calibre_test\library:/books --restart unless-stopped lscr.io/linuxserver/calibre-web:latest
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>docker run -d --name=calibre -e PUID=1000 -e PGID=1000 -e TZ=Asia/Shanghai -e LC_ALL=zh_CN.UTF-8 -p 8080:8080 -p 8181:8181 -p 8081:8081 -v D:\calibre_test\library:/library -v D:\calibre_test\config:/config --restart unless-stopped lscr.io/linuxserver/calibre:latest
&lt;/code>&lt;/pre>
&lt;!-- more -->
&lt;h4 id="docker-compose">docker compose
&lt;/h4>&lt;p>启动组
&lt;code>docker compose -f hexo_debian_DockerCompose.yml up -d &lt;/code>
关闭组
&lt;code>docker compose -f hexo_debian_DockerCompose.yml down -v&lt;/code>
启动但是会留在容器里
&lt;code>docker compose up&lt;/code>
启动不留在容器里
&lt;code>docker compose up -d&lt;/code>
进入docker容器&lt;/p>
&lt;pre>&lt;code>docker exec -it XXX /bin/bash
&lt;/code>&lt;/pre>
&lt;p>退出容器但保留按&lt;code>ctrl+P+Q&lt;/code>
也可以直接接要在容器里执行的命令&lt;/p>
&lt;pre>&lt;code>docker exec hexo hexo g -d
&lt;/code>&lt;/pre>
&lt;p>拷贝容器内的文件出来，在宿主机上输入：&lt;/p>
&lt;pre>&lt;code>docker cp -a vsftpd:/etc/services /root/
&lt;/code>&lt;/pre>
&lt;h3 id="screen">screen
&lt;/h3>&lt;pre>&lt;code># 创建一个新的窗口
screen -S test
# 进入窗口后 执行文件
python test.py
# 退出当前窗口
ctrl+a+d （方法1：保留当前窗口）
screen -d （方法2：保留当前窗口）
exit （方法3：退出程序，并关闭窗口）
# 查看窗口
screen -ls
# 重新连接窗口
screen -r id或窗口名称
&lt;/code>&lt;/pre></description></item><item><title>软件和网站收集</title><link>https://winotmk.github.io/posts/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/</link><pubDate>Wed, 19 Jun 2024 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/</guid><description>&lt;p>&lt;img src="https://winotmk.github.io/images/20240619114459.png"
loading="lazy"
>
收集一些看到的好玩的可能以后会用到的软件/服务，软件类大多可以docker部署
不定期更新
24.8.6更新&lt;/p>
&lt;h2 id="a网站推荐">A.网站推荐
&lt;/h2>&lt;h3 id="开源大世界">开源大世界
&lt;/h3>&lt;blockquote>
&lt;p>开源大世界 专注于应用级的开源软件、开源资料的情报收集汇总整理。
&lt;a class="link" href="https://kydsj.vip/doku.php?id=wiki:%E7%BD%91%E7%AB%99%E7%9B%AE%E5%BD%95#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%85%E5%8A%A9%E8%AE%BE%E8%AE%A1&amp;#43;" target="_blank" rel="noopener"
>https://kydsj.vip/doku.php?id=wiki:网站目录#计算机辅助设计+&lt;/a>
&lt;a class="link" href="https://kydsj.vip/doku.php?id=wiki:%E8%87%AA%E6%89%98%E7%AE%A1-%E7%94%B5%E5%AD%90%E4%B9%A6%E5%92%8C%E7%BB%BC%E5%90%88%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener"
>https://kydsj.vip/doku.php?id=wiki:自托管-电子书和综合图书馆系统&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>很多开源软件项目分享，分类详细品种丰富
&lt;img src="https://winotmk.github.io/images/20240619113833.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="linuxserverio">linuxserver.io
&lt;/h3>&lt;blockquote>
&lt;p>LinuxServer.io 文档之家！我们的目标是确保所有镜像都正确记录所有相关信息，以帮助我们的用户入门。除了每个镜像的单独设置指南外，还有与运行 Docker 容器有关的一般信息和最佳实践
&lt;a class="link" href="https://docs.linuxserver.io/images/docker-calibre-web/" target="_blank" rel="noopener"
>https://docs.linuxserver.io/images/docker-calibre-web/&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240619114936.png"
loading="lazy"
>&lt;/p>
&lt;!-- more -->
&lt;h3 id="webpagetestorg">webpagetest.org
&lt;/h3>&lt;blockquote>
&lt;p>&lt;a class="link" href="https://www.webpagetest.org" target="_blank" rel="noopener"
>www.webpagetest.org&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>感觉是很强的网站性能分析工具
&lt;img src="https://winotmk.github.io/images/20240806152808.png"
loading="lazy"
>
&lt;img src="https://winotmk.github.io/images/20240806152822.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="又拍云">又拍云
&lt;/h3>&lt;p>&lt;a class="link" href="https://www.upyun.com/" target="_blank" rel="noopener"
>https://www.upyun.com/&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240806153828.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="autodl">autodl
&lt;/h3>&lt;p>&lt;a class="link" href="https://www.autodl.com/market/list" target="_blank" rel="noopener"
>https://www.autodl.com/market/list&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240806153956.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="b影音文件资料整理">B.影音/文件/资料整理
&lt;/h2>&lt;h3 id="emby">emby
&lt;/h3>&lt;p>&lt;img src="https://winotmk.github.io/images/20240619112801.png"
loading="lazy"
>&lt;/p>
&lt;blockquote>
&lt;p>任何设备上的个人媒体
将您家里的所有视频、音乐和照片集中到一处从未如此简单。您的个人 Emby 服务器会自动即时转换和流式传输您的媒体，以便在任何设备上播放
&lt;a class="link" href="https://github.com/MediaBrowser/Emby?tab=readme-ov-file" target="_blank" rel="noopener"
>https://github.com/MediaBrowser/Emby?tab=readme-ov-file&lt;/a>
&lt;a class="link" href="https://emby.media/" target="_blank" rel="noopener"
>https://emby.media/&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240619112854.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="jellyfin">jellyfin
&lt;/h3>&lt;p>&lt;img src="https://winotmk.github.io/images/20240619113420.png"
loading="lazy"
>&lt;/p>
&lt;blockquote>
&lt;p>jellyfin是一套多媒体应用程序软件套装，旨在组织、管理和共享数字媒体文件
&lt;a class="link" href="https://github.com/jellyfin/jellyfin" target="_blank" rel="noopener"
>https://github.com/jellyfin/jellyfin&lt;/a>
&lt;a class="link" href="https://jellyfin.org/" target="_blank" rel="noopener"
>https://jellyfin.org/&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240619113518.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="calibre">calibre
&lt;/h3>&lt;blockquote>
&lt;p>Calibre-Web 是一款网络应用程序，它使用有效的Calibre数据库提供简洁直观的界面来浏览、阅读和下载电子书
&lt;a class="link" href="https://github.com/janeczku/calibre-web" target="_blank" rel="noopener"
>https://github.com/janeczku/calibre-web&lt;/a>
&lt;a class="link" href="https://calibre-ebook.com/" target="_blank" rel="noopener"
>https://calibre-ebook.com/&lt;/a>
目前自用的docker镜像：
&lt;a class="link" href="https://hub.docker.com/r/johngong/calibre-web" target="_blank" rel="noopener"
>https://hub.docker.com/r/johngong/calibre-web&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240619115310.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="nextcloud">Nextcloud
&lt;/h3>&lt;p>&lt;img src="https://winotmk.github.io/images/20240619113143.png"
loading="lazy"
>&lt;/p>
&lt;blockquote>
&lt;p>Nextcloud是一套用于建立网络硬盘的客户端－服务器软件。其功能与Dropbox相近，但Nextcloud是自由及开放源代码软件，每个人都可以在私人服务器上安装并执行它。
与Dropbox等专有服务相比，Nextcloud的开放架构让用户可以利用应用程序的方式在服务器上新增额外的功能，并让用户可以完全掌控自己的资料。
&lt;a class="link" href="https://github.com/nextcloud" target="_blank" rel="noopener"
>https://github.com/nextcloud&lt;/a>
&lt;a class="link" href="https://nextcloud.com/" target="_blank" rel="noopener"
>https://nextcloud.com/&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240619113206.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="found">Found
&lt;/h3>&lt;p>&lt;img src="https://winotmk.github.io/images/20240719123503.png"
loading="lazy"
>&lt;/p>
&lt;blockquote>
&lt;p>高效设计师必备的文件浏览器 Found，一键预览三维模型、序列帧、HDR
&lt;a class="link" href="https://www.aalab.com.cn/" target="_blank" rel="noopener"
>https://www.aalab.com.cn/&lt;/a>&lt;/p>&lt;/blockquote>
&lt;h2 id="c工具类">C.工具类
&lt;/h2>&lt;h3 id="matomo">matomo
&lt;/h3>&lt;p>&lt;img src="https://winotmk.github.io/images/20240619113019.png"
loading="lazy"
>&lt;/p>
&lt;blockquote>
&lt;p>Matomo 是领先的免费/自由开放分析平台。&lt;/p>
&lt;p>Matomo 是一款功能齐全的 PHP MySQL 软件程序，您可以下载并安装在自己的网络服务器上。在五分钟的安装过程结束时，您将获得一个 JavaScript 代码。只需将此标签复制并粘贴到您希望跟踪的网站上，即可实时访问您的分析报告。&lt;/p>
&lt;p>Matomo 旨在成为 Google Analytics 的免费软件替代品，目前已在 1,400,000 多个网站上使用。隐私功能已内置
&lt;a class="link" href="https://github.com/matomo-org/matomo" target="_blank" rel="noopener"
>https://github.com/matomo-org/matomo&lt;/a>
&lt;a class="link" href="https://matomo.org/" target="_blank" rel="noopener"
>https://matomo.org/&lt;/a>&lt;/p>&lt;/blockquote>
&lt;h3 id="upverter">Upverter
&lt;/h3>&lt;blockquote>
&lt;p>Upverter 是一个模块化的、基于网络的电子电路设计工具，可以完成所有工作——PCB 设计、原理图、自动布线、3D 预览和按照您的确切规格构建订单——用户不再需要为开源项目付费。
&lt;a class="link" href="https://upverter.com/" target="_blank" rel="noopener"
>https://upverter.com/&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240806153057.png"
loading="lazy"
>
&lt;img src="https://winotmk.github.io/images/20240806153111.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="manim">manim
&lt;/h3>&lt;p>&lt;img src="https://winotmk.github.io/images/20240814160651.png"
loading="lazy"
>
&lt;a class="link" href="https://www.manim.community/" target="_blank" rel="noopener"
>https://www.manim.community/&lt;/a>&lt;/p>
&lt;p>可以做出3B1B那样好看的数学动画（可以用来做视频的工具)
&lt;img src="https://winotmk.github.io/images/20240814160523.png"
loading="lazy"
>&lt;/p></description></item><item><title>地理数据采集器计划</title><link>https://winotmk.github.io/posts/240617_%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%99%A8%E8%AE%A1%E5%88%92/</link><pubDate>Mon, 17 Jun 2024 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/240617_%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%99%A8%E8%AE%A1%E5%88%92/</guid><description>&lt;h2 id="简介">简介
&lt;/h2>&lt;p>想要做一个便携的小设备，能够实现以下功能&lt;/p>
&lt;ul>
&lt;li>记录当前地点的气压，温度，湿度等地理信息&lt;/li>
&lt;li>记录GPS坐标信息&lt;/li>
&lt;li>考虑加上摄像头记录当前周围视觉环境，同时可以将上述信息水印（字幕)在照片上&lt;/li>
&lt;li>存储所有记录的数据以便之后进行可视化数据生成，可以用类似XML，Json，或者找有没有嵌入式轻量数据库实现&lt;/li>
&lt;/ul>
&lt;p>它最好有以下这样的特点：&lt;/p>
&lt;ul>
&lt;li>手机一般大小可以塞进口袋&lt;/li>
&lt;li>一定程度的防摔防水外壳&lt;/li>
&lt;li>续航可以接受2-3天一充电&lt;/li>
&lt;/ul>
&lt;p>所以我的打算用现有的能买到的小板子和单片机来做，预算不是大问题，大概1500-2000，（包含试错和学习成本）考虑过几种方向：&lt;/p>
&lt;ul>
&lt;li>ESP32&lt;/li>
&lt;li>树莓派PICO&lt;/li>
&lt;li>幸狐的板子和摄像头&lt;/li>
&lt;li>树莓派Zero
最后发现现在目前树莓派zero2w的价格只有一百出头了，可能比某些arduino的原版板子还便宜，值得一试，幸狐看起来也不错的样子，回头再研究&lt;/li>
&lt;/ul>
&lt;p>下面这是树莓派zero2w跑通串口通信时的样子&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240617150029.png"
loading="lazy"
>&lt;/p>
&lt;!-- more -->
&lt;p>这个网站不错：https://pinout.xyz/&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240618185812.png"
loading="lazy"
>&lt;/p>
&lt;p>可知右上这几个接口就可以实现TTL的UART连接了，我尝试ground是要接的&lt;/p>
&lt;h2 id="资料">资料
&lt;/h2>&lt;h3 id="ft232串口工具">FT232串口工具
&lt;/h3>&lt;p>&lt;a class="link" href="https://www.waveshare.net/wiki/FT232_USB_UART_Board" target="_blank" rel="noopener"
>https://www.waveshare.net/wiki/FT232_USB_UART_Board&lt;/a>
&lt;img src="https://winotmk.github.io/images/20240619160444.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="gps模块">GPS模块
&lt;/h3>&lt;p>&lt;a class="link" href="https://www.waveshare.net/wiki/LC76G_GPS_Module" target="_blank" rel="noopener"
>https://www.waveshare.net/wiki/LC76G_GPS_Module&lt;/a>
&lt;img src="https://winotmk.github.io/images/20240619160514.png"
loading="lazy"
>
在准备安装micropyGPS时
&lt;img src="https://winotmk.github.io/images/20240619160324.png"
loading="lazy"
>
提示&lt;code>No module namd setuptools&lt;/code>
怀疑需要执行
&lt;code>apt-get install python3-setuptools&lt;/code>
可惜目前没有网络环境，回家尝试了&lt;/p>
&lt;h3 id="raspberry-zero-2w">Raspberry Zero 2W
&lt;/h3>&lt;p>&lt;a class="link" href="https://www.waveshare.net/wiki/Raspberry_Pi_Zero_2_W" target="_blank" rel="noopener"
>https://www.waveshare.net/wiki/Raspberry_Pi_Zero_2_W&lt;/a>
&lt;img src="https://winotmk.github.io/images/20240619160629.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="ups-模块">UPS 模块
&lt;/h3>&lt;p>&lt;a class="link" href="https://www.waveshare.net/wiki/UPS_HAT_%28C%29" target="_blank" rel="noopener"
>https://www.waveshare.net/wiki/UPS_HAT_(C)&lt;/a>
&lt;img src="https://winotmk.github.io/images/20240619160718.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="环境传感器">环境传感器
&lt;/h3>&lt;p>&lt;a class="link" href="https://www.waveshare.net/shop/Environment-Sensor-HAT.htm" target="_blank" rel="noopener"
>https://www.waveshare.net/shop/Environment-Sensor-HAT.htm&lt;/a>
&lt;img src="https://winotmk.github.io/images/20240619160754.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="项目软件">项目/软件
&lt;/h2>&lt;h3 id="数据可视化相关">数据可视化相关
&lt;/h3>&lt;h4 id="很不错的开源教程data-science-for-beginners">很不错的开源教程Data-Science-For-Beginners
&lt;/h4>&lt;p>&lt;a class="link" href="https://microsoft.github.io/Data-Science-For-Beginners/#/" target="_blank" rel="noopener"
>https://microsoft.github.io/Data-Science-For-Beginners/#/&lt;/a>&lt;/p>
&lt;h4 id="matplotlib">Matplotlib
&lt;/h4>&lt;p>&lt;a class="link" href="https://matplotlib.org/stable/index.html" target="_blank" rel="noopener"
>https://matplotlib.org/stable/index.html&lt;/a>
Matplotlib是一个出色的库，可用于创建各种简单和复杂的图表
&lt;a class="link" href="https://microsoft.github.io/Data-Science-For-Beginners/#/3-Data-Visualization/09-visualization-quantities/README" target="_blank" rel="noopener"
>https://microsoft.github.io/Data-Science-For-Beginners/#/3-Data-Visualization/09-visualization-quantities/README&lt;/a>
&lt;img src="https://winotmk.github.io/images/20240717142402.png"
loading="lazy"
>&lt;/p>
&lt;h4 id="streamlit">Streamlit
&lt;/h4>&lt;p>&lt;a class="link" href="https://github.com/streamlit/streamlit" target="_blank" rel="noopener"
>https://github.com/streamlit/streamlit&lt;/a>
&lt;img src="https://winotmk.github.io/images/20240717143550.png"
loading="lazy"
>
更偏向于python库直接生成web，同时也有很多数据可视化的内容，更实用？便于展示&lt;/p>
&lt;h4 id="powerbi">powerbi
&lt;/h4>&lt;p>&lt;a class="link" href="https://www.microsoft.com/en-us/power-platform/products/power-bi" target="_blank" rel="noopener"
>https://www.microsoft.com/en-us/power-platform/products/power-bi&lt;/a>
似乎是微软的web数据可视化绘图&lt;/p>
&lt;h4 id="gpxsee">GPXSee
&lt;/h4>&lt;p>配合gps数据收集可以展示出来
&lt;a class="link" href="https://github.com/tumic0/GPXSee" target="_blank" rel="noopener"
>https://github.com/tumic0/GPXSee&lt;/a>
&lt;img src="https://winotmk.github.io/images/20240719120310.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="图形库">图形库
&lt;/h3>&lt;h4 id="lvgl">LVGL
&lt;/h4>&lt;p>&lt;a class="link" href="https://lvgl.100ask.net/master/get-started/index.html" target="_blank" rel="noopener"
>https://lvgl.100ask.net/master/get-started/index.html&lt;/a>
&lt;a class="link" href="https://github.com/lvgl/lvgl" target="_blank" rel="noopener"
>https://github.com/lvgl/lvgl&lt;/a>
&lt;img src="https://winotmk.github.io/images/20240719122911.png"
loading="lazy"
>&lt;/p>
&lt;h4 id="squareline-studio-ui---配合上面的lvgl用">SquareLine Studio UI - 配合上面的LVGL用
&lt;/h4>&lt;p>&lt;a class="link" href="https://squareline.io/" target="_blank" rel="noopener"
>https://squareline.io/&lt;/a>
&lt;a class="link" href="https://www.bilibili.com/video/BV1DX4y1v727/?vd_source=b7b7bdf106a064893c3c79e4a961f383" target="_blank" rel="noopener"
>https://www.bilibili.com/video/BV1DX4y1v727/?vd_source=b7b7bdf106a064893c3c79e4a961f383&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240719121330.png"
loading="lazy"
>&lt;/p>
&lt;h4 id="guiguider-同上类别但免费">guiguider 同上类别但免费
&lt;/h4>&lt;p>&lt;a class="link" href="https://www.bilibili.com/video/BV1yW421R7zK/?spm_id_from=333.788.recommend_more_video.7&amp;amp;vd_source=b7b7bdf106a064893c3c79e4a961f383" target="_blank" rel="noopener"
>https://www.bilibili.com/video/BV1yW421R7zK/?spm_id_from=333.788.recommend_more_video.7&amp;vd_source=b7b7bdf106a064893c3c79e4a961f383&lt;/a>
&lt;img src="https://winotmk.github.io/images/20240719122655.png"
loading="lazy"
>&lt;/p>
&lt;h4 id="figma">figma
&lt;/h4>&lt;p>UI前期设计软件
&lt;img src="https://winotmk.github.io/images/20240719121825.png"
loading="lazy"
>&lt;/p>
&lt;h4 id="ui-框架oled-ui-astra">UI 框架：oled-ui-astra
&lt;/h4>&lt;p>&lt;a class="link" href="https://github.com/AstraThreshold/oled-ui-astra" target="_blank" rel="noopener"
>https://github.com/AstraThreshold/oled-ui-astra&lt;/a>
&lt;a class="link" href="https://www.bilibili.com/video/BV1i4421D7nJ/?vd_source=b7b7bdf106a064893c3c79e4a961f383" target="_blank" rel="noopener"
>https://www.bilibili.com/video/BV1i4421D7nJ/?vd_source=b7b7bdf106a064893c3c79e4a961f383&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240719120151.png"
loading="lazy"
>&lt;/p></description></item><item><title>令人头疼的vsftpd,ftp端口修改设置配置</title><link>https://winotmk.github.io/posts/240617_%E4%BB%A4%E4%BA%BA%E5%A4%B4%E7%96%BC%E7%9A%84vsftpd/</link><pubDate>Mon, 17 Jun 2024 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/240617_%E4%BB%A4%E4%BA%BA%E5%A4%B4%E7%96%BC%E7%9A%84vsftpd/</guid><description>&lt;p>这么个小小的软件花费了不成正比的时间去弄他，十分令人头疼，简单记录几点重要的设置&lt;/p>
&lt;pre>&lt;code>vim /etc/vsftpd.conf
&lt;/code>&lt;/pre>
&lt;p>vsftpd 配置文件：
&lt;a class="link" href="https://gnu-linux.readthedocs.io/zh/latest/Chapter02/90_vsftpd.html" target="_blank" rel="noopener"
>https://gnu-linux.readthedocs.io/zh/latest/Chapter02/90_vsftpd.html&lt;/a>&lt;/p>
&lt;h2 id="修改ftp的端口">修改ftp的端口
&lt;/h2>&lt;p>ftp的监听和实际数据传输是两个端口，如果要改最好都改&lt;/p>
&lt;pre>&lt;code>connect_from_port_20=NO
ftp_data_port=12520
listen_port=12521
&lt;/code>&lt;/pre>
&lt;p>pasv模式时的端口范围设置，假如用docker运行这些端口都要转出来&lt;/p>
&lt;pre>&lt;code>pasv_promiscuous=YES
pasv_min_port=31100
pasv_max_port=31110
&lt;/code>&lt;/pre>
&lt;p>我至今没太搞明白ftp的主动与被动模式的区别，以及能不能只用其中一种模式来工作..&lt;/p>
&lt;p>另外还有系统的services里&lt;/p>
&lt;pre>&lt;code>vim /etc/services
#ftp-data 20/tcp
#ftp-data 20/udp
ftp-data 12520/tcp
ftp-data 12520/udp
&lt;/code>&lt;/pre>
&lt;p>这个不确定是否必要但还是改了吧&lt;/p>
&lt;h2 id="中文乱码">中文乱码
&lt;/h2>&lt;p>&lt;img src="https://winotmk.github.io/images/20240617155755.png"
loading="lazy"
>&lt;/p>
&lt;p>一篇不错的配置说明
&lt;a class="link" href="https://blog.starryvoid.com/archives/1044.html" target="_blank" rel="noopener"
>https://blog.starryvoid.com/archives/1044.html&lt;/a>
主要提到了utf8的编码问题&lt;/p>
&lt;p>&lt;code>utf8_filesystem=YES&lt;/code>&lt;/p>
&lt;p>如果这样还没解决，考虑是要修改容器本身的&lt;code>LANG&lt;/code>
可以直接进入容器然后类似：
export LANG=C.UTF-8
或者
export LANG=en_US.UTF-8
输入locale查看结果
当然这样关了这个sh就没了，所以可以直接加到docker启动时的环境变量里
&lt;a class="link" href="https://zihengcat.github.io/2018/09/10/change-locale-system-encoding-in-docker-container/" target="_blank" rel="noopener"
>https://zihengcat.github.io/2018/09/10/change-locale-system-encoding-in-docker-container/&lt;/a>
然后你猜怎么着，做完这些设置以后中文依然显示为乱码，但是在FileZilla里看却没问题&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240618170337.png"
loading="lazy"
>&lt;/p>
&lt;p>现在高度怀疑是VScode的这个SFTP同步插件的锅&lt;/p></description></item><item><title>StableDiffusion大模型(Dreambooth)云上训练以及安装CODA指定版本</title><link>https://winotmk.github.io/posts/240110_sd%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%BA%91%E4%B8%8A%E8%AE%AD%E7%BB%83/</link><pubDate>Thu, 11 Jan 2024 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/240110_sd%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%BA%91%E4%B8%8A%E8%AE%AD%E7%BB%83/</guid><description>&lt;h2 id="创建阿里云pai-dsw实例跑kohya">创建阿里云PAI DSW实例跑kohya
&lt;/h2>&lt;p>镜像我这里选：
&lt;img src="https://winotmk.github.io/images/20240110174810.png"
loading="lazy"
>
&lt;code>dsw-registry-vpc.cn-shanghai.cr.aliyuncs.com/pai/modelscope:1.10.0-pytorch2.1.0tensorflow2.14.0-gpu-py310-cu118-ubuntu22.04&lt;/code>
我这里用默认的镜像，实测截至2024.01.10时，直接拉kohya的github可以直接用，不需要改动cuda之类的操作&lt;/p>
&lt;h3 id="安装kohya_ss">安装kohya_ss
&lt;/h3>&lt;p>kohya_ss仓库地址：
&lt;a class="link" href="https://github.com/bmaltais/kohya_ss" target="_blank" rel="noopener"
>https://github.com/bmaltais/kohya_ss&lt;/a>
kohya_ss是个webui训练器，SD web_ui里也有对应的Dreambooth训练插件移植，如果只拿来训练不需要跑完整的sd webui服务，只需要kohya就可以了,kohay也可以练lora
在workspace根目录直接：&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/bmaltais/kohya_ss.git
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240110175054.png"
loading="lazy"
>&lt;/p>
&lt;!-- more -->
&lt;p>很快就能完成，接着依次执行&lt;/p>
&lt;pre>&lt;code class="language-bash">cd ./kohya_ss
apt update -y &amp;amp;&amp;amp; apt install -y python3-tk
chmod +x ./setup.sh
./setup.sh
&lt;/code>&lt;/pre>
&lt;p>虽然镜像里带py310，但是似乎还是要装一下python3-tk
之后安装脚本会自动完成，我大概花了5分钟
&lt;img src="https://winotmk.github.io/images/20240110193312.png"
loading="lazy"
>
然后运行启动webui&lt;/p>
&lt;pre>&lt;code>HF_ENDPOINT=https://hf-mirror.com ./gui.sh --headless
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240111114153.png"
loading="lazy"
>
点击这个本地的IP即能点开webui了
&lt;code>HF_ENDPOINT=https://hf-mirror.com&lt;/code>是为了防止抱脸会更新卡住而用的镜像网站（我确实因为这个卡过）或者见本站另一篇专门说代理的文章：
&lt;a class="link" href="https://winotmk.github.io/240109_Linux%E4%B8%8A%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/" target="_blank" rel="noopener"
>https://winotmk.github.io/240109_Linux%E4%B8%8A%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/&lt;/a>&lt;/p>
&lt;h2 id="kohya_ss的dreambooth训练参数">kohya_ss的Dreambooth训练参数
&lt;/h2>&lt;h3 id="source-model">source model
&lt;/h3>&lt;p>&lt;img src="https://winotmk.github.io/images/20240111114635.png"
loading="lazy"
>
我这里用自己上传的模型，可以先上传至阿里云oss再挂载进来，所以这里这样选，然后填模型路径就好了&lt;/p>
&lt;h3 id="floders">floders
&lt;/h3>&lt;p>这个tag里比较简单，没什么好说的
Image folder里写上训练集目录，注意写上的目录底下应该是例如10_ABC目录，然后再放图和txt文件，这个10就step的10，和lora训练时候一样&lt;/p>
&lt;h3 id="parameters">parameters
&lt;/h3>&lt;p>&lt;img src="https://winotmk.github.io/images/20240111115115.png"
loading="lazy"
>&lt;/p>
&lt;h4 id="basic">basic
&lt;/h4>&lt;p>和lora训练设置大同小异，但是参数要比lora小得多，因为Dreambooth比lora性能消耗要大得多而且非常容易过拟合，图出来一滩浆糊，比如我尝试epoch可能10以内就足够，由于文件比较大Save every N epochs我一般也就3-4，其他参数看个人需求吧&lt;/p>
&lt;h4 id="samples">samples
&lt;/h4>&lt;p>这里能填关键词和每多少轮出个预览图，玩玩用
都准备好了就可以点 &lt;code>start training&lt;/code>，但webui不会有任何提示..要看之前启webui的终端
这样就是开始训练了：
&lt;img src="https://winotmk.github.io/images/20240111121059.png"
loading="lazy"
>
不过我第一次成功启动了webui但是点开始训练以后，报过类似这样的错：&lt;/p>
&lt;pre>&lt;code>The following directories listed in your path were found to be non-existent: {PosixPath('/usr/local/nvidia/lib64'), PosixPath('/usr/local/nvidia/lib')}
/usr/local/lib/python3.10/dist-packages/bitsandbytes/cuda_setup/main.py:166: UserWarning: /usr/local/nvidia/lib:/usr/local/nvidia/lib64:/usr/local/cuda-11 did not contain ['libcudart.so', 'libcudart.so.11.0', 'libcudart.so.12.0'] as expected! Searching further paths...
warn(msg)
The following directories listed in your path were found to be non-existent: {PosixPath('//license-pai.cn-shanghai.data.aliyun.com'), PosixPath('http')}
The following directories listed in your path were found to be non-existent: {PosixPath('dsw-registry-vpc.cn-shanghai.cr.aliyuncs.com/cloud-dsw/eas-service'), PosixPath('aigc-torch113-cu117-ubuntu22.04-v0.2.1')}
The following directories listed in your path were found to be non-existent: {PosixPath('http'), PosixPath('8088/dsw-301739'), PosixPath('//127.0.0.1')}
The following directories listed in your path were found to be non-existent: {PosixPath('Asia/Shanghai')}
The following directories listed in your path were found to be non-existent: {PosixPath('tcp'), PosixPath('443'), PosixPath('//10.192.0.1')}
The following directories listed in your path were found to be non-existent: {PosixPath('https'), PosixPath('//dsw-cn-shanghai.data.aliyun.com')}
The following directories listed in your path were found to be non-existent: {PosixPath('tcp'), PosixPath('443'), PosixPath('//10.192.0.1')}
The following directories listed in your path were found to be non-existent: {PosixPath('/home/pai/bin/python')}
CUDA_SETUP: WARNING! libcudart.so not found in any environmental path. Searching in backup paths...
DEBUG: Possible options found for libcudart.so: {PosixPath('/usr/local/cuda/lib64/libcudart.so.11.0')}
CUDA SETUP: PyTorch settings found: CUDA_VERSION=118, Highest Compute Capability: 7.0.
CUDA SETUP: To manually override the PyTorch CUDA version please see:https://github.com/TimDettmers/bitsandbytes/blob/main/how_to_use_nonpytorch_cuda.md
/usr/local/lib/python3.10/dist-packages/bitsandbytes/cuda_setup/main.py:166: UserWarning: WARNING: Compute capability &amp;lt; 7.5 detected! Only slow 8-bit matmul is supported for your GPU! If you run into issues with 8-bit matmul, you can try 4-bit quantization: https://huggingface.co/blog/4bit-transformers-bitsandbytes
warn(msg)
CUDA SETUP: Loading binary /usr/local/lib/python3.10/dist-packages/bitsandbytes/libbitsandbytes_cuda118_nocublaslt.so...
libcusparse.so.11: cannot open shared object file: No such file or directory
CUDA SETUP: Something unexpected happened. Please compile from source:
git clone https://github.com/TimDettmers/bitsandbytes.git
cd bitsandbytes
CUDA_VERSION=118 make cuda11x_nomatmul
python setup.py install
Traceback (most recent call last):
File &amp;quot;/usr/lib/python3.10/runpy.py&amp;quot;, line 187, in _run_module_as_main
mod_name, mod_spec, code = _get_module_details(mod_name, _Error)
File &amp;quot;/usr/lib/python3.10/runpy.py&amp;quot;, line 146, in _get_module_details
return _get_module_details(pkg_main_name, error)
File &amp;quot;/usr/lib/python3.10/runpy.py&amp;quot;, line 110, in _get_module_details
__import__(pkg_name)
File &amp;quot;/usr/local/lib/python3.10/dist-packages/bitsandbytes/__init__.py&amp;quot;, line 6, in &amp;lt;module&amp;gt;
from . import cuda_setup, utils, research
File &amp;quot;/usr/local/lib/python3.10/dist-packages/bitsandbytes/research/__init__.py&amp;quot;, line 1, in &amp;lt;module&amp;gt;
from . import nn
File &amp;quot;/usr/local/lib/python3.10/dist-packages/bitsandbytes/research/nn/__init__.py&amp;quot;, line 1, in &amp;lt;module&amp;gt;
from .modules import LinearFP8Mixed, LinearFP8Global
File &amp;quot;/usr/local/lib/python3.10/dist-packages/bitsandbytes/research/nn/modules.py&amp;quot;, line 8, in &amp;lt;module&amp;gt;
from bitsandbytes.optim import GlobalOptimManager
File &amp;quot;/usr/local/lib/python3.10/dist-packages/bitsandbytes/optim/__init__.py&amp;quot;, line 6, in &amp;lt;module&amp;gt;
from bitsandbytes.cextension import COMPILED_WITH_CUDA
File &amp;quot;/usr/local/lib/python3.10/dist-packages/bitsandbytes/cextension.py&amp;quot;, line 20, in &amp;lt;module&amp;gt;
raise RuntimeError('''
&lt;/code>&lt;/pre>
&lt;p>以及如果遇到类似：&lt;/p>
&lt;pre>&lt;code>Could not load dynamic library 'libcudart.so.11.0'
&lt;/code>&lt;/pre>
&lt;p>重新装适合的CUDA版本即可解决，如果要装CUDA：&lt;/p>
&lt;h2 id="cuda相关">CUDA相关
&lt;/h2>&lt;h3 id="安装cuda指定版本">安装CUDA指定版本
&lt;/h3>&lt;p>遇到过cuda版本不匹配的问题，记一下配置过程
cuda下载：https://developer.nvidia.com/cuda-downloads
但是有时候需要特定版本：https://developer.nvidia.com/cuda-toolkit-archive
以11.8为例，系统是ubuntu22.04，所以这样选：
&lt;img src="https://winotmk.github.io/images/20240111133431.png"
loading="lazy"
>
下载安装cuda：&lt;/p>
&lt;pre>&lt;code>cd /mnt/workspace
wget https://developer.download.nvidia.com/compute/cuda/11.8.0/local_installers/cuda_11.8.0_520.61.05_linux.run
sudo sh cuda_11.8.0_520.61.05_linux.run
&lt;/code>&lt;/pre>
&lt;p>大约3-4GB左右，运行后需要等一会，会弹出交互界面
&lt;img src="https://winotmk.github.io/images/20240111135108.png"
loading="lazy"
>
这里去掉安装驱动，因为我们已经有驱动了只是想要不同版本的cuda，然后选安装&lt;/p>
&lt;p>ps如果遇到装了多份驱动需要卸一个的情况：
&lt;a class="link" href="https://www.jianshu.com/p/54928967e417" target="_blank" rel="noopener"
>https://www.jianshu.com/p/54928967e417&lt;/a>&lt;/p>
&lt;p>装好以后他会提示：
&lt;img src="https://winotmk.github.io/images/20240111135653.png"
loading="lazy"
>
需要往 &lt;code>LD_LIBRARY_PATH&lt;/code> 和 &lt;code>PATH&lt;/code> 里添加两条环境变量&lt;/p>
&lt;pre>&lt;code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-11.8/lib64
export PATH=$PATH:/usr/local/cuda-11.8/bin
&lt;/code>&lt;/pre>
&lt;p>之后我使用&lt;/p>
&lt;pre>&lt;code>python -m bitsandbytes
&lt;/code>&lt;/pre>
&lt;p>如果没有报错应该就是好用的&lt;/p>
&lt;p>ps如果是windows上的wsl：&lt;/p>
&lt;pre>&lt;code>export LD_LIBRARY_PATH=/usr/lib/wsl/lib/
&lt;/code>&lt;/pre>
&lt;h3 id="切换cuda版本">切换cuda版本
&lt;/h3>&lt;pre>&lt;code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-11.7
export BNB_CUDA_VERSION=117
&lt;/code>&lt;/pre>
&lt;p>改环境变量可以手动切换版本（当然得已经装了)&lt;/p>
&lt;h3 id="查看cuda版本">查看cuda版本
&lt;/h3>&lt;pre>&lt;code>nvidia-smi
&lt;/code>&lt;/pre>
&lt;p>或者可以：
参考：https://blog.csdn.net/Kefenggewu_/article/details/117675079
默认cuda会装在&lt;code>/usr/local&lt;/code>,所以查看安装版本可以这样：&lt;/p>
&lt;pre>&lt;code>ls -l /usr/local | grep cuda
&lt;/code>&lt;/pre>
&lt;p>或者据说可以&lt;code>nvcc -V # (V大写)&lt;/code>&lt;/p>
&lt;p>本节另外的参考：https://github.com/TimDettmers/bitsandbytes/blob/main/how_to_use_nonpytorch_cuda.md&lt;/p>
&lt;h2 id="链接">链接
&lt;/h2>&lt;p>kohya_ss:
&lt;a class="link" href="https://github.com/bmaltais/kohya_ss" target="_blank" rel="noopener"
>https://github.com/bmaltais/kohya_ss&lt;/a>
一个封装好的kohya-docker的镜像
&lt;a class="link" href="https://github.com/ashleykleynhans/kohya-docker" target="_blank" rel="noopener"
>https://github.com/ashleykleynhans/kohya-docker&lt;/a>&lt;/p>
&lt;p>dreambooth相关介绍：
&lt;a class="link" href="https://huggingface.co/docs/diffusers/training/dreambooth" target="_blank" rel="noopener"
>https://huggingface.co/docs/diffusers/training/dreambooth&lt;/a>
&lt;a class="link" href="https://github.com/google/dreambooth" target="_blank" rel="noopener"
>https://github.com/google/dreambooth&lt;/a>&lt;/p></description></item><item><title>Linux上的命令行代理工具</title><link>https://winotmk.github.io/posts/240109_linux%E4%B8%8A%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Tue, 09 Jan 2024 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/240109_linux%E4%B8%8A%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>&lt;p>&lt;img src="https://winotmk.github.io/images/20240109144331.png"
loading="lazy"
>&lt;/p>
&lt;p>阿里云的AI白票试用还是很香的，b站顺便一搜有很多教程，跑个lora训练或者SD webui之类的
但难免会遇到要拉更新之类的情况，github和huggingface.co速度慢或者连不上去也经常遇到，除了使用镜像站以外，还有可以使用代理来加速&lt;/p>
&lt;h2 id="先通socks5">先通SOCKS5！
&lt;/h2>&lt;h3 id="安装ss">安装ss
&lt;/h3>&lt;p>先贴上需要用到的软件github：
&lt;a class="link" href="https://github.com/shadowsocks/shadowsocks-libev" target="_blank" rel="noopener"
>https://github.com/shadowsocks/shadowsocks-libev&lt;/a>&lt;/p>
&lt;p>以及大概解释了什么是ss2，ss-go，ss-libev
&lt;a class="link" href="https://shadowsocks5.github.io/en/spec/Implementations.html" target="_blank" rel="noopener"
>https://shadowsocks5.github.io/en/spec/Implementations.html&lt;/a>&lt;/p>
&lt;p>在云端实例命令行下，需要个尽可能简洁小巧又好用的工具，ss-libev可能会是我们的首选，ss-libev是一个轻量级安全 SOCKS5 代理，适用于嵌入式设备和低端设备，用纯 C 编写，体积小巧比较高效
我的云计算镜像是基于ubuntu22.04的
要安装它，直接&lt;/p>
&lt;pre>&lt;code>sudo apt update
sudo apt install shadowsocks-libev
&lt;/code>&lt;/pre>
&lt;h3 id="配置ss">配置ss
&lt;/h3>&lt;p>然后编辑设置：&lt;/p>
&lt;pre>&lt;code># Edit the configuration file
sudo vim /etc/shadowsocks-libev/config.json
&lt;/code>&lt;/pre>
&lt;!-- more -->
&lt;p>在&lt;code>config.json&lt;/code>里&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;server&amp;quot;:&amp;quot;my_server_ip&amp;quot;,
&amp;quot;mode&amp;quot;:&amp;quot;tcp_and_udp&amp;quot;,
&amp;quot;server_port&amp;quot;:8388,
&amp;quot;local_port&amp;quot;:1080,
&amp;quot;password&amp;quot;:&amp;quot;barfoo!&amp;quot;,
&amp;quot;timeout&amp;quot;:600,
&amp;quot;method&amp;quot;:&amp;quot;chacha20-ietf-poly1305&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>server&lt;/code> :您的主机名或服务器 IP (IPv4/IPv6)&lt;/li>
&lt;li>&lt;code>mode&lt;/code> :模式一般不动&lt;/li>
&lt;li>&lt;code>server_port&lt;/code> :服务器端口号&lt;/li>
&lt;li>&lt;code>local_port&lt;/code> :本地端口号，一般默认就1080&lt;/li>
&lt;li>&lt;code>password&lt;/code> :密码&lt;/li>
&lt;li>&lt;code>timeout&lt;/code> :连接超时（以秒为单位）&lt;/li>
&lt;li>&lt;code>method&lt;/code> :加密算法&lt;/li>
&lt;/ul>
&lt;p>这些信息只要你找的代理供应商支持ss协议应该都可以拿到&lt;/p>
&lt;p>ps顺便给同学们复习下vim，懒得用vim的可以不看，按&lt;code>a&lt;/code>进入编辑模式，方向键移动光标，编辑完成后按两下 &lt;code>ctrl+c&lt;/code> 进入指令模式然后&lt;code>:wq!&lt;/code>保存更改并退出,如果直接退出不保存是&lt;code>:q!&lt;/code>&lt;/p>
&lt;h3 id="启动ss客户端">启动ss客户端
&lt;/h3>&lt;p>任意目录输入&lt;/p>
&lt;pre>&lt;code>ss-local
&lt;/code>&lt;/pre>
&lt;p>即可做为客户端启动
这里我启动成功以后显示：
&lt;img src="https://winotmk.github.io/images/20240109150557.png"
loading="lazy"
>&lt;/p>
&lt;p>ps这个软件可以以服务端启动，同样也是修改上面的&lt;code>etc/shadowsocks-libev/config.json&lt;/code>,这里挺容易混淆啊，我这里的目标是想给我的云上GPU计算实例代理加速，所以以客户端启动就行
如果要以服务端启动&lt;/p>
&lt;pre>&lt;code>systemctl start shadowsocks-libev.service
&lt;/code>&lt;/pre>
&lt;p>systemctl如果云上镜像里没有（大概率没有，容器镜像谁会带systemctl或者systemd呢~），可以尝试&lt;/p>
&lt;pre>&lt;code>sudo /etc/init.d/shadowsocks-libev start
&lt;/code>&lt;/pre>
&lt;h2 id="安装proxychains使软件走代理">安装proxychains使软件走代理
&lt;/h2>&lt;p>上面只做到了客户端使用SOCKS5打通代理，接下来再用另外一个软件使我们指定的命令/app走这条SOCKS5线路，也就是需要个SOCKS5转HTTP的工具来为我们所用
这里发现了proxychains&lt;/p>
&lt;blockquote>
&lt;p>ProxyChains 是一个强制应用的 TCP 连接通过代理的工具，支持 Tor、HTTP、与 Socks 代理。ProxyChains 只会将当前应用的 TCP 连接转发至代理，而非全局代理。&lt;/p>&lt;/blockquote>
&lt;h3 id="安装proxychains">安装proxychains
&lt;/h3>&lt;pre>&lt;code>sudo apt install proxychains
&lt;/code>&lt;/pre>
&lt;p>超快就安装好了&lt;/p>
&lt;h3 id="配置">配置
&lt;/h3>&lt;pre>&lt;code> vim /etc/proxychains.conf
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>[ProxyList]
# add proxy here ...
# meanwile
# defaults set to &amp;quot;tor&amp;quot;
#socks4 127.0.0.1 9050
# example
socks5 127.0.0.1 1080
&lt;/code>&lt;/pre>
&lt;h3 id="使用">使用
&lt;/h3>&lt;p>ProxyChains 的使用方式非常简单，直接在应用程序前加上 proxychains 即可
例如：&lt;/p>
&lt;pre>&lt;code>proxychains git clone https://github.com/rofl0r/proxychains-ng
&lt;/code>&lt;/pre>
&lt;p>但是据说ping是不行的，因为pin并不是TCP而是ICMP，所以可以尝试&lt;code>proxychains ping google.com&lt;/code>,总之我是能解析出IP但是会卡住ping不了，问题不大&lt;/p>
&lt;p>试试看是不是通了：
先试试&lt;/p>
&lt;pre>&lt;code>curl cip.cc
&lt;/code>&lt;/pre>
&lt;p>得到
&lt;img src="https://winotmk.github.io/images/20240109152134.png"
loading="lazy"
>&lt;/p>
&lt;p>我们加上proxychains以后&lt;/p>
&lt;pre>&lt;code>proxychains curl cip.cc
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://winotmk.github.io/images/20240109152400.png"
loading="lazy"
>&lt;/p>
&lt;p>看！效果立竿见影，而且可以灵活使用&lt;/p>
&lt;p>另外一种方法或许可以不装proxychains
直接设置变量&lt;/p>
&lt;pre>&lt;code>export http_proxy=&amp;quot;socks5://127.0.0.1:1080&amp;quot;
export https_proxy=&amp;quot;socks5://127.0.0.1:1080&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>可能也可以但没试过&lt;/p>
&lt;h2 id="其他一些镜像方案">其他一些镜像方案：
&lt;/h2>&lt;h3 id="huggingface">huggingface
&lt;/h3>&lt;p>运行python时前加&lt;code>HF_ENDPOINT=https://hf-mirror.com&lt;/code>，这样就可以实现后续走镜像加速了&lt;/p>
&lt;pre>&lt;code>HF_ENDPOINT=https://hf-mirror.com python your_script.py
&lt;/code>&lt;/pre>
&lt;p>详细用法：
&lt;a class="link" href="https://hf-mirror.com/" target="_blank" rel="noopener"
>https://hf-mirror.com/&lt;/a>&lt;/p>
&lt;h3 id="github">github
&lt;/h3>&lt;p>示例用法，直接github域名前加&lt;code>https://mirror.ghproxy.com/&lt;/code>&lt;/p>
&lt;pre>&lt;code>https://mirror.ghproxy.com/https://github.com/d8ahazard/sd_dreambooth_extension
&lt;/code>&lt;/pre>
&lt;p>详细见：
&lt;a class="link" href="https://mirror.ghproxy.com/" target="_blank" rel="noopener"
>https://mirror.ghproxy.com/&lt;/a>
有些部署文件里还是用的之前的域名&lt;code>https://ghproxy.com/&lt;/code>,已失效，改用二级域名&lt;code>https://mirror.ghproxy.com/&lt;/code>即可&lt;/p>
&lt;h2 id="附录">附录
&lt;/h2>&lt;h3 id="本文参考文章">本文参考文章
&lt;/h3>&lt;p>linux命令行代理神器-proxychains
&lt;a class="link" href="https://zhuanlan.zhihu.com/p/166375631" target="_blank" rel="noopener"
>https://zhuanlan.zhihu.com/p/166375631&lt;/a>&lt;/p>
&lt;p>Linux 让终端走代理的几种方法
&lt;a class="link" href="https://zhuanlan.zhihu.com/p/46973701" target="_blank" rel="noopener"
>https://zhuanlan.zhihu.com/p/46973701&lt;/a>&lt;/p>
&lt;p>ss服务端和客户端安装
&lt;a class="link" href="https://mkmerich.com/2018-09-23/shadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85.html" target="_blank" rel="noopener"
>https://mkmerich.com/2018-09-23/shadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85.html&lt;/a>&lt;/p>
&lt;p>基本概念,什么是ss什么是socks5
&lt;a class="link" href="https://reezon.github.io/2018/05/23/%E5%85%B3%E4%BA%8Ess%28%E9%85%B8%E9%85%B8%29%E5%92%8Cssr%28%E9%85%B8%E9%85%B8%E4%B9%B3%29%EF%BC%8C%E8%BF%98%E6%9C%89vpn%E5%92%8Csocks5/" target="_blank" rel="noopener"
>https://reezon.github.io/2018/05/23/%E5%85%B3%E4%BA%8Ess(%E9%85%B8%E9%85%B8)%E5%92%8Cssr(%E9%85%B8%E9%85%B8%E4%B9%B3)%EF%BC%8C%E8%BF%98%E6%9C%89vpn%E5%92%8Csocks5/&lt;/a>&lt;/p>
&lt;p>使用Curl时可以直接用socks5
&lt;a class="link" href="https://blog.emacsos.com/use-socks5-proxy-in-curl.html" target="_blank" rel="noopener"
>https://blog.emacsos.com/use-socks5-proxy-in-curl.html&lt;/a>&lt;/p>
&lt;h3 id="其他类似方案软件">其他类似方案软件
&lt;/h3>&lt;p>sshuttle
&lt;a class="link" href="https://github.com/sshuttle/sshuttle" target="_blank" rel="noopener"
>https://github.com/sshuttle/sshuttle&lt;/a>&lt;/p>
&lt;p>yuhaiin
&lt;a class="link" href="https://github.com/yuhaiin/yuhaiin" target="_blank" rel="noopener"
>https://github.com/yuhaiin/yuhaiin&lt;/a>&lt;/p>
&lt;p>clash-verge
&lt;a class="link" href="https://github.com/zzzgydi/clash-verge" target="_blank" rel="noopener"
>https://github.com/zzzgydi/clash-verge&lt;/a>&lt;/p></description></item><item><title>群晖上用容器搭建SVN服务器</title><link>https://winotmk.github.io/posts/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>&lt;p>&lt;img src="https://winotmk.github.io/images/20231214182733.png"
loading="lazy"
>
事先：我是用路由拨号所以家里已经有外网直连IP，且配置了DDNS和端口转发，所以一个域名即可连上NAS
另外我的群晖是DS720+，是块X86intel的CPU，所以和PC一样用X86的容器镜像就可以，如果是ARM机NAS应该是不通用的&lt;/p>
&lt;p>所用镜像：https://hub.docker.com/r/garethflowers/svn-server
备选镜像（看起来也很不错，拉取次数也过1M：https://hub.docker.com/r/elleflorio/svn-server&lt;/p>
&lt;p>SVN网站：https://subversion.apache.org/&lt;/p>
&lt;p>参考：
&lt;a class="link" href="https://blog.51cto.com/u_12701820/6544028" target="_blank" rel="noopener"
>https://blog.51cto.com/u_12701820/6544028&lt;/a>&lt;/p>
&lt;h2 id="准备镜像">准备镜像
&lt;/h2>&lt;p>&lt;img src="https://winotmk.github.io/images/20231213184128.png"
loading="lazy"
>
由于在群晖的ContainerManager里直接添加镜像不能，应该是要配个docker的镜像站加速或者整个NAS在梯子环境里，懒得整了，我这次选择PC上保存镜像包再拖来NAS里用的形式，个人感觉更方便些&lt;/p>
&lt;p>先在PC上拉个镜像，直接&lt;/p>
&lt;pre>&lt;code>docker pull garethflowers/svn-server:latest
&lt;/code>&lt;/pre>
&lt;p>然后把镜像打包成文件&lt;/p>
&lt;pre>&lt;code>docker save -o svn-server.tar garethflowers/svn-server:latest
&lt;/code>&lt;/pre>
&lt;!-- more -->
&lt;p>就能得到一个&lt;code>svn-server.tar&lt;/code>的文件了，把这个文件上传到ContainerManager里
&lt;img src="https://winotmk.github.io/images/20231214164925.png"
loading="lazy"
>
&lt;img src="https://winotmk.github.io/images/20231214165029.png"
loading="lazy"
>&lt;/p>
&lt;p>然后左边的TAG里选容器》新增，选择刚上传的svn-server
&lt;img src="https://winotmk.github.io/images/20231214165249.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="配置镜像">配置镜像
&lt;/h2>&lt;p>&lt;img src="https://winotmk.github.io/images/20231214171830.png"
loading="lazy"
>
镜像用法说明，基本上配置个端口和映射库就行
&lt;img src="https://winotmk.github.io/images/20231214172511.png"
loading="lazy"
>
&lt;code>/SVN_library/SVN_Folder&lt;/code>是我专门创建的新的NAS文件夹&lt;/p>
&lt;p>之后下一步容器就能启动起来了&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/2023121417311214.png"
loading="lazy"
>
打开终端机》通过命令启动》用&lt;code>/bin/sh&lt;/code> 来开一个交互的shell
然后我输入&lt;/p>
&lt;pre>&lt;code>svnadmin create WinSVN
&lt;/code>&lt;/pre>
&lt;p>来建我的第一个SVN仓库名为&lt;code>WinSVN&lt;/code>&lt;/p>
&lt;p>（以下部分参考: &lt;a class="link" href="https://cloud.tencent.com/developer/article/1650131" target="_blank" rel="noopener"
>https://cloud.tencent.com/developer/article/1650131&lt;/a>&lt;/p>
&lt;p>然后找到&lt;code>/SVN_library/SVN_Folder/WinSVN/conf&lt;/code>，里面是SVN的配置文件了
&lt;img src="https://winotmk.github.io/images/20231214175225.png"
loading="lazy"
>
编辑&lt;code>svnserve.conf&lt;/code>
&lt;img src="https://winotmk.github.io/images/20231214175133.png"
loading="lazy"
>&lt;/p>
&lt;p>anon-access = none #取消匿名访问
auth-access = write #授权用户有可写权限
password-db = passwd #指定用户配置文件，后面会用到&lt;/p>
&lt;p>编辑&lt;code>passwd&lt;/code>
&lt;img src="https://winotmk.github.io/images/20231214175701.png"
loading="lazy"
>
添加了自己的账户，至于分区权限我暂时用不到&lt;/p>
&lt;p>记得重启容器，服务器部分好像就差不多了&lt;/p>
&lt;p>最后别忘记路由器上配个3690端口转发来远程访问这个仓库，我用的是ikuai的路由OS
&lt;img src="https://winotmk.github.io/images/20231214180021.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="测试连接">测试连接
&lt;/h2>&lt;p>pc端新建个文件夹，右键SVN CheckOut
&lt;img src="https://winotmk.github.io/images/20231214181003.png"
loading="lazy"
>
地址可以输入&lt;code>svn://DDNS的域名:3690/WinSVN&lt;/code>，输入上面&lt;code>passwd&lt;/code>文件里设置好的用户名和密码就好了！！&lt;/p>
&lt;p>之后就是svn客户端的基本用法了，随便放一个文件尝试上传
&lt;img src="https://winotmk.github.io/images/20231214181456.png"
loading="lazy"
>
很快就传好了，至此这个SVN仓库宣告可用！
&lt;img src="https://winotmk.github.io/images/20231214181617.png"
loading="lazy"
>&lt;/p></description></item><item><title>Markdown Syntax Guide</title><link>https://winotmk.github.io/p/markdown-syntax-guide/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/p/markdown-syntax-guide/</guid><description>&lt;p>This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.&lt;/p>
&lt;h2 id="headings">Headings
&lt;/h2>&lt;p>The following HTML &lt;code>&amp;lt;h1&amp;gt;&lt;/code>—&lt;code>&amp;lt;h6&amp;gt;&lt;/code> elements represent six levels of section headings. &lt;code>&amp;lt;h1&amp;gt;&lt;/code> is the highest section level while &lt;code>&amp;lt;h6&amp;gt;&lt;/code> is the lowest.&lt;/p>
&lt;h1 id="h1">H1
&lt;/h1>&lt;h2 id="h2">H2
&lt;/h2>&lt;h3 id="h3">H3
&lt;/h3>&lt;h4 id="h4">H4
&lt;/h4>&lt;h5 id="h5">H5
&lt;/h5>&lt;h6 id="h6">H6
&lt;/h6>&lt;h2 id="paragraph">Paragraph
&lt;/h2>&lt;p>Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.&lt;/p>
&lt;p>Itatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.&lt;/p>
&lt;h2 id="blockquotes">Blockquotes
&lt;/h2>&lt;p>The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a &lt;code>footer&lt;/code> or &lt;code>cite&lt;/code> element, and optionally with in-line changes such as annotations and abbreviations.&lt;/p>
&lt;h3 id="blockquote-without-attribution">Blockquote without attribution
&lt;/h3>&lt;blockquote>
&lt;p>Tiam, ad mint andaepu dandae nostion secatur sequo quae.
&lt;strong>Note&lt;/strong> that you can use &lt;em>Markdown syntax&lt;/em> within a blockquote.&lt;/p>&lt;/blockquote>
&lt;h3 id="blockquote-with-attribution">Blockquote with attribution
&lt;/h3>&lt;blockquote>
&lt;p>Don&amp;rsquo;t communicate by sharing memory, share memory by communicating.&lt;br>
— &lt;cite>Rob Pike&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/cite>&lt;/p>&lt;/blockquote>
&lt;h2 id="tables">Tables
&lt;/h2>&lt;p>Tables aren&amp;rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>Age&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Bob&lt;/td>
&lt;td>27&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Alice&lt;/td>
&lt;td>23&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="inline-markdown-within-tables">Inline Markdown within tables
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Italics&lt;/th>
&lt;th>Bold&lt;/th>
&lt;th>Code&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;em>italics&lt;/em>&lt;/td>
&lt;td>&lt;strong>bold&lt;/strong>&lt;/td>
&lt;td>&lt;code>code&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>A&lt;/th>
&lt;th>B&lt;/th>
&lt;th>C&lt;/th>
&lt;th>D&lt;/th>
&lt;th>E&lt;/th>
&lt;th>F&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/td>
&lt;td>Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex.&lt;/td>
&lt;td>Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus&lt;/td>
&lt;td>Proin sit amet velit nec enim imperdiet vehicula.&lt;/td>
&lt;td>Ut bibendum vestibulum quam, eu egestas turpis gravida nec&lt;/td>
&lt;td>Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="code-blocks">Code Blocks
&lt;/h2>&lt;h3 id="code-block-with-backticks">Code block with backticks
&lt;/h3>&lt;pre>&lt;code class="language-html">&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Example HTML5 Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;Test&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>
&lt;h3 id="code-block-indented-with-four-spaces">Code block indented with four spaces
&lt;/h3>&lt;pre>&lt;code>&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;Example HTML5 Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;Test&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>
&lt;h3 id="diff-code-block">Diff code block
&lt;/h3>&lt;pre>&lt;code class="language-diff">[dependencies.bevy]
git = &amp;quot;https://github.com/bevyengine/bevy&amp;quot;
rev = &amp;quot;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13&amp;quot;
- features = [&amp;quot;dynamic&amp;quot;]
+ features = [&amp;quot;jpeg&amp;quot;, &amp;quot;dynamic&amp;quot;]
&lt;/code>&lt;/pre>
&lt;h3 id="one-line-code-block">One line code block
&lt;/h3>&lt;pre>&lt;code class="language-html">&amp;lt;p&amp;gt;A paragraph&amp;lt;/p&amp;gt;
&lt;/code>&lt;/pre>
&lt;h2 id="list-types">List Types
&lt;/h2>&lt;h3 id="ordered-list">Ordered List
&lt;/h3>&lt;ol>
&lt;li>First item&lt;/li>
&lt;li>Second item&lt;/li>
&lt;li>Third item&lt;/li>
&lt;/ol>
&lt;h3 id="unordered-list">Unordered List
&lt;/h3>&lt;ul>
&lt;li>List item&lt;/li>
&lt;li>Another item&lt;/li>
&lt;li>And another item&lt;/li>
&lt;/ul>
&lt;h3 id="nested-list">Nested list
&lt;/h3>&lt;ul>
&lt;li>Fruit
&lt;ul>
&lt;li>Apple&lt;/li>
&lt;li>Orange&lt;/li>
&lt;li>Banana&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Dairy
&lt;ul>
&lt;li>Milk&lt;/li>
&lt;li>Cheese&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="other-elements--abbr-sub-sup-kbd-mark">Other Elements — abbr, sub, sup, kbd, mark
&lt;/h2>&lt;p>&lt;abbr title="Graphics Interchange Format">GIF&lt;/abbr> is a bitmap image format.&lt;/p>
&lt;p>H&lt;sub>2&lt;/sub>O&lt;/p>
&lt;p>X&lt;sup>n&lt;/sup> + Y&lt;sup>n&lt;/sup> = Z&lt;sup>n&lt;/sup>&lt;/p>
&lt;p>Press &lt;kbd>CTRL&lt;/kbd> + &lt;kbd>ALT&lt;/kbd> + &lt;kbd>Delete&lt;/kbd> to end the session.&lt;/p>
&lt;p>Most &lt;mark>salamanders&lt;/mark> are nocturnal, and hunt for insects, worms, and other small creatures.&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>The above quote is excerpted from Rob Pike&amp;rsquo;s &lt;a class="link" href="https://www.youtube.com/watch?v=PAAkCSZUG1c" target="_blank" rel="noopener"
>talk&lt;/a> during Gopherfest, November 18, 2015.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Image gallery</title><link>https://winotmk.github.io/p/image-gallery/</link><pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/p/image-gallery/</guid><description>&lt;img src="https://winotmk.github.io/p/image-gallery/2.jpg" alt="Featured image of post Image gallery" />&lt;p>Hugo theme Stack supports the creation of interactive image galleries using Markdown. It&amp;rsquo;s powered by &lt;a class="link" href="https://photoswipe.com/" target="_blank" rel="noopener"
>PhotoSwipe&lt;/a> and its syntax was inspired by &lt;a class="link" href="https://typlog.com/" target="_blank" rel="noopener"
>Typlog&lt;/a>.&lt;/p>
&lt;p>To use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo&amp;rsquo;s page bundle feature to read the dimensions of the image. &lt;strong>External images are not supported.&lt;/strong>&lt;/p>
&lt;h2 id="syntax">Syntax
&lt;/h2>&lt;pre>&lt;code class="language-markdown">![Image 1](1.jpg) ![Image 2](2.jpg)
&lt;/code>&lt;/pre>
&lt;h2 id="result">Result
&lt;/h2>&lt;p>&lt;img src="https://winotmk.github.io/p/image-gallery/1.jpg"
width="2000"
height="1400"
srcset="https://winotmk.github.io/p/image-gallery/1_hu_811b671457ffff1f.jpg 480w, https://winotmk.github.io/p/image-gallery/1_hu_c74af69dd7c1dcda.jpg 1024w"
loading="lazy"
alt="Image 1"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="342px"
> &lt;img src="https://winotmk.github.io/p/image-gallery/2.jpg"
width="1500"
height="2250"
srcset="https://winotmk.github.io/p/image-gallery/2_hu_42f6436cb1637265.jpg 480w, https://winotmk.github.io/p/image-gallery/2_hu_27862a49608da0d9.jpg 1024w"
loading="lazy"
alt="Image 2"
class="gallery-image"
data-flex-grow="66"
data-flex-basis="160px"
>&lt;/p>
&lt;blockquote>
&lt;p>Photo by &lt;a class="link" href="https://unsplash.com/@mymind" target="_blank" rel="noopener"
>mymind&lt;/a> and &lt;a class="link" href="https://unsplash.com/@lukechesser" target="_blank" rel="noopener"
>Luke Chesser&lt;/a> on &lt;a class="link" href="https://unsplash.com/" target="_blank" rel="noopener"
>Unsplash&lt;/a>&lt;/p>&lt;/blockquote></description></item><item><title>Docker01.1_eci价格计算表</title><link>https://winotmk.github.io/posts/docker01.1_%E4%BB%B7%E6%A0%BC%E8%AE%A1%E7%AE%97%E8%A1%A8/</link><pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/docker01.1_%E4%BB%B7%E6%A0%BC%E8%AE%A1%E7%AE%97%E8%A1%A8/</guid><description>&lt;p>计费文档：
&lt;a class="link" href="https://help.aliyun.com/document_detail/447697.html" target="_blank" rel="noopener"
>https://help.aliyun.com/document_detail/447697.html&lt;/a>&lt;/p>
&lt;p>定价标准：&lt;/p>
&lt;blockquote>
&lt;p>vCPU单价（vCPU）：0.000049 元/秒
内存单价（GiB）： 0.00000613 元/秒&lt;/p>&lt;/blockquote>
&lt;p>所以可知：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>规格&lt;/th>
&lt;th>秒&lt;/th>
&lt;th>分钟&lt;/th>
&lt;th>小时&lt;/th>
&lt;th>天&lt;/th>
&lt;th>月&lt;/th>
&lt;th>年&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>每1u&lt;/td>
&lt;td>0.00004900&lt;/td>
&lt;td>0.00294&lt;/td>
&lt;td>0.1764&lt;/td>
&lt;td>4.2336&lt;/td>
&lt;td>127.008&lt;/td>
&lt;td>1545.264&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>每1G内存&lt;/td>
&lt;td>0.00000613&lt;/td>
&lt;td>0.0003678&lt;/td>
&lt;td>0.022068&lt;/td>
&lt;td>0.529632&lt;/td>
&lt;td>15.88896&lt;/td>
&lt;td>193.31568&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>eci价格计算：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>实例规格&lt;/th>
&lt;th>秒&lt;/th>
&lt;th>分钟&lt;/th>
&lt;th>小时&lt;/th>
&lt;th>天&lt;/th>
&lt;th>月&lt;/th>
&lt;th>年&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0.25u 0.5G&lt;/td>
&lt;td>0.00001532&lt;/td>
&lt;td>0.0009189&lt;/td>
&lt;td>0.055134&lt;/td>
&lt;td>1.323216&lt;/td>
&lt;td>39.69648&lt;/td>
&lt;td>482.97384&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0.5u 1G&lt;/td>
&lt;td>0.00003063&lt;/td>
&lt;td>0.0018378&lt;/td>
&lt;td>0.110268&lt;/td>
&lt;td>2.646432&lt;/td>
&lt;td>79.39296&lt;/td>
&lt;td>965.94768&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2u 4G&lt;/td>
&lt;td>0.00012252&lt;/td>
&lt;td>0.0073512&lt;/td>
&lt;td>0.441072&lt;/td>
&lt;td>10.585728&lt;/td>
&lt;td>317.57184&lt;/td>
&lt;td>3863.79072&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2u 8G&lt;/td>
&lt;td>0.00014704&lt;/td>
&lt;td>0.0088224&lt;/td>
&lt;td>0.529344&lt;/td>
&lt;td>12.704256&lt;/td>
&lt;td>381.12768&lt;/td>
&lt;td>4637.05344&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4u 8G&lt;/td>
&lt;td>0.00024504&lt;/td>
&lt;td>0.0147024&lt;/td>
&lt;td>0.882144&lt;/td>
&lt;td>21.171456&lt;/td>
&lt;td>635.14368&lt;/td>
&lt;td>7727.58144&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>64u 256G&lt;/td>
&lt;td>0.00470528&lt;/td>
&lt;td>0.2823168&lt;/td>
&lt;td>16.939008&lt;/td>
&lt;td>406.536192&lt;/td>
&lt;td>12196.08576&lt;/td>
&lt;td>148385.7101&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>一秒0.0047元很便宜吗？一月要1.2w！可以说被安排得明明白白了&lt;/p></description></item><item><title>Math Typesetting</title><link>https://winotmk.github.io/p/math-typesetting/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/p/math-typesetting/</guid><description>&lt;p>Stack has built-in support for math typesetting using &lt;a class="link" href="https://katex.org/" target="_blank" rel="noopener"
>KaTeX&lt;/a>.&lt;/p>
&lt;p>&lt;strong>It&amp;rsquo;s not enabled by default side-wide,&lt;/strong> but you can enable it for individual posts by adding &lt;code>math: true&lt;/code> to the front matter. Or you can enable it side-wide by adding &lt;code>math = true&lt;/code> to the &lt;code>params.article&lt;/code> section in &lt;code>config.toml&lt;/code>.&lt;/p>
&lt;h2 id="inline-math">Inline math
&lt;/h2>&lt;p>This is an inline mathematical expression: $\varphi = \dfrac{1+\sqrt5}{2}= 1.6180339887…$&lt;/p>
&lt;pre>&lt;code class="language-markdown">$\varphi = \dfrac{1+\sqrt5}{2}= 1.6180339887…$
&lt;/code>&lt;/pre>
&lt;h2 id="block-math">Block math
&lt;/h2>$$
\varphi = 1+\frac{1} {1+\frac{1} {1+\frac{1} {1+\cdots} } }
$$&lt;pre>&lt;code class="language-markdown">$$
\varphi = 1+\frac{1} {1+\frac{1} {1+\frac{1} {1+\cdots} } }
$$
&lt;/code>&lt;/pre>
$$
f(x) = \int_{-\infty}^\infty\hat f(\xi)\,e^{2 \pi i \xi x}\,d\xi
$$&lt;pre>&lt;code class="language-markdown">$$
f(x) = \int_{-\infty}^\infty\hat f(\xi)\,e^{2 \pi i \xi x}\,d\xi
$$
&lt;/code>&lt;/pre></description></item><item><title>Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行</title><link>https://winotmk.github.io/posts/docker01/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/docker01/</guid><description>&lt;style type="text/css" rel="stylesheet">
.nav-number {
display:none !important;
}
.post-toc .nav-item {
white-space: normal !important;
}
&lt;/style>
&lt;p>一口气步子迈得有大，慢慢记录一下,如果你碰巧看到这个文章，希望这个文章的某些部分对你有帮助，来源我已尽量在文章中标出，还有很多部分是自己敲的&lt;/p>
&lt;p>了解ECI弹性容器：https://www.aliyun.com/product/eci
了解阿里云NAS文件存储：https://www.aliyun.com/product/nas&lt;/p>
&lt;p>&lt;strong>为什么要用eci来运行hexo？&lt;/strong>
因为好玩，同时来学习从pull到发布到运行整个docker镜像的流程，也想给自己的hexo博客找个新家，酷酷的那种
本博客之前是由树莓派上的hexo生成，部署到github上的
最近在捣鼓docker，一时想不起来有什么灵活小巧的服务拿来用docker玩，那么想着干脆把树莓派上hexo这部分服务做成镜像，需要用的时候拿出来用用想必是极好的（这么一来好像树莓派又要吃灰了）
恰巧最近又在琢磨阿里云ECI容器服务，所以理论上是可以用我自己打包好的镜像的
最后成品的结构大致如下图：&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20230829140549.png"
loading="lazy"
>&lt;/p>
&lt;p>这里挂了3个镜像：
&lt;strong>1.node.js+git+ssh+hexo&lt;/strong>
主要是此镜像——由node.js+hexo组成的运行hexo环境，用过的都了解hexo是基于node.js的，每次我们生成文章的时候都会&lt;code>hexo g -d&lt;/code>，而运行这套需要一个环境容器
git和ssh主要是部署在github上用的，同时我习惯用VSCode的SSH FS来管理远程文件和写博客，主要是ssh连接，也方便我拿PuTTY和WinSCP远程登录管理
&lt;strong>2.vsftpd&lt;/strong>
一个常用的ftp服务，我是在本地些完再上传的，用这个是因为我发现如果要给文章插入图片，我还需要手动用ssh上传到hexo对应目录里。而用VSCode的SSH FS可以帮我自动同步本地工作目录和云上即将生成静态网页的hexo目录，非常方便！
&lt;strong>3.ddns&lt;/strong>
因为容器是即用即开，用完就释放的，每次开会新分配一个弹性IP做为外网接口，但是不想每次都去复制这个新的ip地址，那么就要用到动态域名解析，刚好我在阿里云上购买过一个我自己的域名，所以ddns这部分服务就拉出来做个镜像&lt;/p>
&lt;p>还挂了一个NAS盘：
&lt;img src="https://winotmk.github.io/images/20230829142400.png"
loading="lazy"
>
挂载以后：
&lt;img src="https://winotmk.github.io/images/20230829142501.png"
loading="lazy"
>
可见我的hexo，主题，文章，图片等等都存放在里面，服务容器可以随便释放拉取，数据不会受到影响，几百M的NAS容量价格抹零后可以忽略不计&lt;/p>
&lt;p>文章后面（第三部分）会说如何按我的需求构建定制这几个镜像，并上传到阿里云容器镜像ARK仓库以方便调用&lt;/p>
&lt;!-- more -->
&lt;p>&lt;strong>vsftpd&lt;/strong>还有&lt;strong>ddns&lt;/strong>可以与主镜像&lt;strong>node.js+hexo&lt;/strong>合并成一个大镜像吗？
&lt;strong>当然可以&lt;/strong>，但我实际做了几次以后发现把ftp，ddns这样常用的服务功能单独拿出来会方便得多的多，毕竟我想起别得服务，也可以给他们挂上ftp等常用服务，我也可以选择不挂，这样容器的优势就体现出来了。我可以把单一的服务都做成单独的小镜像，需要哪个挂哪个，性能消耗也很小&lt;/p>
&lt;p>整套下来有这些部分：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>docker基本操作&lt;/strong>&lt;/li>
&lt;li>&lt;strong>已经启动的本地容器修改端口，启动容器时即启动服务等&lt;/strong>&lt;/li>
&lt;li>&lt;strong>打包制作自己的docker镜像(dockerfile)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>docker镜像打包并上传到阿里云镜像库ARK&lt;/strong>&lt;/li>
&lt;li>&lt;strong>eci容器创建模板和eci命令行工具使用&lt;/strong>&lt;/li>
&lt;li>&lt;strong>hexo本地编辑环境设置————如何用VSCode舒服的写MD文档&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>附表：
群晖搭建私有镜像仓库和dockerengine设置
eci价格计算表&lt;/p>
&lt;hr>
&lt;h2 id="1-docker-基本操作">1. docker 基本操作
&lt;/h2>&lt;p>博主吐槽一下，总觉得一些类似run，commit操作完全可以做成一个美观好用的UI控制软件，但是docker destop就是不做，然后大家都默认敲命令行是方便的，好用的。十分不解，可能需要ui的不会写ui，熟练使用命令行的也不需要什么ui吧，诶
——后面随着对docker了解的深入，明白它不是虚拟机，用得还是linux内核，这么一想，处处真是浓浓的linux味，现在能提供一个windows下的Docker Desktop桌面程序，已经非常得不错了！
资料网站：&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.docker.com/engine/reference/commandline/cli/" target="_blank" rel="noopener"
>官方命令大全&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://chunchengwei.github.io/ruan-jian/ji-yu-docker-de-hexo-bo-ke-da-jian/" target="_blank" rel="noopener"
>基于Docker的Hexo博客搭建&lt;/a>&lt;/p>
&lt;p>这个基本操作写得还行下次爬一篇下来吧：&lt;/p>
&lt;p>&lt;a class="link" href="https://yingclin.github.io/2018/docker-basic.html" target="_blank" rel="noopener"
>[小抄] Docker 基本命令&lt;/a>&lt;/p>
&lt;h3 id="11-运行容器">1.1 运行容器
&lt;/h3>&lt;pre>&lt;code class="language-bash">docker run -it -d --name [container-name] -p 8088:80 [image-name]
&lt;/code>&lt;/pre>
&lt;p>这里是将容器内的80端口映射到宿主机的8088端口&lt;/p>
&lt;p>参数说明&lt;/p>
&lt;p>&lt;code>-d&lt;/code> 表示后台运行容器
&lt;code>-t&lt;/code> 为docker分配一个伪终端并绑定到容器的标准输入上
&lt;code>-i&lt;/code> 是让容器的标准输入保持打开状态
&lt;code>-p&lt;/code> 指定映射端口&lt;/p>
&lt;p>还能这么写：&lt;/p>
&lt;pre>&lt;code class="language-bash">docker run --name mssql -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=xxxx' \
-p 1433:1433 \
-d mssql-2019-with-cimb
&lt;/code>&lt;/pre>
&lt;p>&lt;code>\&lt;/code>应该是可以换行表述
&lt;code>-e&lt;/code> 定义环境变量（通常制作镜像的时候应该已经写好了，或者在容器内做好自动脚本，run时候再写毕竟是不方便的）&lt;/p>
&lt;h3 id="12-将此容器-commit-保存为新镜像">1.2 将此容器 commit 保存为新镜像：
&lt;/h3>&lt;p>格式：&lt;/p>
&lt;pre>&lt;code>docker commit container-id new-name
&lt;/code>&lt;/pre>
&lt;p>container-id也可以是已有容器的名字，例如：&lt;/p>
&lt;pre>&lt;code>docker commit node-test nodehexo
&lt;/code>&lt;/pre>
&lt;p>nodehexo这里是新镜像名&lt;/p>
&lt;h3 id="13-启动docker引擎时自动运行docker容器">1.3 启动docker引擎时自动运行docker容器：
&lt;/h3>&lt;p>&lt;a class="link" href="https://blog.csdn.net/londa/article/details/97611947" target="_blank" rel="noopener"
>https://blog.csdn.net/londa/article/details/97611947&lt;/a>&lt;/p>
&lt;p>ps:上面链接文章还有:修改docker容器的挂载路径，修改docker默认的存储位置&lt;/p>
&lt;pre>&lt;code>docker run --restart=always
&lt;/code>&lt;/pre>
&lt;p>有时候，我们创建容器时忘了添加参数 &lt;code>--restart=always&lt;/code> ，当 Docker 重启时，容器未能自动启动，&lt;/p>
&lt;p>现在要添加该参数怎么办呢，方法有二：&lt;/p>
&lt;p>1、Docker 命令修改&lt;/p>
&lt;pre>&lt;code>docker container update --restart=always 容器名字
&lt;/code>&lt;/pre>
&lt;p>我实际运行时，可以支持同时配置多个容器id，比如（其中container关键字可以忽略不写）&lt;/p>
&lt;pre>&lt;code>docker update 87cd61ad7f7c f488b0479f24 2109903220ce 1fb346ea1a46 --restart=no
&lt;/code>&lt;/pre>
&lt;p>2、直接改配置文件&lt;/p>
&lt;p>首先停止容器，不然无法修改配置文件&lt;/p>
&lt;p>配置文件路径为：&lt;code>/var/lib/docker/containers/&lt;/code> 容器ID&lt;/p>
&lt;p>在该目录下找到一个文件 hostconfig.json ，找到该文件中关键字 RestartPolicy&lt;/p>
&lt;p>修改前配置：&lt;code>&amp;quot;RestartPolicy&amp;quot;:{&amp;quot;Name&amp;quot;:&amp;quot;no&amp;quot;,&amp;quot;MaximumRetryCount&amp;quot;:0}&lt;/code>&lt;/p>
&lt;p>修改后配置：&lt;code>&amp;quot;RestartPolicy&amp;quot;:{&amp;quot;Name&amp;quot;:&amp;quot;always&amp;quot;,&amp;quot;MaximumRetryCount&amp;quot;:0}&lt;/code>&lt;/p>
&lt;p>最后启动容器。&lt;/p>
&lt;h3 id="14-有关dockerfile">1.4 有关dockerfile
&lt;/h3>&lt;p>dockerfile是用来构建镜像的脚本
主要参考这几篇：
&lt;a class="link" href="https://www.runoob.com/docker/docker-dockerfile.html" target="_blank" rel="noopener"
>https://www.runoob.com/docker/docker-dockerfile.html&lt;/a>
&lt;a class="link" href="https://developer.aliyun.com/article/484262" target="_blank" rel="noopener"
>https://developer.aliyun.com/article/484262&lt;/a>
&lt;a class="link" href="https://juejin.cn/s/docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC" target="_blank" rel="noopener"
>docker容器启动时自动启动脚本&lt;/a>&lt;/p>
&lt;h4 id="编写dockerfile">编写dockerfile
&lt;/h4>&lt;p>我的第一个dockerfile：
简单做个测试，在之前做的镜像上加了条启动命令
&lt;strong>Dockerfile&lt;/strong> （文件没有后缀)&lt;/p>
&lt;pre>&lt;code>## Set the base image to CentOS 基于nodehexo
FROM nodehexo:V4
COPY ddnsstart.sh /ddnsstart.sh
ENTRYPOINT [&amp;quot;/bin/bash&amp;quot;, &amp;quot;/ddnsstart.sh&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>很简单:
&lt;code>FROM&lt;/code>基于&lt;code>nodehexo:V4&lt;/code>镜像构建
&lt;code>COPY&lt;/code>就是拷贝构建目录下的&lt;code>ddnsstart.sh&lt;/code>到之后构建好的镜像根目录下
&lt;code>ENTRYPOINT&lt;/code>会在用新镜像开启容器时再执行，这里会在执行&lt;code>/bin/bash&lt;/code>里执行&lt;code>/ddnsstart.sh&lt;/code>&lt;/p>
&lt;p>一个dockerfile只能有一条&lt;code>ENTRYPOINT&lt;/code>，多个也只执行最后一个,&lt;code>CMD&lt;/code>也是如此
如果 Dockerfile 中如果存在多个 &lt;code>CMD&lt;/code> 指令，仅最后一个生效。&lt;/p>
&lt;p>关于&lt;code>CMD&lt;/code>还有些写法，比如还可以
&lt;code>CMD service ssh start &amp;amp;&amp;amp; service XXX start &amp;amp;&amp;amp; tail -f /etc/passwd&lt;/code>一起执行多道指令
这在构建镜像的时候会被自动转换为类似：
&lt;code>CMD [&amp;quot;/bin/sh&amp;quot;, &amp;quot;service ssh start&amp;quot;,&amp;quot;service XXX start&amp;quot;,&amp;quot;tail -f /etc/passwd&amp;quot;]&lt;/code>&lt;/p>
&lt;p>&lt;code>tail -f /etc/passwd&lt;/code>作用在于防止docker容器开启后立即关闭见下面段落&lt;/p>
&lt;p>CMD格式：&lt;/p>
&lt;pre>&lt;code>CMD &amp;lt;shell 命令&amp;gt;
CMD [&amp;quot;&amp;lt;可执行文件或命令&amp;gt;&amp;quot;,&amp;quot;&amp;lt;param1&amp;gt;&amp;quot;,&amp;quot;&amp;lt;param2&amp;gt;&amp;quot;,...]
CMD [&amp;quot;&amp;lt;param1&amp;gt;&amp;quot;,&amp;quot;&amp;lt;param2&amp;gt;&amp;quot;,...] # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数
&lt;/code>&lt;/pre>
&lt;p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认是 &lt;code>bin/sh&lt;/code>&lt;/p>
&lt;p>&lt;strong>ddnsstart.sh文件&lt;/strong>&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
root/ddnsAPP/ddns -c root/ddnsAPP/config.json
echo &amp;quot;更新mcwrite.winotmk.com解析&amp;quot;
service ssh start
tail -f /etc/passwd
&lt;/code>&lt;/pre>
&lt;p>这里都是简单的shell命令了
&lt;code>root/ddnsAPP/ddns -c root/ddnsAPP/config.json&lt;/code>是执行ddns更新，解析新的ip到域名上，因为我这个镜像打算放到阿里云ECI里跑，每次新拉的IP当然都不一样（一直占着一个IP会产生费用，没必要）&lt;/p>
&lt;p>同时我还执行了启动ssh服务，有的时候会用上ssh，因为我把网盘挂载到了容器内
&lt;code>tail -f /etc/passwd&lt;/code>这里起到的比较重要的占着进程的作用，详见下面：&lt;/p>
&lt;p>*关于 &lt;code>CMD&lt;/code> 或 &lt;code>entrypoint&lt;/code> 构建后 &lt;code>docker run -dit&lt;/code> 为何容器依然秒退
&lt;a class="link" href="https://www.zhihu.com/question/344939968" target="_blank" rel="noopener"
>https://www.zhihu.com/question/344939968&lt;/a>
是因为使用了CMD或者entrypoint去service *** start命令作为容器启动命令，主进程执行完结束了，容器也就结束了&lt;/p>
&lt;blockquote>
&lt;p>dockerfile 写清楚 entrypoint 和 cmd，启动脚本如果立刻会退出，那么在最后添加 tail -f 某个日志文件。或者 监听某个端口或者进程。
方法1: 设置容器启动时就启动服务ENTRYPOINT [&amp;ldquo;flask&amp;rdquo;, &amp;ldquo;run&amp;rdquo;, &amp;ldquo;-h&amp;rdquo;, &amp;ldquo;0.0.0.0&amp;rdquo;, &amp;ldquo;-p&amp;rdquo;, &amp;ldquo;80&amp;rdquo;]
方法2:CMD service apache2 start &amp;amp;&amp;amp; tail -F /var/log/apache2/error.log再极端点 sleep infinite&lt;/p>&lt;/blockquote>
&lt;h4 id="用dockerfile构建镜像">用dockerfile构建镜像
&lt;/h4>&lt;p>&lt;code>docker build -t &amp;lt;新镜像名字:标签&amp;gt; .&lt;/code>
比如&lt;code>docker build -t nodehexo:V5 .&lt;/code>
请不要忘记最后一个&lt;code>.&lt;/code>，这表示在当前目录下构建
用这条指令前先&lt;code>CD&lt;/code>到dockerfile文件所放置的目录
比如我先&lt;code>CD ./dockerbuild&lt;/code>，因为我的文件放在&lt;code>用户/dockerbuild&lt;/code>目录下面
然后就拥有了属于构建的镜像！&lt;/p>
&lt;h4 id="141-entrypoint与cmd的区别">1.4.1 ENTRYPOINT与CMD的区别
&lt;/h4>&lt;p>Docker 的 ENTRYPOINT 和 CMD 参数探秘
&lt;a class="link" href="https://aws.amazon.com/cn/blogs/china/demystifying-entrypoint-cmd-docker/" target="_blank" rel="noopener"
>https://aws.amazon.com/cn/blogs/china/demystifying-entrypoint-cmd-docker/&lt;/a>&lt;/p>
&lt;h4 id="142-dockerfile构建镜像时如何选择from镜像以减小镜像体积">1.4.2 dockerfile构建镜像时如何选择FROM镜像以减小镜像体积
&lt;/h4>&lt;p>busybox：
&lt;a class="link" href="https://blog.csdn.net/hknaruto/article/details/70229896" target="_blank" rel="noopener"
>https://blog.csdn.net/hknaruto/article/details/70229896&lt;/a>
alpine：
&lt;a class="link" href="https://hub.docker.com/_/alpine" target="_blank" rel="noopener"
>https://hub.docker.com/_/alpine&lt;/a>
alpine包管理器APK：
&lt;a class="link" href="https://wangchujiang.com/linux-command/c/apk.html" target="_blank" rel="noopener"
>https://wangchujiang.com/linux-command/c/apk.html&lt;/a>
&lt;a class="link" href="https://wiki.alpinelinux.org/wiki/Alpine_Package_Keeper" target="_blank" rel="noopener"
>https://wiki.alpinelinux.org/wiki/Alpine_Package_Keeper&lt;/a>&lt;/p>
&lt;h3 id="15-将已有镜像打包带走使用将打包来的镜像">1.5 将已有镜像打包带走/使用将打包来的镜像
&lt;/h3>&lt;p>&lt;a class="link" href="https://zhuanlan.zhihu.com/p/348849578" target="_blank" rel="noopener"
>https://zhuanlan.zhihu.com/p/348849578&lt;/a>&lt;/p>
&lt;h4 id="将镜像保存为本地文件">将镜像保存为本地文件
&lt;/h4>&lt;p>可以使用Docker save命令&lt;/p>
&lt;pre>&lt;code>docker save -o mssql-2019-with-cimb.tar mssql-2019-with-cimb
&lt;/code>&lt;/pre>
&lt;p>会得到一个&lt;code>mssql-2019-with-cimb.tar&lt;/code>文件，就可以随身携带啦&lt;/p>
&lt;p>从文件载入镜像&lt;/p>
&lt;h4 id="从文件载入镜像">从文件载入镜像
&lt;/h4>&lt;p>使用Docker load命令:&lt;/p>
&lt;pre>&lt;code>docker load --input mssql-2019-with-cimb.tar
&lt;/code>&lt;/pre>
&lt;h3 id="16-docker挂载本地目录">1.6 docker挂载本地目录
&lt;/h3>&lt;p>有关volume:https://docs.docker.com/storage/volumes/
&lt;a class="link" href="https://docs.docker.com/get-started/05_persisting_data/" target="_blank" rel="noopener"
>https://docs.docker.com/get-started/05_persisting_data/&lt;/a>
&lt;a class="link" href="https://blog.csdn.net/zz00008888/article/details/131924286" target="_blank" rel="noopener"
>https://blog.csdn.net/zz00008888/article/details/131924286&lt;/a>&lt;/p>
&lt;p>在Docker中，可以使用“-v”选项来挂载本地目录。该选项需要两个参数，分别是本地目录路径和容器内目录路径。例如，以下命令将本地目录“/home/user/app”挂载到容器内的“/app”目录中：&lt;/p>
&lt;pre>&lt;code>docker run -v /home/user/app:/app my_image
&lt;/code>&lt;/pre>
&lt;p>这将使得容器可以访问本地目录中的文件，并且任何对该目录的更改也会反映在容器中。&lt;/p>
&lt;p>&lt;strong>Docker挂载本地目录到已有容器&lt;/strong>&lt;/p>
&lt;p>除了在容器启动时挂载本地目录外，还可以在运行时将本地目录挂载到正在运行的容器中。要实现这一点，可以使用“docker cp”命令将本地目录复制到容器中，并使用“docker exec”命令在容器中执行命令。例如，以下命令将本地目录“/home/user/data”挂载到正在运行的容器中：&lt;/p>
&lt;pre>&lt;code>docker cp /home/user/data my_container:/data
docker exec -it my_container bash
&lt;/code>&lt;/pre>
&lt;p>在容器中，可以访问挂载的目录“/data”，并且任何对该目录的更改也会反映在本地文件系统中。&lt;/p>
&lt;h3 id="17-其他一些操作">1.7 其他一些操作
&lt;/h3>&lt;pre>&lt;code># ****************************** 容器 ****************************** #
# 查看正在运行的容器
$ docker ps
# 查看所有容器
$ docker ps -a
# 启动/停止某个容器
$ docker start/stop id/name
# 以交互方式启动一个容器
$ docker start -i id/name
# 进入某个容器(使用exit退出后容器也跟着停止运行)
$ docker attach id/name
# 启动一个伪终端以交互式的方式进入某个运行的容器（使用exit退出后容器不停止运行）
$ docker exec -it id/name
# 删除某个容器
$ docker rm id/name
# 复制ubuntu容器并且重命名为test且运行，然后以伪终端交互式方式进入容器，运行bash
$ docker run --name test -ti ubuntu /bin/bash
# ****************************** 镜像 ****************************** #
# 查看本地镜像
$ docker images
# 删除某个镜像
$ docker rmi id/name
# 基于当前目录下的Dockerfile，创建一个名为name:flag的镜像
$ docker build -t name:flag .
&lt;/code>&lt;/pre>
&lt;h2 id="2-已启动容器操作">2. 已启动容器操作
&lt;/h2>&lt;h3 id="21-win10下docker给已存在的容器添加端口映射的方法">2.1 win10下docker给已存在的容器添加端口映射的方法
&lt;/h3>&lt;p>博主再吐槽一下，这个调试阶段如此常用的修改容我端口，改起来却像游戏作弊，不觉得这个要做简单很难，怕只是没做
&lt;a class="link" href="https://mdnice.com/writing/25822ca29531424d9b68d7feb8273a82" target="_blank" rel="noopener"
>https://mdnice.com/writing/25822ca29531424d9b68d7feb8273a82&lt;/a>
&lt;a class="link" href="https://blog.csdn.net/Taysuesue/article/details/126706394" target="_blank" rel="noopener"
>https://blog.csdn.net/Taysuesue/article/details/126706394&lt;/a>
&lt;a class="link" href="https://www.cnblogs.com/kingsonfu/p/11578073.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/kingsonfu/p/11578073.html&lt;/a>&lt;/p>
&lt;p>查看容器已映射的端口（dockerdeskUI内也可看见）&lt;/p>
&lt;pre>&lt;code>docker port 容器ID/容器名
&lt;/code>&lt;/pre>
&lt;p>先停止容器&lt;/p>
&lt;pre>&lt;code>docker stop {容器的名称或者 id }
&lt;/code>&lt;/pre>
&lt;p>查看容器完整的 &lt;code>hash_of_the_container&lt;/code> 数值：&lt;/p>
&lt;pre>&lt;code>docker inspect {容器的名称或者 id } | grep Id
# 比如：
docker inspect cbe26510c276 | grep Id
# 会得到如下结果：
# &amp;quot;Id&amp;quot;: &amp;quot;cbe26510c276fa9a4487a8c2af8cbb49410f2a5305149d2b26eb8ce37c777d00&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>如果主机是linux（mac应该也行没测）&lt;/strong>
打开 hostconfig.json 配置文件:&lt;/p>
&lt;pre>&lt;code>vim /var/lib/docker/containers/{hash_of_the_container}/hostconfig.json
&lt;/code>&lt;/pre>
&lt;p>记得还要改 config.v2.json，改法同下面的win10
&lt;strong>如果是win10&lt;/strong>
1.先找到容器的配置文件，首先我的电脑地址栏输\wsl$\进入到网络文件夹上,在一步一步找到容器目录&lt;/p>
&lt;pre>&lt;code>\\wsl$\docker-desktop-data\data\docker\containers
&lt;/code>&lt;/pre>
&lt;p>2.点击进入相应容器ID文件夹，打开后修改其中的 &lt;code>config.v2.json&lt;/code> 和 &lt;code>hostconfig.json&lt;/code>&lt;/p>
&lt;p>&lt;strong>hostconfig.json&lt;/strong>&lt;/p>
&lt;pre>&lt;code>&amp;quot;PortBindings&amp;quot;:{&amp;quot;22/tcp&amp;quot;:[{&amp;quot;HostIp&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;HostPort&amp;quot;:&amp;quot;50022&amp;quot;}],&amp;quot;3306/tcp&amp;quot;:[{&amp;quot;HostIp&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;HostPort&amp;quot;:&amp;quot;53306&amp;quot;}],&amp;quot;6379/tcp&amp;quot;:[{&amp;quot;HostIp&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;HostPort&amp;quot;:&amp;quot;56379&amp;quot;}]}
&lt;/code>&lt;/pre>
&lt;p>这里的&lt;code>HostPort&lt;/code>字面意思就是宿主机的端口，所以即：
容器内22&amp;gt;外部5022访问
容器内3306&amp;gt;外部53306访问
容器内6379&amp;gt;外部56379访问&lt;/p>
&lt;p>&lt;strong>config.v2.json&lt;/strong> 有两处需要添加，只修改一处不生效&lt;/p>
&lt;pre>&lt;code>&amp;quot;ExposedPorts&amp;quot;:{&amp;quot;22/tcp&amp;quot;:{},&amp;quot;3306/tcp&amp;quot;:{},&amp;quot;6379/tcp&amp;quot;:{}}
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>&amp;quot;Ports&amp;quot;:{&amp;quot;22/tcp&amp;quot;:[{&amp;quot;HostIp&amp;quot;:&amp;quot;0.0.0.0&amp;quot;,&amp;quot;HostPort&amp;quot;:&amp;quot;50022&amp;quot;}],&amp;quot;3306/tcp&amp;quot;:[{&amp;quot;HostIp&amp;quot;:&amp;quot;0.0.0.0&amp;quot;,&amp;quot;HostPort&amp;quot;:&amp;quot;53306&amp;quot;}],&amp;quot;6379/tcp&amp;quot;:[{&amp;quot;HostIp&amp;quot;:&amp;quot;0.0.0.0&amp;quot;,&amp;quot;HostPort&amp;quot;:&amp;quot;56379&amp;quot;}]}
&lt;/code>&lt;/pre>
&lt;p>不过我实际只改了这里的&lt;code>&amp;quot;ExposedPorts&amp;quot;&lt;/code>貌似就行了&lt;/p>
&lt;p>然后重启&lt;strong>docker&lt;/strong>，注意不只是重启容器，我一开始只重启容器发现白改了&lt;/p>
&lt;pre>&lt;code># 重启 docker
service docker restart
&lt;/code>&lt;/pre>
&lt;p>或者在系统右下角，点击Restart重启整个 Docker 服务，然后再重启 Container 即可正常使用&lt;/p>
&lt;h3 id="22-docker容器内服务开机自启动实现方案以ssh服务为例">2.2 docker容器内服务开机自启动实现方案（以ssh服务为例）
&lt;/h3>&lt;p>&lt;strong>&lt;font color=red>注意，2.2这段内容随着对docker和linux了解的深入觉得有不妥，但是作为学习的过程还是保留&lt;/font>&lt;/strong>&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/qq_38603541/article/details/124028994" target="_blank" rel="noopener"
>https://blog.csdn.net/qq_38603541/article/details/124028994&lt;/a>&lt;/p>
&lt;p>因为我后续打算用类似vscode里的remote-ssh来管理容器内，也想用winscp等好用的工具可以接进来，还是有必要开个ssh
&lt;strong>解决方案&lt;/strong>
1、正常我们在linux操作系统内设置服务自启动的方法一般都是使用systemctl。&lt;/p>
&lt;p>systemctl enable ssh
2、但是，一般在docker容器内我们一般不这么干，因为容器内没有systemctl权限……&lt;/p>
&lt;p>3、我们依然还是使用脚本的形式将ssh设为自启，只不过这个的这个脚本和我们使用Dockerfile的脚本不一样。&lt;/p>
&lt;p>4、在 /root 目录下新建一个 start_ssh.sh文件，并给予该文件可执行权限。&lt;/p>
&lt;pre>&lt;code>touch /root/start_ssh.sh
vim /root/start_ssh.sh
chmod +x /root/start_ssh.sh
&lt;/code>&lt;/pre>
&lt;p>5、start_ssh.sh 脚本的内容，如下：&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
LOGTIME=$(date &amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;)
echo &amp;quot;[$LOGTIME] startup run...&amp;quot; &amp;gt;&amp;gt;/root/start_ssh.log
service ssh start &amp;gt;&amp;gt;/root/start_ssh.log
#service mysql start &amp;gt;&amp;gt;/root/star_mysql.log //其他服务也可这么实现
&lt;/code>&lt;/pre>
&lt;p>6、将start_ssh.sh脚本添加到启动文件中&lt;/p>
&lt;pre>&lt;code>vim /root/.bashrc
&lt;/code>&lt;/pre>
&lt;p>7、在 .bashrc 文件末尾加入如下内容：&lt;/p>
&lt;pre>&lt;code># startup run
if [ -f /root/start_ssh.sh ]; then
. /root/start_ssh.sh
fi
&lt;/code>&lt;/pre>
&lt;p>8、保存后，等下次重启容器的时候，添加的服务也就跟着重启了。&lt;/p>
&lt;p>docker容器在启动的时候，会自动执行的是~/.bashrc文件，所以，环境变量需要配置在该文件内，这样镜像启动时，可自动执行该文件，使环境变量生效。&lt;/p>
&lt;p>&lt;strong>&lt;font color=red>正确的理解是：&lt;/font>&lt;/strong>
/root/.bashrc会在容器启动的时候自动执行这句十分欠妥，
准确的来讲是&lt;strong>root用户登录bash的时候会执行，每次开新的bash shell也会执行一遍&lt;/strong>
如果dockerfile内定义了ENTRYPOINT或者CMD执行类似：&lt;/p>
&lt;pre>&lt;code>ENTRYPOINT [ &amp;quot;/bin/bash&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;service apache2 start&amp;quot; ]
&lt;/code>&lt;/pre>
&lt;p>那么对于容器来说PID 1号进程就是bash（apache是bash的子进程），也确实会跑一遍.bashrc内的内容，但是这不代表所有容器启动时一定会启动bash shell，也可能直接是个java进程，也可能是dumb-int，更多时候可能是sh shell，这应该都不会触发.bashrc
所以如果想要在容器启动时自动启动一个服务，推荐写在dockerfile里，比如&lt;/p>
&lt;pre>&lt;code>COPY start.sh /
ENTRYPOINT [ &amp;quot;sh&amp;quot;,&amp;quot;/start.sh&amp;quot; ]
&lt;/code>&lt;/pre>
&lt;p>然后再在start.sh里写上你需要启动的服务&lt;/p>
&lt;pre>&lt;code>#!/bin/sh
service ssh restart
service apache2 restart
&lt;/code>&lt;/pre>
&lt;p>以及如果确实有很多个服务需要启，考虑使用类似docker compose启多个镜像，每个镜像跑单个服务&lt;/p>
&lt;h4 id="221-拓展bashrc-etcbashrc-etcprofile三个文件的区别">2.2.1 拓展：~/.bashrc /etc/bashrc /etc/profile三个文件的区别
&lt;/h4>&lt;p>&lt;a class="link" href="https://segmentfault.com/q/1010000003793341" target="_blank" rel="noopener"
>https://segmentfault.com/q/1010000003793341&lt;/a>&lt;/p>
&lt;h2 id="3-打包制作自己的docker镜像dockerfile">3 打包制作自己的docker镜像(dockerfile)
&lt;/h2>&lt;p>dockerfile是告诉docker engine如何构建镜像的脚本&lt;/p>
&lt;h3 id="31-nodejsgithexo镜像">3.1 node.js+git+hexo镜像
&lt;/h3>&lt;p>其实这部分镜像做了两遍，第一遍直接拉的官方node镜像，然后发现ssh不好装，走了很多弯路，随着对docker了解的加深，最后我自己做了dockerfile重构了这部分镜像&lt;/p>
&lt;h4 id="311-dockerfile">3.1.1 Dockerfile
&lt;/h4>&lt;p>&lt;strong>&lt;i class="fas fa-file">&lt;/i>dockerfileV02（可以没有后缀）&lt;/strong>&lt;/p>
&lt;pre>&lt;code>#这个包将包含：node-v29.5.0 git ssh hexo
#hexo环境目录/hexo/Winblog
FROM debian:stable-slim
LABEL maintainer=&amp;quot;winotmk&amp;quot; web=&amp;quot;md.winotmk.com&amp;quot; Ver=&amp;quot;02&amp;quot;
#ADD有自动解压功能
ADD node-v20.5.0-linux-x64.tar.xz /
#移动node二进制文件到目录
RUN mkdir -p /usr/local/nodejs &amp;amp;&amp;amp;\
mv node-v20.5.0-linux-x64 /usr/local/nodejs &amp;amp;&amp;amp;\
#mk hexo目录
mkdir -p /hexo/Winblog &amp;amp;&amp;amp;\
apt-get update &amp;amp;&amp;amp;\
#安装SSH 安装GIT
apt-get install -y --no-install-recommends openssh-server git-core &amp;amp;&amp;amp;\
apt-get autoremove -y &amp;amp;&amp;amp;\
apt-get clean
#node和npm环境变量
ENV PATH=&amp;quot;/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH&amp;quot;
#安装hexo
WORKDIR /hexo/Winblog
RUN npm install -g hexo-cli
#hexo环境变量
ENV PATH=&amp;quot;$PATH:/hexo/Winblog/node_modules/.bin&amp;quot;
#更新ssh设置
COPY sshd_config /etc/ssh/
#环境变量设置
COPY .profile /root/
#设置启动脚本
COPY hexo_debian_service_start.sh /service_start.sh
CMD [&amp;quot;/bin/bash&amp;quot;,&amp;quot;/service_start.sh&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>基本上都是些安装命令以及配置环境变量
安装了&lt;code>hexo&lt;/code>,&lt;code>git&lt;/code>,&lt;code>ssh&lt;/code>,&lt;code>node&lt;/code>
这是优化过了的第二版，主要是第二版使用了&lt;code>ADD&lt;/code>，它基本和&lt;code>COPY&lt;/code>一样，都可以把某个构建目录下的文件打入正在生成的镜像里，但当用ADD在执行 &amp;lt;源文件&amp;gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &amp;lt;目标路径&amp;gt;。说白了ADD会帮我自动解压
在这里我还设置了ssh（但是没有配置root密码）&lt;/p>
&lt;p>而我的第一版开头：
&lt;strong>&lt;i class="fas fa-file">&lt;/i>dockerfileV01&lt;/strong>&lt;/p>
&lt;pre>&lt;code>FROM debian:stable-slim
COPY node-v20.5.0-linux-x64.tar.xz /node-v20.5.0-linux-x64.tar.xz
RUN apt-get update &amp;amp;&amp;amp;\
apt-get install -y xz-utils --no-install-recommends &amp;amp;&amp;amp;\
tar -xvf node-v20.5.0-linux-x64.tar.xz &amp;amp;&amp;amp;\
mkdir -p /usr/local/nodejs &amp;amp;&amp;amp;\
mv node-v20.5.0-linux-x64 /usr/local/nodejs &amp;amp;&amp;amp;\
#删除xz包
apt-get purge -y xz-utils &amp;amp;&amp;amp; \
apt-get autoremove -y &amp;amp;&amp;amp; \
apt-get clean &amp;amp;&amp;amp; \
#删除node-v20.5.0-linux-x64.tar.xz包
rm node-v20.5.0-linux-x64.tar.xz
#node和npm环境变量
ENV PATH=&amp;quot;/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>当时不知道&lt;code>ADD&lt;/code>的功能，使用 &lt;code>COPY&lt;/code>拷贝整个.tar.xz包结果debian还没有.xz包解压功能，需要安装&lt;code>xz-utils&lt;/code>&lt;a class="link" href="https://blog.csdn.net/weixin_43502175/article/details/129547250" target="_blank" rel="noopener"
>详见&lt;/a>，凭空多出好几行&lt;/p>
&lt;p>&lt;strong>为什么要用二进制包安装呢node.js呢？&lt;/strong>
因为实测如果用&lt;code>apt-get install nodejs&lt;/code>安装，
或者&lt;code>curl -fsSL https://deb.nodesource.com/setup_19.x | bash - &amp;amp;&amp;amp;\ apt-get install -y nodejs&lt;/code>&lt;a class="link" href="https://github.com/nodesource/distributions" target="_blank" rel="noopener"
>命令出处&lt;/a>，
安装出来镜像体积就是会楞大出好几百MB&lt;/p>
&lt;h4 id="312-nodejsgithexo镜像copy的文件">3.1.2 node.js+git+hexo镜像COPY的文件
&lt;/h4>&lt;p>&lt;strong>&lt;i class="fas fa-file">&lt;/i>.profile&lt;/strong>&lt;/p>
&lt;pre>&lt;code># ~/.profile: executed by Bourne-compatible login shells.
if [ &amp;quot;$BASH&amp;quot; ]; then
if [ -f ~/.bashrc ]; then
. ~/.bashrc
fi
fi
mesg n 2&amp;gt; /dev/null || true
export PATH=&amp;quot;/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH&amp;quot;
export PATH=&amp;quot;$PATH:/hexo/Winblog/node_modules/.bin&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>为了防止镜像上云后莫名其妙的原因导致环境变量出问题，脚本里再跑一遍，这俩&lt;code>export PATH&lt;/code>其实dockerfile里设置过&lt;/p>
&lt;p>&lt;strong>sshd_config是什么&lt;/strong>
ssh的设置
参考：https://blog.csdn.net/weixin_34910922/article/details/125193597
主要改了两条&lt;/p>
&lt;pre>&lt;code class="language-bash">#vim /etc/ssh/sshd_config
PermitRootLogin yes #root登陆权限
PasswordAuthentication yes #密码权限
&lt;/code>&lt;/pre>
&lt;p>等于我们预先改好了配置文件，在构建的时候再把配置放入容器里面&lt;/p>
&lt;p>&lt;strong>&lt;i class="fas fa-file">&lt;/i>hexo_debian_service_start.sh&lt;/strong>&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
. ~/.profile
LOGTIME=$(date &amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;)
echo &amp;quot;[$LOGTIME] startup run...&amp;quot; &amp;gt;&amp;gt;/start_ssh.log
service ssh start &amp;gt;&amp;gt;/start_ssh.log
tail -f /start_ssh.log
&lt;/code>&lt;/pre>
&lt;p>启动脚本，主要启动了ssh服务，并且用&lt;code>tail -f&lt;/code>让这个容器一直运行以方便我们来连接&lt;/p>
&lt;h4 id="313-开始构建镜像">3.1.3 开始构建镜像
&lt;/h4>&lt;p>先&lt;code>CD&lt;/code>到Dockerfile所在的目录
&lt;img src="https://winotmk.github.io/images/20230829135356.png"
loading="lazy"
>&lt;/p>
&lt;pre>&lt;code>docker build -t hexo_debian:V02 -f dockerfileV02 .
&lt;/code>&lt;/pre>
&lt;p>格式是&lt;/p>
&lt;pre>&lt;code>docker build -t 镜像名:tag -f Dockerfile文件名 .
&lt;/code>&lt;/pre>
&lt;p>注意&lt;code>.&lt;/code>不要落下！&lt;/p>
&lt;p>这样我们的镜像就做好了！&lt;/p>
&lt;p>本节参考资料：
二进制手动安装node参考：
&lt;a class="link" href="https://github.com/nodejs/help/wiki/Installation" target="_blank" rel="noopener"
>https://github.com/nodejs/help/wiki/Installation&lt;/a>
&lt;a class="link" href="https://blog.51cto.com/u_13460811/4901015" target="_blank" rel="noopener"
>https://blog.51cto.com/u_13460811/4901015&lt;/a>&lt;/p>
&lt;p>一些关于dockerfile指令的说明：
较详细： &lt;a class="link" href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy" target="_blank" rel="noopener"
>https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy&lt;/a>
&lt;a class="link" href="https://blog.csdn.net/qq_35528657/article/details/127244194" target="_blank" rel="noopener"
>https://blog.csdn.net/qq_35528657/article/details/127244194&lt;/a>
&lt;a class="link" href="https://www.runoob.com/docker/docker-dockerfile.html" target="_blank" rel="noopener"
>https://www.runoob.com/docker/docker-dockerfile.html&lt;/a>&lt;/p>
&lt;p>在dockerfile里用apt-get包管理的建议：
&lt;a class="link" href="https://ubuntu.com/blog/we-reduced-our-docker-images-by-60-with-no-install-recommends" target="_blank" rel="noopener"
>https://ubuntu.com/blog/we-reduced-our-docker-images-by-60-with-no-install-recommends&lt;/a>
&lt;a class="link" href="https://www.metricfire.com/blog/how-to-build-optimal-docker-images/" target="_blank" rel="noopener"
>https://www.metricfire.com/blog/how-to-build-optimal-docker-images/&lt;/a>&lt;/p>
&lt;p>hexo所需环境安装说明：
&lt;a class="link" href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener"
>https://hexo.io/zh-cn/docs/index.html&lt;/a>&lt;/p>
&lt;h4 id="314-测试镜像功能">3.1.4 测试镜像功能
&lt;/h4>&lt;p>来启个容器试试！&lt;/p>
&lt;pre>&lt;code>docker run -it -d -p 22:22 --name hexo_debian hexo_debian:V02
&lt;/code>&lt;/pre>
&lt;p>这里开放了22端口来方便验证ssh服务和登录ssh没有问题
启动成功！
容器内执行来验证服务状态都正常：&lt;/p>
&lt;pre>&lt;code>ssh
node -v
git -v
&lt;/code>&lt;/pre>
&lt;p>输出：
&lt;img src="https://winotmk.github.io/images/20230829124045.png"
loading="lazy"
>
可以看见一切正常！&lt;/p>
&lt;h4 id="315-设置和再打包镜像">3.1.5 设置和再打包镜像
&lt;/h4>&lt;h5 id="设置">设置
&lt;/h5>&lt;p>毕竟自用镜像，我习惯直接把比如ssh密钥之类全都配置好，再&lt;code>commit&lt;/code>为一个新镜像，以后就再也不用输密码了，这样确实不安全，但是自己的hexo博客而已，何必为难自己呢
接下来设置root密码和重启ssh服务
&lt;img src="https://winotmk.github.io/images/20230829124114.png"
loading="lazy"
>&lt;/p>
&lt;pre>&lt;code>passwd root
#然后敲自己设置的密码
service ssh restart
&lt;/code>&lt;/pre>
&lt;p>尝试使用PuTTY进行SSH &lt;a class="link" href="mailto:root@127.0.0.1" >root@127.0.0.1&lt;/a>登录：
&lt;img src="https://winotmk.github.io/images/20230829123658.png"
loading="lazy"
>
成功!!!
接下来配置git和ssh，要生成新的ssh公钥
详见：https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent
&lt;img src="https://winotmk.github.io/images/20230829124332.png"
loading="lazy"
>&lt;/p>
&lt;pre>&lt;code>ssh-keygen -t ed25519 -C &amp;quot;github邮箱@qq.com&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>得到密钥默认在&lt;code>/root/.ssh/id_ed25519.pub&lt;/code>
&lt;img src="https://winotmk.github.io/images/20230829124753.png"
loading="lazy"
>
在Github的头像点Setting然后点右上角击&lt;strong>New SSH key&lt;/strong>，把id_ed25519.pub内容粘贴进即可！
测试SSH连接：&lt;/p>
&lt;pre>&lt;code>ssh -T git@github.com
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://winotmk.github.io/images/20230829125208.png"
loading="lazy"
>
这样就连上了！
需要进行一个小设置：&lt;/p>
&lt;pre>&lt;code>git config --global user.email &amp;quot;you@example.com&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>这样以后使用&lt;code>hexo d&lt;/code>的时候就能无脑部署了&lt;/p>
&lt;h5 id="再打包">再打包
&lt;/h5>&lt;p>为了存下我们配置好的连接，制作成最终镜像方便eci云上调用，把现有容器再commit一次&lt;/p>
&lt;pre>&lt;code>docker commit hexo_debian hexo_debian:V02-configured
&lt;/code>&lt;/pre>
&lt;p>成了！得到了&lt;code>hexo_debian:V02-configured&lt;/code>作为我最后准备上传至ECI云的镜像&lt;/p>
&lt;hr>
&lt;h4 id="316-附一些命令参考">3.1.6 附一些命令参考
&lt;/h4>&lt;h5 id="如何用ssh连接-docker-容器">如何用ssh连接 docker 容器
&lt;/h5>&lt;p>&lt;a class="link" href="https://blog.csdn.net/weixin_34910922/article/details/125193597" target="_blank" rel="noopener"
>https://blog.csdn.net/weixin_34910922/article/details/125193597&lt;/a>&lt;/p>
&lt;p>1.修改root密码&lt;/p>
&lt;pre>&lt;code>$ passwd root
输入密码：123456(自己决定)
&lt;/code>&lt;/pre>
&lt;p>2.安装Openssh&lt;/p>
&lt;pre>&lt;code>sudo apt-get update # 更新源
sudo apt-get upgrade # 更新系统软件
apt-get install -y openssh-server
&lt;/code>&lt;/pre>
&lt;p>3.修改ssh配置,允许root登录
&lt;a class="link" href="https://blog.csdn.net/weixin_43343144/article/details/102494830" target="_blank" rel="noopener"
>https://blog.csdn.net/weixin_43343144/article/details/102494830&lt;/a>
&lt;strong>【非常重要】在/etc/ssh/ssh_config中没有PermitRootLogin yes选项的话，就要在sshd_config文件中寻找！&lt;/strong>&lt;/p>
&lt;pre>&lt;code>vim /etc/ssh/sshd_config
PermitRootLogin yes #root登陆权限
PasswordAuthentication yes #密码权限
&lt;/code>&lt;/pre>
&lt;p>4.启动ssh服务/重启服务&lt;/p>
&lt;pre>&lt;code>service ssh start
service ssh restart
&lt;/code>&lt;/pre>
&lt;h5 id="安装hexo">安装hexo
&lt;/h5>&lt;pre>&lt;code>npm install hexo-cli -g
&lt;/code>&lt;/pre>
&lt;h5 id="ssh远程登录这个镜像">SSH远程登录这个镜像
&lt;/h5>&lt;p>之前在本机docker内已经配好了ssh服务，讲道理应该启动则开启ssh但是不知为啥没有自动启动，以后再研究吧
打开Workbench远程连接，启动ssh
由于我启用ECI时开通了弹性公网IP，所以我可以通过这个IP:22用ssh来登录
&lt;img src="https://winotmk.github.io/images/20230811153438.png"
loading="lazy"
>
使用PuTTY工具登录成功！！
&lt;img src="https://winotmk.github.io/images/20230811153400.png"
loading="lazy"
>
多么令人振奋的一刻&lt;/p>
&lt;hr>
&lt;h3 id="32-vsftpd镜像">3.2 vsftpd镜像
&lt;/h3>&lt;p>这个镜像比较简单，只跑ftp服务，主要在写作的时候方便上传图片&lt;/p>
&lt;h4 id="321-dockerfile">3.2.1 Dockerfile
&lt;/h4>&lt;p>&lt;strong>&lt;i class="fas fa-file">&lt;/i>vsftpd_dockerfileV01&lt;/strong>&lt;/p>
&lt;pre>&lt;code>#这个包将包含：vsftp（root登录）
FROM debian:stable-slim
LABEL maintainer=&amp;quot;winotmk&amp;quot; web=&amp;quot;md.winotmk.com&amp;quot; Ver=&amp;quot;01&amp;quot;
RUN apt-get update &amp;amp;&amp;amp;\
apt-get install -y vsftpd --no-install-recommends &amp;amp;&amp;amp;\
apt-get autoremove -y &amp;amp;&amp;amp;\
apt-get clean &amp;amp;&amp;amp;\
echo &amp;quot;root:yourpasswd&amp;quot; | chpasswd
COPY ftpusers /etc/
COPY vsftpd.conf /etc/
COPY service_start.sh /service_start.sh
CMD [&amp;quot;/bin/bash&amp;quot;,&amp;quot;/service_start.sh&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>比较简单的dockerfile，就装了个vsftpd服务，然后拷贝了一些设置文件
如果要在dockerfile里配置用户密码可以这么写：&lt;/p>
&lt;pre>&lt;code>echo &amp;quot;root:yourpasswd&amp;quot; | chpasswd
&lt;/code>&lt;/pre>
&lt;h4 id="322-vsftpd镜像copy的文件">3.2.2 vsftpd镜像COPY的文件
&lt;/h4>&lt;p>&lt;strong>&lt;i class="fas fa-file">&lt;/i>service_start.sh&lt;/strong>&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
LOGTIME=$(date &amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;)
echo &amp;quot;[$LOGTIME] startup run...&amp;quot; &amp;gt;&amp;gt;/start_vsftpd.log
service vsftpd start &amp;gt;&amp;gt;/start_vsftpd.log
tail -f /start_vsftpd.log
&lt;/code>&lt;/pre>
&lt;p>简单的服务启动脚本，使用&lt;code>tail -f&lt;/code>来维持住进程&lt;/p>
&lt;p>&lt;strong>&lt;i class="fas fa-file">&lt;/i>ftpusers&lt;/strong>
&lt;code>root&lt;/code>前加个&lt;code>#&lt;/code>以启用root登录&lt;/p>
&lt;pre>&lt;code># /etc/ftpusers: list of users disallowed FTP access. See ftpusers(5).
#root
daemon
bin
sys
sync
games
man
lp
mail
news
uucp
nobody
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>&lt;i class="fas fa-file">&lt;/i>vsftpd.conf&lt;/strong>
ftp设置文件，这个文件内容很多只些下修改的部分&lt;/p>
&lt;pre>&lt;code>listen=NO
listen_ipv6=YES
anonymous_enable=NO
local_enable=YES
write_enable=YES
dirmessage_enable=YES
use_localtime=YES
connect_from_port_20=YES
pam_service_name=vsftpd
utf8_filesystem=YES
&lt;/code>&lt;/pre>
&lt;p>*关于修改vsftpd的端口
&lt;a class="link" href="https://askubuntu.com/questions/37058/how-to-change-vsftpd-default-port" target="_blank" rel="noopener"
>https://askubuntu.com/questions/37058/how-to-change-vsftpd-default-port&lt;/a>
&lt;code>vsftpd.conf&lt;/code>里的设置不是完全设置，可以自己增加字段&lt;/p>
&lt;pre>&lt;code>listen_port=234
ftp_data_port=235
pasv_min_port=30000
pasv_max_port=31000
&lt;/code>&lt;/pre>
&lt;p>来设置端口
注意FTP默认20传输数据，21用来listen，所以改得话干脆两个都改吧&lt;/p>
&lt;p>*这里遇到过一个小坑坑
&lt;img src="https://winotmk.github.io/images/20230829155702.png"
loading="lazy"
>
构建器报错，一直卡在&lt;code>Starting FTP server: vsftpdvsftpd failed - probably invalid config. ... (warning).&lt;/code>
&lt;img src="https://winotmk.github.io/images/20230829155358.png"
loading="lazy"
>
自己在容器内运行&lt;code>service vsftpd start&lt;/code>的时候同样如此，一般这样是因为&lt;code>vsftpd.conf&lt;/code>文件设置错了，可神奇的是我只要打开dockerDesktop的Files文件管理把&lt;code>vsftpd.conf&lt;/code>打开再保存一下就可以成功运行&lt;code>service vsftpd start&lt;/code>
我发现这个文件的格式是UTF-8 CRLF
&lt;img src="https://winotmk.github.io/images/20230829155602.png"
loading="lazy"
>
修改为LF
&lt;img src="https://winotmk.github.io/images/20230829155623.png"
loading="lazy"
>
即可顺利启动vsftpd服务&lt;/p>
&lt;p>参考：
&lt;a class="link" href="https://www.cnblogs.com/Dreamcho/p/10805690.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/Dreamcho/p/10805690.html&lt;/a>&lt;/p>
&lt;p>如果要在dockerfile里加用户：
&lt;a class="link" href="https://blog.csdn.net/u010275850/article/details/120587850" target="_blank" rel="noopener"
>https://blog.csdn.net/u010275850/article/details/120587850&lt;/a>&lt;/p>
&lt;h3 id="33-ddns镜像">3.3 ddns镜像
&lt;/h3>&lt;p>这个镜像更简单？只在启动的时候跑一个ddns
但是我却在这里卡了很久
原因之一是因为一开始选用的ddns软件本地跑得好好的，在阿里云上总是报错，log显示已经修改了a记录但是自己去一看啥也没有，很是困惑，所以换了个软件实现
最开始使用的是这个软件，配置方便
&lt;a class="link" href="https://github.com/NewFuture/DDNS" target="_blank" rel="noopener"
>https://github.com/NewFuture/DDNS&lt;/a>
参考：
&lt;a class="link" href="https://blog.csdn.net/biao0309/article/details/117202951" target="_blank" rel="noopener"
>https://blog.csdn.net/biao0309/article/details/117202951&lt;/a>
无奈阿里云上即便是用官方提供的镜像&lt;code>newfuture/ddns&lt;/code>也会报错（恼&lt;/p>
&lt;p>所以我改用ddns-go:
&lt;a class="link" href="https://github.com/jeessy2/ddns-go" target="_blank" rel="noopener"
>https://github.com/jeessy2/ddns-go&lt;/a>
先贴上官方镜像的层：
&lt;strong>jeessy/ddns-go&lt;/strong>
&lt;img src="https://winotmk.github.io/images/20230904184205.png"
loading="lazy"
>
我们的新镜像将基于官方镜像来做&lt;/p>
&lt;h4 id="331-dockerfile">3.3.1 dockerfile
&lt;/h4>&lt;p>&lt;strong>&lt;i class="fas fa-file">&lt;/i>ddns-go_dockerfileV01&lt;/strong>&lt;/p>
&lt;pre>&lt;code>FROM jeessy/ddns-go
LABEL maintainer=&amp;quot;winotmk&amp;quot; web=&amp;quot;md.winotmk.com&amp;quot; Ver=&amp;quot;01&amp;quot;
COPY ddns_start.sh /
COPY ddns_go_config.yaml /
ENV DDNS_URL=
ENTRYPOINT [ &amp;quot;sh&amp;quot;,&amp;quot;/ddns_start.sh&amp;quot; ]
CMD [ &amp;quot;&amp;quot; ]
&lt;/code>&lt;/pre>
&lt;p>这里做了一个变量&lt;code>$DDNS_URL&lt;/code>来定义我想要dns的域名(当然这个域名我得拥有)
ENTRYPOINT和CMD的设置会覆盖掉的之前镜像内的设置
我不确定CMD [ &amp;quot;&amp;quot; ]是否有必要，但总之我想使官方镜像里的CMD失效，从结果上来看管用&lt;/p>
&lt;h4 id="332-ddns镜像copy的文件">3.3.2 ddns镜像COPY的文件
&lt;/h4>&lt;p>&lt;strong>&lt;i class="fas fa-file">&lt;/i>ddns_go_config.yaml&lt;/strong>&lt;/p>
&lt;pre>&lt;code>dnsconf:
- ipv4:
enable: true
gettype: url
url: https://myip4.ipip.net,https://ddns.oray.com/checkip,https://ip.3322.net,https://4.ipw.cn
netinterface: &amp;quot;&amp;quot;
cmd: &amp;quot;&amp;quot;
domains:
- null.winotmk.com
ipv6:
enable: false
gettype: netInterface
url: https://speed.neu6.edu.cn/getIP.php,https://v6.ident.me,https://6.ipw.cn
netinterface: &amp;quot;&amp;quot;
cmd: &amp;quot;&amp;quot;
ipv6reg: &amp;quot;&amp;quot;
domains:
- &amp;quot;&amp;quot;
dns:
name: alidns
id: 阿里云的AccessKey ID
secret: 阿里云的AccessKey secret
ttl: &amp;quot;&amp;quot;
user:
username: &amp;quot;&amp;quot;
password: &amp;quot;&amp;quot;
webhook:
webhookurl: &amp;quot;&amp;quot;
webhookrequestbody: &amp;quot;&amp;quot;
webhookheaders: &amp;quot;&amp;quot;
notallowwanaccess: true
&lt;/code>&lt;/pre>
&lt;p>这个是ddns-go的配置文件，第一次启动会在本地:9876打开个web界面，保存设置后会在root中生成这个文件，这里我直接引入这个文件是希望后面能用&lt;code>sed&lt;/code>命令对文件的&lt;code>domains&lt;/code>字段进行修改&lt;/p>
&lt;p>&lt;strong>&lt;i class="fas fa-file">&lt;/i>ddns_start.sh&lt;/strong>&lt;/p>
&lt;pre>&lt;code>#!/bin/sh
LOGTIME=$(date &amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;)
echo &amp;quot;[$LOGTIME] startup run...&amp;quot; &amp;gt;&amp;gt;/start_ddns.log
cd /
if [ &amp;quot;$DDNS_URL&amp;quot; = &amp;quot;&amp;quot; ]
then
echo &amp;quot;DDNS_URL is not set!&amp;quot; &amp;gt;&amp;gt;/start_ddns.log
tail -f /start_ddns.log
else
sed -i &amp;quot;s/null.winotmk.com/$DDNS_URL/g&amp;quot; ddns_go_config.yaml
#chmod 777 ddns_go_config.yaml
sleep 3
/app/ddns-go -l :9876 -f 300 -c /ddns_go_config.yaml
echo &amp;quot;已执行更新[$DDNS_URL]解析&amp;quot; &amp;gt;&amp;gt;/start_ddns.log
tail -f /start_ddns.log
fi
&lt;/code>&lt;/pre>
&lt;p>在这个脚本里会判断&lt;code>$DDNS_URL&lt;/code>是否为空，空的话直接输出需要&lt;code>$DDNS_URL&lt;/code>设置
如果不为空的话会通过&lt;code>sed&lt;/code>替换字符，这里设置文件内默认写得是&lt;code>null.winotmk.com&lt;/code>
用这种方式去直接修改设置文件，是因为我没找到这个软件是否能直接用环境变量来定义解析到的域名&lt;/p>
&lt;p>关于用sed替换congif.json设置内的字段：
如何使用sed:
&lt;a class="link" href="https://linux.cn/article-11367-1.html" target="_blank" rel="noopener"
>https://linux.cn/article-11367-1.html&lt;/a>
如何在sed命令内使用变量
&lt;a class="link" href="https://www.cnblogs.com/muahao/p/6874412.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/muahao/p/6874412.html&lt;/a>
判断变量是否为空的方法：
&lt;a class="link" href="https://cloud.tencent.com/developer/article/1721905" target="_blank" rel="noopener"
>https://cloud.tencent.com/developer/article/1721905&lt;/a>&lt;/p>
&lt;h2 id="4-docker镜像打包并上传到阿里云镜像库ark">4 docker镜像打包并上传到阿里云镜像库ARK
&lt;/h2>&lt;p>将自己的镜像上传至阿里云：
阿里云提供容器镜像服务，我自己玩开通个人实例即可
&lt;a class="link" href="https://cr.console.aliyun.com/cn-shanghai/instances" target="_blank" rel="noopener"
>https://cr.console.aliyun.com/cn-shanghai/instances&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20230811150239.png"
loading="lazy"
>&lt;/p>
&lt;p>建立一个自己的仓库，然后就能看到示例说明，我们就能把自己的镜像上传了&lt;/p>
&lt;h3 id="41-将镜像推送到registry">4.1 将镜像推送到Registry
&lt;/h3>&lt;pre>&lt;code>$ docker login --username=*****@qq.com registry.cn-shanghai.aliyuncs.com
$ docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/******:[镜像版本号]
$ docker push registry.cn-shanghai.aliyuncs.com/******:[镜像版本号]
&lt;/code>&lt;/pre>
&lt;p>&lt;code>tag&lt;/code>是类似复制一份且重命名镜像，&lt;code>push&lt;/code>是上传（不知道为什么要重命名&lt;/p>
&lt;p>针对上面的3个镜像，分别是：&lt;code>node.js+git+hexo&lt;/code>,&lt;code>vsftpd&lt;/code>,&lt;code>ddns-go&lt;/code>
我分别tag成了：&lt;/p>
&lt;pre>&lt;code>registry-vpc.cn-shanghai.aliyuncs.com/******:debian_V02_configured #应该写成:hexo_debian_V02_configured的，漏了。。算了
registry-vpc.cn-shanghai.aliyuncs.com/******:vsftpd_debian_V01
registry-vpc.cn-shanghai.aliyuncs.com/******:ddns_go_V01
&lt;/code>&lt;/pre>
&lt;p>再分别&lt;code>push&lt;/code>即可&lt;/p>
&lt;h3 id="42-在阿里云上使用容器实例eci运行镜像">4.2 在阿里云上使用容器实例（ECI）运行镜像
&lt;/h3>&lt;p>阿里云ECI提供这个服务，你可以直接用现有的镜像也可以自己上传（就是上一步镜像服务里上传的镜像）按秒收费！不过作为hexo这种启用&amp;gt;生成&amp;gt;部署&amp;gt;关闭的服务来说，花不了几毛钱&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20230811151948.png"
loading="lazy"
>&lt;/p>
&lt;p>然后就能看到我们上传的镜像
&lt;img src="https://winotmk.github.io/images/20230811152250.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="5-eci容器创建模板和eci命令行工具使用">5 eci容器创建模板和eci命令行工具使用
&lt;/h2>&lt;p>参考文章这两篇足够:
&lt;a class="link" href="https://github.com/aliyuneci/eci-client-doc/blob/main/eci_run.md" target="_blank" rel="noopener"
>https://github.com/aliyuneci/eci-client-doc/blob/main/eci_run.md&lt;/a>
&lt;a class="link" href="https://help.aliyun.com/document_detail/186961.html" target="_blank" rel="noopener"
>https://help.aliyun.com/document_detail/186961.html&lt;/a>&lt;/p>
&lt;h3 id="51-eci简介">5.1 eci简介
&lt;/h3>&lt;p>&lt;a class="link" href="https://www.aliyun.com/product/eci" target="_blank" rel="noopener"
>https://www.aliyun.com/product/eci&lt;/a>
ECI是 Serverless 和容器化的弹性计算服务。您无需管理底层 ECS 服务器，只需要提供打包好的镜像，即可运行容器，与阿里云容器服务无缝对接并仅为容器实际运行消耗的资源付费。&lt;/p>
&lt;p>博主：比ECS云服务器灵活得多，本地用docker制作好镜像以后，上传，随启随用，用完就释放，成本可以很低,但如果连开一个月，并不会比ECS划算，详见本站&lt;a class="link" href="https://winotmk.github.io/Docker01.1_%E4%BB%B7%E6%A0%BC%E8%AE%A1%E7%AE%97%E8%A1%A8/" target="_blank" rel="noopener"
>ECI价格计算附表&lt;/a>&lt;/p>
&lt;h3 id="52-用模板创建eci">5.2 用模板创建eci
&lt;/h3>&lt;p>&lt;img src="https://winotmk.github.io/images/20230907171351.png"
loading="lazy"
>
询问过阿里云客服，说在web控制面版里的这个功能已经下线了
不过没关系，我们还有命令行工具！
安装：&lt;/p>
&lt;pre>&lt;code>sudo bash -c &amp;quot;$(curl -s https://eci-docs.oss-cn-beijing.aliyuncs.com/eci-client/1.0/install.sh)&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>然后配置你的阿里云信息&lt;/p>
&lt;pre>&lt;code>eci config set-context \
--access-key-id **** \
--access-secret **** \
--region-id cn-shanghai \
--security-group-id sg-**** \
--v-switch-id vsw-****
&lt;/code>&lt;/pre>
&lt;p>要指定自己的&lt;code>access-key-id&lt;/code>和&lt;code>access-secret&lt;/code>，地区以及安全组和虚拟交换机
建议这些东西在web上的控制台里准备好，会直观很多&lt;/p>
&lt;p>然后就可以直接创建一个容器了&lt;/p>
&lt;pre>&lt;code>eci run -n myeci centos:7 sleep 3600
&lt;/code>&lt;/pre>
&lt;p>指令很像&lt;code>docker run&lt;/code>喝！很好，很有精神&lt;/p>
&lt;p>我们还可以编写yaml模板文件
然后执行&lt;/p>
&lt;pre>&lt;code>eci run -f eci.yaml -w 20
&lt;/code>&lt;/pre>
&lt;p>需要注意的事，如果使用了&lt;code>-f xxxx.yaml&lt;/code>模板文件，除了-f和-w选项以外，其他选项都将被忽略，因为这些选项都是针对实例中某个容器的，如果模板中定义了多个容器，ECI将不知道这些选项应该作用于哪个容器
那么我自己的启动模板是这样的：
&lt;strong>&lt;i class="fas fa-file">&lt;/i>hexo_debian_eci.yaml&lt;/strong>&lt;/p>
&lt;pre>&lt;code>ContainerGroupName: eci-hexo
Cpu: &amp;quot;0.5&amp;quot;
Memory: &amp;quot;1&amp;quot;
Container:
- Name: hexo
Image: registry-vpc.cn-shanghai.aliyuncs.com/****:debian_V02_configured
Command: [&amp;quot;/bin/bash&amp;quot;,&amp;quot;/service_start.sh&amp;quot;]
ImagePullPolicy: IfNotPresent
Cpu: &amp;quot;0.5&amp;quot;
Memory: &amp;quot;1&amp;quot;
VolumeMount:
- Name: hexo
MountPath: /hexo
ReadOnly: false
- Name: vsftpd
Image: registry-vpc.cn-shanghai.aliyuncs.com/****:vsftpd_debian_V01
Command: [&amp;quot;/bin/bash&amp;quot;,&amp;quot;/service_start.sh&amp;quot;]
ImagePullPolicy: IfNotPresent
VolumeMount:
- Name: hexo
MountPath: /hexo
ReadOnly: false
- Name: ddns
Image: registry-vpc.cn-shanghai.aliyuncs.com/****:ddns_go_V01
ImagePullPolicy: IfNotPresent
EnvironmentVar:
- FieldRefFieldPath: &amp;quot;&amp;quot;
Key: DDNS_URL
Value: mdwrite.winotmk.com
Volume:
- Name: hexo
Type: NFSVolume
NFSVolume:
Server: ****.cn-shanghai.nas.aliyuncs.com
Path: /
ReadOnly: false
&lt;/code>&lt;/pre>
&lt;p>是不是挺像&lt;code>docker compose&lt;/code>~&lt;/p>
&lt;p>cpu只给了0.5,Memory 1G，足够了，之前这套可是在树莓派3B上跑得溜溜得呢
对于阿里云ECI，CPU和Memory直接和成本挂钩，能少就少吧&lt;/p>
&lt;p>这里启了上面做好的3个镜像，分别实现hexo，ftp，还有ddns
&lt;code>Command:&lt;/code>写法目测类似dockerfile里的&lt;code>CMD&lt;/code>，我习惯做好启动sh脚本就是为了方便这里再调用
最后一段声明了我的一个阿里云NAS卷，卷里的内容就是我的hexo目录
&lt;img src="https://winotmk.github.io/images/20230829142501.png"
loading="lazy"
>
然后把它挂到hexo和ftp镜像上就好了&lt;/p>
&lt;p>值得一提的是ddns镜像还写了个环境变量&lt;code>DDNS_URL&lt;/code>值为&lt;code>mdwrite.winotmk.com&lt;/code>，这会修改&lt;code>ddns-go&lt;/code>的解析配置&lt;/p>
&lt;p>然后执行&lt;/p>
&lt;pre>&lt;code>eci run -f hexo_debian_eci.yaml -w 20
&lt;/code>&lt;/pre>
&lt;p>不出意外的话会返回一个eci的id编号，打开web会发现已经创建成功了！
&lt;img src="https://winotmk.github.io/images/20230907174209.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="6-hexo本地编辑环境设置如何用vscode舒服的写md文档">6 hexo本地编辑环境设置————如何用VSCode舒服的写MD文档
&lt;/h2>&lt;h3 id="61-vscodessh-fs插件配置">6.1 VSCodeSSH FS插件配置
&lt;/h3>&lt;p>&lt;img src="https://winotmk.github.io/images/20230908113634.png"
loading="lazy"
>
简单配置一下服务器地址和用户密码就可以把远程目录映射到工作区里，很方便
&lt;img src="https://winotmk.github.io/images/20230908113824.png"
loading="lazy"
>
这里可以看到&lt;code>/root/hexo/Winblog&lt;/code>目录下是我挂载的阿里云NAS网盘了&lt;/p>
&lt;h3 id="62-markdown-paste插件配置">6.2 Markdown Paste插件配置
&lt;/h3>&lt;p>一个很方便的在VScode里直接粘图的插件&lt;/p>
&lt;h4 id="配置">配置：
&lt;/h4>&lt;p>&lt;img src="https://winotmk.github.io/images/20230908114845.png"
loading="lazy"
>
会用时间来命名图片
然后会将图片放入MD文件目录下的&lt;code>images&lt;/code>下&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20230908115038.png"
loading="lazy"
>&lt;/p>
&lt;p>然后文件》首选项》键盘快捷方式
&lt;img src="https://winotmk.github.io/images/20230908115303.png"
loading="lazy"
>
我将快捷键设置为&lt;code>ctrl+alt+a&lt;/code>
配置完成！&lt;/p>
&lt;h4 id="使用">使用：
&lt;/h4>&lt;p>截图我习惯用Sinpaste，按F1就能截图
&lt;img src="https://winotmk.github.io/images/20230908115743.png"
loading="lazy"
>
然后点右下角复制按钮
在VScode的markdown文档里&lt;code>ctrl+alt+a&lt;/code>就能粘图了！
&lt;img src="https://winotmk.github.io/images/20230908113947.png"
loading="lazy"
>
图片文件会自动保存!&lt;/p>
&lt;h3 id="62-vscode的sftp插件配置">6.2 VSCode的SFTP插件配置
&lt;/h3>&lt;p>先把images文件夹单独放到工作区里
然后在Ctrl+Shift+P打开命令面板，运行SFTP: config命令
sftp.json目录下会出现一个名为的基本配置文件.vscode
&lt;img src="https://winotmk.github.io/images/20230908121346.png"
loading="lazy"
>
然后编辑
&lt;strong>&lt;i class="fas fa-file">&lt;/i>sftp.json&lt;/strong>&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;name&amp;quot;: &amp;quot;Hexo_images&amp;quot;,
&amp;quot;host&amp;quot;: &amp;quot;mdwrite.winotmk.com&amp;quot;,
&amp;quot;protocol&amp;quot;: &amp;quot;ftp&amp;quot;,
&amp;quot;port&amp;quot;: 21,
&amp;quot;username&amp;quot;: &amp;quot;root&amp;quot;,
&amp;quot;password&amp;quot;: &amp;quot;****&amp;quot;,
&amp;quot;remotePath&amp;quot;: &amp;quot;/hexo/Winblog/source/images&amp;quot;,
&amp;quot;useTempFile&amp;quot;: false,
&amp;quot;openSsh&amp;quot;: false,
&amp;quot;uploadOnSave&amp;quot;: false,
&amp;quot;watcher&amp;quot;: {
&amp;quot;files&amp;quot;: &amp;quot;**/*&amp;quot;,
&amp;quot;autoUpload&amp;quot;: true,
&amp;quot;autoDelete&amp;quot;: true
},
&amp;quot;syncOption&amp;quot;: {
&amp;quot;delete&amp;quot;: true
}
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>&amp;quot;watcher&amp;quot;&lt;/code>是用来设置自动更新的
这样我们在md里粘了图，就会自动上传到到ftp目录上&lt;/p>
&lt;p>参考：
&lt;a class="link" href="https://marketplace.visualstudio.com/items?itemName=Natizyskunk.sftp#remote-explorer" target="_blank" rel="noopener"
>https://marketplace.visualstudio.com/items?itemName=Natizyskunk.sftp#remote-explorer&lt;/a>
开启watcher模式，实现增加文件时自动上传目录同步
&lt;a class="link" href="https://github.com/Natizyskunk/vscode-sftp/blob/master/FAQ.md#automatically-sync-both-ways-without-user-interaction" target="_blank" rel="noopener"
>https://github.com/Natizyskunk/vscode-sftp/blob/master/FAQ.md#automatically-sync-both-ways-without-user-interaction&lt;/a>&lt;/p></description></item><item><title>next主题增加近期文章侧边栏</title><link>https://winotmk.github.io/posts/next%E4%B8%BB%E9%A2%98%E5%A2%9E%E5%8A%A0%E8%BF%91%E6%9C%9F%E6%96%87%E7%AB%A0%E4%BE%A7%E8%BE%B9%E6%A0%8F/</link><pubDate>Thu, 27 Jul 2023 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/next%E4%B8%BB%E9%A2%98%E5%A2%9E%E5%8A%A0%E8%BF%91%E6%9C%9F%E6%96%87%E7%AB%A0%E4%BE%A7%E8%BE%B9%E6%A0%8F/</guid><description>&lt;h2 id="边栏显示文章列表效果">边栏显示文章列表效果
&lt;/h2>&lt;p>我还奇怪next没用提供这样的功能，文章一多一篇篇翻实在是累，还好找到了有人实现最近文章的功能，那么做文章列表也就同理了
&lt;img src="https://winotmk.github.io/images/20230727113321.png"
loading="lazy"
>
我修改过的代码
首先是：&lt;/p>
&lt;h3 id="sidebarnjk">sidebar.njk
&lt;/h3>&lt;p>&lt;code>/hexo-theme-next/layout/_macro/sidebar.njk&lt;/code>
在最后一个&lt;code>{% endif %}&lt;/code>后面加入&lt;/p>
&lt;pre>&lt;code> {% if theme.recent_posts.enable %}
&amp;lt;div class=&amp;quot;links-of-blogroll&amp;quot; style=&amp;quot;margin-top:20px; border-style:dotted none none none; padding-top:5px; text-align:left;padding-left: 20px; padding-right: 10px; padding-bottom: 5px;&amp;quot;&amp;gt;
&amp;lt;div class=&amp;quot;links-of-blogroll-title&amp;quot; style=&amp;quot;padding-bottom: 5px; padding-top: 5px; padding-left: 0px; padding-right: 20px; font-size: 1.6em; argin-right: 5px;&amp;quot;&amp;gt;
&amp;lt;!-- 选择合适的icon --&amp;gt;
{%- if theme.recent_posts.icon %}&amp;lt;i class=&amp;quot;{{ theme.recent_posts.icon }}&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;{%- endif %}
&amp;lt;b style=&amp;quot;font-size: 0.65em; padding-left: 8px; position: relative; top: -2px;&amp;quot;&amp;gt;{{ theme.recent_posts.description }}&amp;lt;/b&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;ul class=&amp;quot;links-of-blogroll-list&amp;quot;&amp;gt;
&amp;lt;!-- 文章排序规格,-updated 按照文章更新时间倒排 --&amp;gt;
{% set posts = site.posts.sort('-updated').toArray() %}
&amp;lt;!-- 显示20数目的文章 --&amp;gt;
{% for post in posts.slice('0','20') %}
&amp;lt;li class=&amp;quot;postsSidebarNumb&amp;quot; style=&amp;quot;text-indent: -1em;&amp;quot;&amp;gt;
&amp;lt;a href=&amp;quot;{{ url_for(post.path) }}&amp;quot; title=&amp;quot;{{ post.title }}&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt;
&amp;lt;/li&amp;gt;
{% endfor %}
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
{% endif %}
&lt;/code>&lt;/pre>
&lt;!-- more -->
&lt;p>出于美观我把一些css代码内嵌进去了其实不推荐这样做（寄&lt;/p>
&lt;h3 id="_configyml">_config.yml
&lt;/h3>&lt;p>&lt;code>/hexo-theme-next/_config.yml&lt;/code>&lt;/p>
&lt;pre>&lt;code># 近期文章配置
recent_posts:
enable: true
icon: fab fa-markdown
description: 文章列表
&lt;/code>&lt;/pre>
&lt;h3 id="mainstyl">main.styl
&lt;/h3>&lt;p>&lt;code>/hexo-theme-next/source/css/main.styl&lt;/code>
是因为我想给文章列表加上计数，直接在css里用伪类做（要不是伪类不能html内嵌写进去我也不写这里&lt;/p>
&lt;pre>&lt;code>//侧边栏计数伪类
body {
counter-reset: postsSidebarNumbsection;
}
.postsSidebarNumb::before {
counter-increment: postsSidebarNumbsection;
content: counter(postsSidebarNumbsection) &amp;quot;: &amp;quot;;
}
&lt;/code>&lt;/pre>
&lt;h2 id="一些搜集资料">一些搜集资料
&lt;/h2>&lt;p>ps在查找的过程中发现提到这些的多半是next主题，而且别人的next主题都挺有意思的啊想搬！（爬&lt;/p>
&lt;h3 id="资料01hexo博客7给next主题添加最新文章模块">资料01：Hexo博客：(7)给NexT主题添加最新文章模块
&lt;/h3>&lt;p>首先是这篇
&lt;a class="link" href="https://pickear.github.io/2020/04/12/Hexo%E5%8D%9A%E5%AE%A2%EF%BC%9A-7-%E7%BB%99NexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%9C%80%E6%96%B0%E6%96%87%E7%AB%A0%E6%A8%A1%E5%9D%97%20-%20%E5%89%AF%E6%9C%AC/" target="_blank" rel="noopener"
>https://pickear.github.io/2020/04/12&lt;/a>
提到了：
next/layout/_macro/sidebar.swig ,这个负责渲染侧边栏。在sidebar.swig的if theme.links的end if后面添加以下代码:&lt;/p>
&lt;pre>&lt;code>{% if theme.recent_posts %}
&amp;lt;div class=&amp;quot;links-of-blogroll motion-element {{ &amp;quot;links-of-blogroll-&amp;quot; + theme.recent_posts_layout }}&amp;quot;&amp;gt;
&amp;lt;div class=&amp;quot;links-of-blogroll-title&amp;quot;&amp;gt;
&amp;lt;!-- modify icon to fire by szw --&amp;gt;
&amp;lt;i class=&amp;quot;fa fa-history fa-{{ theme.recent_posts_icon | lower }}&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
{{ theme.recent_posts_title }}
&amp;lt;/div&amp;gt;
&amp;lt;ul class=&amp;quot;links-of-blogroll-list&amp;quot;&amp;gt;
{% set posts = site.posts.sort('-date') %}
{% for post in posts.slice('0', '5') %}
&amp;lt;li&amp;gt;
&amp;lt;a href=&amp;quot;{{ url_for(post.path) }}&amp;quot; title=&amp;quot;{{ post.title }}&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt;
&amp;lt;/li&amp;gt;
{% endfor %}
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
{% endif %}
&lt;/code>&lt;/pre>
&lt;p>然后在NexT主题目录下的_config.yaml配置文件，添加下面配置:&lt;/p>
&lt;pre>&lt;code>recent_posts_title: 最新文章
recent_posts_layout: block
recent_posts: true
&lt;/code>&lt;/pre>
&lt;p>然而实际效果是只会显示“最新文章”几个字
&lt;img src="https://winotmk.github.io/images/20230727111720.png"
loading="lazy"
>
查了得知&lt;/p>
&lt;blockquote>
&lt;p>NexT 的架構檔案格式從 swig 改成 njk，照著舊的文章貼上不會成功&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h3 id="资料02day33-hexo-x-next---顯示最新文章導入google-analytics-的坑">资料02：[Day33] Hexo x NexT - 顯示最新文章、導入Google Analytics 的坑
&lt;/h3>&lt;p>接着是这篇，感谢提到了next主题架构更变的问题
&lt;a class="link" href="https://ithelp.ithome.com.tw/articles/10283488?sc=iThomeR" target="_blank" rel="noopener"
>https://ithelp.ithome.com.tw/articles/10283488?sc=iThomeR&lt;/a>&lt;/p>
&lt;p>&lt;em>左側選單顯示最新文章&lt;/em>&lt;/p>
&lt;p>NexT 已經有 hexo-related-popular-posts 套件來顯示最新文章列表的功能，但是這個套件似乎沒辦法正常運作，網路上有不少教學文章，但是 NexT 的架構檔案格式從 swig 改成 njk，照著舊的文章貼上不會成功，設定步驟如下：&lt;/p>
&lt;p>在 sidebar.njk 檔案裡面加入下段程式碼（跟 swig 版本就只差了一個 .toArray() ）&lt;/p>
&lt;pre>&lt;code>{%- if theme.recent_posts %}
&amp;lt;div class=&amp;quot;links-of-blogroll motion-element {{ &amp;quot;links-of-blogroll-&amp;quot; + theme.recent_posts_layout }}&amp;quot;&amp;gt;
&amp;lt;div class=&amp;quot;links-of-blogroll-title&amp;quot;&amp;gt;
&amp;lt;!-- 設定你要的fa fa icon--&amp;gt;
&amp;lt;i class=&amp;quot;fa fa-history fa-{{ theme.recent_posts_icon | lower }}&amp;quot; aria-hidden=&amp;quot;true&amp;quot; style=&amp;quot;margin: 1rem 0.25rem 0.5rem 0&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
{{ theme.recent_posts_title }}
&amp;lt;/div&amp;gt;
&amp;lt;ul class=&amp;quot;links-of-blogroll-list&amp;quot;&amp;gt;
{%- set posts = site.posts.sort('-date') %}
{%- for post in posts.slice('0', '5').toArray() %}
&amp;lt;li&amp;gt;
&amp;lt;a href=&amp;quot;{{ url_for(post.path) }}&amp;quot; title=&amp;quot;{{ post.title }}&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt;
&amp;lt;/li&amp;gt;
{%- endfor %}
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
{%- endif %}
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h3 id="资料03-hexo-next-后续优化">资料03: Hexo-NexT 后续优化
&lt;/h3>&lt;p>&lt;a class="link" href="https://blog.yileaf.com/posts/15baca53/" target="_blank" rel="noopener"
>https://blog.yileaf.com/posts/15baca53/&lt;/a>
我最后使用的基本上参考了这篇的代码&lt;/p>
&lt;p>&lt;em>侧边栏添加近期文章&lt;/em>
1.打开&lt;code>blog\source\_data\sidebar.njk&lt;/code>文件，加入以下代码：&lt;/p>
&lt;pre>&lt;code>{% if theme.recent_posts.enable %}
&amp;lt;div class=&amp;quot;links-of-blogroll&amp;quot;&amp;gt;
&amp;lt;div class=&amp;quot;links-of-blogroll-title&amp;quot;&amp;gt;
&amp;lt;!-- 选择合适的icon --&amp;gt;
{%- if theme.recent_posts.icon %}&amp;lt;i class=&amp;quot;{{ theme.recent_posts.icon }}&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;{%- endif %}
{{ theme.recent_posts.description }}
&amp;lt;/div&amp;gt;
&amp;lt;ul class=&amp;quot;links-of-blogroll-list&amp;quot;&amp;gt;
&amp;lt;!-- 文章排序规格,-updated 按照文章更新时间倒排 --&amp;gt;
{% set posts = site.posts.sort('-updated').toArray() %}
&amp;lt;!-- 显示四条近期文章 --&amp;gt;
{% for post in posts.slice('0', '4') %}
&amp;lt;li&amp;gt;
&amp;lt;a href=&amp;quot;{{ url_for(post.path) }}&amp;quot; title=&amp;quot;{{ post.title }}&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt;
&amp;lt;/li&amp;gt;
{% endfor %}
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
{% endif %}
&lt;/code>&lt;/pre>
&lt;p>2.主题config.yml&lt;/p>
&lt;pre>&lt;code># 近期文章配置
recent_posts:
enable: true
icon: fas fa-history
description: 近期文章
&lt;/code>&lt;/pre></description></item><item><title>Archives</title><link>https://winotmk.github.io/archives/</link><pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/archives/</guid><description/></item><item><title>批处理实现批量改名以及SVN批量改名</title><link>https://winotmk.github.io/posts/bat/</link><pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/bat/</guid><description>&lt;h2 id="需求">需求
&lt;/h2>&lt;p>{% asset_img 20211214_123317_Snipaste.png %}&lt;/p>
&lt;p>注意Mesh和Texture前加了编号&lt;/p>
&lt;p>工作需要整理目录文件，要将多组资产目录（Assets01,Assets02,Assets03&amp;hellip;内的Resource目录下的Texture和Mesh目录加编号)&lt;/p>
&lt;p>感觉这是一个可以用批处理脚本做到的事情，所以稍微研究了一下&lt;/p>
&lt;h2 id="改名实现">改名实现
&lt;/h2>&lt;p>如果单只是改名其实很简单，只需要几行即可实现：&lt;/p>
&lt;pre>&lt;code class="language-bat">@echo off
for /f &amp;quot;delims=&amp;quot; %%a in ('dir /ad/s/b &amp;quot;Mesh&amp;quot;') do ren &amp;quot;%%~a&amp;quot; 01-Mesh
for /f &amp;quot;delims=&amp;quot; %%b in ('dir /ad/s/b &amp;quot;Texture&amp;quot;') do ren &amp;quot;%%~b&amp;quot; 00-Texture
pause
&lt;/code>&lt;/pre>
&lt;!-- more -->
&lt;p>&lt;code>@echo off&lt;/code>打开批处理黑窗口&lt;/p>
&lt;p>&lt;code>for in do&lt;/code>常用在查找匹配，满足条件后执行&lt;/p>
&lt;p>&lt;code>dir /ad/s/b &amp;quot;Mesh&amp;quot;&lt;/code>这行可以参考&lt;code>dir&lt;/code>命令的用法，&lt;code>/ab&lt;/code>在这里是只显示目录（如果是要显示文件是&lt;code>/a-d&lt;/code>）&lt;code>/s&lt;/code>显示目录和包含子目录，&lt;code>/b&lt;/code>不显示日期大小等其他信息，&lt;code>&amp;quot;Mesh&amp;quot;&lt;/code>会列出包含Mesh目录&lt;/p>
&lt;p>&lt;code>pause&lt;/code>这里会暂停一下按任意键继续&lt;/p>
&lt;p>所以连起来就是列出包含Mesh和Texture的目录，然后用&lt;code>ren&lt;/code>改名&lt;/p>
&lt;h2 id="svn-rename批处理">SVN Rename批处理
&lt;/h2>&lt;p>然而上面的简单改名这对于我遇到的实际情况不理想，有些资源是在SVN目录库里的，对于SVN来说，直接用&lt;code>ren&lt;/code>等于删除Mesh旧目录，再新添加一个00-Mesh新目录，这会来带几个问题：&lt;/p>
&lt;ul>
&lt;li>log丢失，历史版本找不回来&lt;/li>
&lt;li>如果文件多，占用空间很大，浪费大家带宽（每个人update会重新下载一遍）&lt;/li>
&lt;/ul>
&lt;p>所以最好是用SVN的命令来进行操作&lt;/p>
&lt;p>然后发现用&lt;code>svn mv oldname newname&lt;/code>就能完成&lt;/p>
&lt;pre>&lt;code class="language-bat">svn mv Mesh 00-Mesh
&lt;/code>&lt;/pre>
&lt;p>移动，重命名，对svn来说都是这一个命令&lt;/p>
&lt;p>所以大致思路就是用&lt;code>for in do&lt;/code>来找到Mesh和Texture文件夹，然后用变量来做oldname和newname&lt;/p>
&lt;pre>&lt;code class="language-bat">@echo off
setlocal EnableDelayedExpansion
for /f &amp;quot;delims=&amp;quot; %%b in ('dir /ad/s/b &amp;quot;Mesh&amp;quot;') do (
set &amp;quot;oldm=%%b&amp;quot;
set &amp;quot;newm=!oldm:Mesh=00_Mesh!&amp;quot;
echo ------旧Mesh目录名称
echo !oldm!
echo ------新Mesh目录名称
echo !newm!
echo ------Mesh改名中...
svn mv !oldm! !newm!
)
for /f &amp;quot;delims=&amp;quot; %%b in ('dir /ad/s/b &amp;quot;Texture&amp;quot;') do (
set &amp;quot;oldt=%%b&amp;quot;
set &amp;quot;newt=!oldt:Texture=01_Texture!&amp;quot;
echo ------旧Texture目录名称
echo !oldt!
echo ------新Texture目录名称
echo !newt!
echo ------Texture改名中...
svn mv !oldt! !newt!
)
pause
&lt;/code>&lt;/pre>
&lt;p>一开始卡在变量这块很久，最后发现一定要有&lt;code>setlocal EnableDelayedExpansion&lt;/code>，然后变量才可以在&lt;code>do()&lt;/code>里用&lt;code>!oldm!&lt;/code>这样，而不能用&lt;code>%oldm%&lt;/code>&lt;/p>
&lt;p>&lt;code>set &amp;quot;newm=!oldm:Mesh=00_Mesh!&amp;quot;&lt;/code>这行的操作是字符串替换，举例来说此时&lt;code>!oldm!&lt;/code>为&lt;code>C:\Users\winte\Desktop\project\Assets01\Resource\Mesh&lt;/code>&lt;/p>
&lt;p>会将此段字符串中的&lt;code>Mesh&lt;/code>替换为&lt;code>00_Mesh&lt;/code>,得到&lt;/p>
&lt;p>&lt;code>C:\Users\winte\Desktop\project\Assets01\Resource\00_Mesh&lt;/code>&lt;/p>
&lt;p>然后是一些交互上的完善，有个用到的结构&lt;/p>
&lt;pre>&lt;code class="language-bat">@echo off
echo 如需要撤销操作请按r,按其他任意键退出...
set /p a=请输入r后回车:
if &amp;quot;%a%&amp;quot;==&amp;quot;r&amp;quot; Goto abc
exit /b
:abc
....
&lt;/code>&lt;/pre>
&lt;p>这里有个判断，如果按下了r键，会触发&lt;code>Goto abc&lt;/code>，然后跳转到&lt;code>:abc&lt;/code>以下的脚本，否则会直接走&lt;code>exit /b&lt;/code>退出脚本，很实用&lt;/p>
&lt;h2 id="一些tips">一些Tips
&lt;/h2>&lt;ul>
&lt;li>将变量与批处理中的另一个变量的一部分匹配&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.thinbug.com/q/19056911" target="_blank" rel="noopener"
>https://www.thinbug.com/q/19056911&lt;/a>&lt;/p>
&lt;p>测试这段是好用的，用来检测一段字符串是否含有一段字符串&lt;/p>
&lt;pre>&lt;code class="language-bat">@echo off
set &amp;quot;h=Hello-World&amp;quot;
set &amp;quot;f=This is a Hello-World test&amp;quot;
call set &amp;quot;a=%%f:%h%=%%&amp;quot;
if not &amp;quot;%a%&amp;quot;==&amp;quot;%f%&amp;quot; goto :done
pause
exit /b
:done
echo it matched
pause
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>一个ping通隔段时间再ping，ping不通就关机的例子
&lt;a class="link" href="http://www.bathome.net/thread-12490-1-1.html" target="_blank" rel="noopener"
>http://www.bathome.net/thread-12490-1-1.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bat">@echo off
:open
ping 192.168.1.90
if %ERRORLEVEL%==0 goto Ok
if %ERRORLEVEL%==1 goto No
exit
:No
cls&amp;amp;echo 不通!关机操作
shutdown -s -f -t 5000
::5000秒后关机
exit
:Ok
cls&amp;amp;echo.通，10分钟后再监测，请勿关闭本窗口
ping 127.0.1 /n 600 &amp;gt;nul
::600秒后执行检测
goto open
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>如果要检测的是上段脚本执行以后的返回值，可以用到&lt;code>%ERRORLEVEL%&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.jianshu.com/p/5e72aed76b71" target="_blank" rel="noopener"
>https://www.jianshu.com/p/5e72aed76b71&lt;/a>&lt;/p>
&lt;p>不过&lt;code>%ERRORLEVEL%&lt;/code>返回的是个数值，成功执行是0，不成功执行是非0，但是我用作svn命令执行判断的时候发现，有些指令即便不成功执行也返回0？懒得深究&lt;/p>
&lt;ul>
&lt;li>找到另外一种方法直接判断返回的字符串&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/hadsdn/article/details/78957361" target="_blank" rel="noopener"
>https://blog.csdn.net/hadsdn/article/details/78957361&lt;/a>&lt;/p></description></item><item><title>SourceCraft服务器</title><link>https://winotmk.github.io/posts/mc/</link><pubDate>Sun, 07 Nov 2021 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/mc/</guid><description>&lt;p>{% asset_img 20211107_114809_QQ_20211107114745.png %}&lt;/p>
&lt;p>Java服务器地址：mc.winotmk.com:25465
基岩服务器地址：mc.winotmk.com:19132&lt;/p>
&lt;p>网站：
Web地图：&lt;a class="link" href="http://mcmap.winotmk.com" target="_blank" rel="noopener"
>http://mcmap.winotmk.com&lt;/a>&lt;/p>
&lt;!-- more -->
&lt;h2 id="服务器概况">服务器概况
&lt;/h2>&lt;p>目前版本：spigot-1.20.1
自有服务器，计划长期开服，主世界不清档，视情况可以增加副世界
使用了Geyser插件，实现基岩版和Java版本同服，支持多种客户端，可以在手机和电脑上同时玩 &lt;del>（主机也行没测过&lt;/del>&lt;/p>
&lt;p>开服日期：2021-11-07
容器化上云: 2023-08-25&lt;/p>
&lt;p>世界结构：
Lobby
MainWorld -Nether -TheEnd
LyhWorld&lt;/p>
&lt;p>{% asset_img 20211118_131504__Map.jpg %}&lt;/p>
&lt;p>现有传送门：&lt;/p>
&lt;ol>
&lt;li>Lobby去塔顶&lt;/li>
&lt;li>Lobby去主世界（主传送门）&lt;/li>
&lt;li>Lobby去lyh存档世界&lt;/li>
&lt;li>主世界往返湖边村落&lt;/li>
&lt;/ol>
&lt;h2 id="更新log">更新log
&lt;/h2>&lt;p>&lt;strong>2023-08-25&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>版本由spigot-1.17.1更新至spigot-1.20.1&lt;/li>
&lt;li>运行环境eci内运行，服务器文件nas上存储，环境和数据分离&lt;/li>
&lt;li>服务器版本更新至1.20.1（顺带更新对应插件版本）
禁用如下插件：&lt;/li>
&lt;li>PlaceholderAPI&lt;/li>
&lt;li>MiaoChat(被曝有后门)&lt;/li>
&lt;li>wolfyutilities&lt;/li>
&lt;li>ServerMinimap(似乎没啥用)&lt;/li>
&lt;li>Dynmap(web端地图，性能消耗巨大，体积巨大，暂移除)&lt;/li>
&lt;/ul>
&lt;h2 id="常用玩家命令">常用玩家命令
&lt;/h2>&lt;p>按T输入文本&lt;/p>
&lt;p>&lt;strong>第一次进服务器需要注册&lt;/strong>&lt;/p>
&lt;pre>&lt;code>/reg 密码 密码
&lt;/code>&lt;/pre>
&lt;p>登录&lt;/p>
&lt;pre>&lt;code>/l 密码
&lt;/code>&lt;/pre>
&lt;p>回主城lobby&lt;/p>
&lt;pre>&lt;code>/spawn
&lt;/code>&lt;/pre>
&lt;p>回家（上次认得床）&lt;/p>
&lt;pre>&lt;code>/home
&lt;/code>&lt;/pre>
&lt;p>回上次移动的地方（或上次死的地方)&lt;/p>
&lt;pre>&lt;code>/back
&lt;/code>&lt;/pre>
&lt;p>移动到玩家身边（需要对方确认)&lt;/p>
&lt;pre>&lt;code>/tpa 玩家名
&lt;/code>&lt;/pre>
&lt;h2 id="开始">开始
&lt;/h2>&lt;p>首先选择一个版本
如果你买过Windows版、主机，iPad之类的版本，可以选择基岩版
或者在windows和MAC上玩Java版&lt;/p>
&lt;p>{% asset_img 20211118132752.png %}&lt;/p>
&lt;p>附上Windows游戏购买链接
java：&lt;a class="link" href="https://www.minecraft.net/zh-hans/store/minecraft-java-edition" target="_blank" rel="noopener"
>https://www.minecraft.net/zh-hans/store/minecraft-java-edition&lt;/a>
基岩：&lt;a class="link" href="https://www.minecraft.net/zh-hans/store/minecraft-windows10" target="_blank" rel="noopener"
>https://www.minecraft.net/zh-hans/store/minecraft-windows10&lt;/a>&lt;/p>
&lt;h3 id="java版连接服务器">Java版连接服务器
&lt;/h3>&lt;h4 id="如果购买过正版java版本">如果购买过正版java版本
&lt;/h4>&lt;p>直接进多人游戏输入服务器地址&lt;code>mc.winotmk.com:25465&lt;/code>即可&lt;/p>
&lt;h4 id="如果没有购买">如果没有购买
&lt;/h4>&lt;p>这里提供原版纯净客户端：&lt;/p>
&lt;p>链接：&lt;a class="link" href="https://pan.baidu.com/s/1dl3mBgqhmvxPGMNVG2bRgw" target="_blank" rel="noopener"
>https://pan.baidu.com/s/1dl3mBgqhmvxPGMNVG2bRgw&lt;/a>
提取码：lijt&lt;/p>
&lt;h4 id="下载java运行环境">下载java运行环境
&lt;/h4>&lt;p>&lt;a class="link" href="https://www.oracle.com/java/technologies/downloads/#jdk17-windows" target="_blank" rel="noopener"
>https://www.oracle.com/java/technologies/downloads/#jdk17-windows&lt;/a>&lt;/p>
&lt;h4 id="下载客户端">下载客户端
&lt;/h4>&lt;p>运行HMCL登陆器&lt;/p>
&lt;p>登录方式选离线模即可，写个名字，即游玩服务器时的名字&lt;/p>
&lt;p>{% asset_img 20211107_164216___20211107164202.png %}&lt;/p>
&lt;p>ps.如果启动失败请确保使用了java17&lt;/p>
&lt;p>{% asset_img 20211107_165918___20211107164459.png %}&lt;/p>
&lt;p>进游戏选择&lt;/p>
&lt;p>{% asset_img 20211107_164108___20211107164032.png %}&lt;/p>
&lt;p>&lt;strong>第一次进服务器需要按T&lt;/strong>&lt;/p>
&lt;p>&lt;strong>然后输入/reg 密码 密码&lt;/strong>&lt;/p>
&lt;p>注册&lt;/p>
&lt;p>enjoy！&lt;/p>
&lt;h3 id="基岩版连接服务器">基岩版连接服务器
&lt;/h3>&lt;p>启动游戏选服务器，添加服务器&lt;/p>
&lt;p>{% asset_img 20211107_205807_QQ_20211107205503.png %}&lt;/p>
&lt;p>然后输入地址mc.winotmk.com端口19132&lt;/p>
&lt;p>{% asset_img 20211107_205827_QQ_20211107205427.png %}&lt;/p>
&lt;h2 id="服务器插件列表">服务器插件列表
&lt;/h2>&lt;p>以下部分玩家有兴趣可看&lt;/p>
&lt;p>插件有功能类和玩法类多种，简单记录一下目前所有的插件&lt;/p>
&lt;ol>
&lt;li>ActionHealth&lt;/li>
&lt;li>AncientGates&lt;/li>
&lt;li>AureliumSkills-Beta1.1.4&lt;/li>
&lt;li>BlockLocker&lt;/li>
&lt;li>&lt;del>BossShopPro&lt;/del>&lt;/li>
&lt;li>CatSeedLogin-1.3.9&lt;/li>
&lt;li>&lt;del>Dynmap-3.2.1-spigot&lt;/del>&lt;/li>
&lt;li>EssentialsX-2.19.0&lt;/li>
&lt;li>EssentialsXChat-2.19.0&lt;/li>
&lt;li>EssentialsXSpawn-2.19.0&lt;/li>
&lt;li>Geyser-Spigot_基岩转发&lt;/li>
&lt;li>&lt;del>GiftPack&lt;/del>&lt;/li>
&lt;li>GSit&lt;/li>
&lt;li>LuckPerms-Bukkit-5.3.47&lt;/li>
&lt;li>&lt;del>MiaoChat&lt;/del>&lt;/li>
&lt;li>NekoMaid&lt;/li>
&lt;li>PocketGames&lt;/li>
&lt;li>Residence5.0.0.4&lt;/li>
&lt;li>&lt;del>ServerMinimap&lt;/del>&lt;/li>
&lt;li>Tree Feller-V2.2&lt;/li>
&lt;li>Multiverse&lt;/li>
&lt;/ol>
&lt;p>API前置类&lt;/p>
&lt;ol>
&lt;li>CMILib1.0.4.2_圈地前置&lt;/li>
&lt;li>&lt;del>PlaceholderAPI-2.10.10&lt;/del>&lt;/li>
&lt;li>SmartInvs-1.2.7&lt;/li>
&lt;li>Vault&lt;/li>
&lt;li>Uniporter-1.3.2_Web管理前置&lt;/li>
&lt;li>&lt;del>wolfyutilities-1.7.2.0&lt;/del>&lt;/li>
&lt;/ol>
&lt;h4 id="actionhealth">ActionHealth
&lt;/h4>&lt;p>{% asset_img 20211107_103036_77a753a3753ee2059b26bcd92b4c7a7d435c2a3e.png %}
在物品栏上显示血量
&lt;a class="link" href="https://www.spigotmc.org/resources/action-bar-health.2661/" target="_blank" rel="noopener"
>https://www.spigotmc.org/resources/action-bar-health.2661/&lt;/a>&lt;/p>
&lt;h4 id="ancientgates">AncientGates
&lt;/h4>&lt;p>传送门&lt;/p>
&lt;p>基础用法：
本插件可以传送一切实体，包括玩家、运输工具、实体都能进入传送门
这个插件不仅能跨服务器传送实体和输入指令，而且可以在进入另一个服务器时输入指令
指令非常简单
首先，需要输入指令打开功能：/gate setconf bungeeCordSupport true
接下来你就可以使用任何关于BC的指令，创建传送门方法与普通的方法几乎无异
/gate setto [id] [服务器] - 设置传送到的目的地
/gate setbungeetype [id] [LOCATION/SERVER] - 在本地服务器上设置传送类型
/gate addto [id] [服务器] - 添加传送到的服务器
/gate remto [id] [服务器] - 删除可以传送到的服务器&lt;/p>
&lt;p>&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=584063" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=584063&lt;/a>&lt;/p>
&lt;h4 id="aureliumskills">AureliumSkills
&lt;/h4>&lt;p>技能系统&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>15 种独特的技能 (耕作Farming, 锻造Foraging, 挖矿Mining, 钓鱼Fishing, 采掘(旧版本翻译为掘土)Excavation, 箭术Archery, 防御Defense, 战斗Fighting, 耐力Endurance, 敏捷Agility, 炼金Alchemy, 附魔Enchanting, 巫术Sorcery, 治愈Healing, 以及锻造Forging)&lt;/li>
&lt;li>6 种玩家属性 (生命Health, 力量Strength, 再生Regeneration, 幸运Luck, 智慧Wisdom, 以及韧性Toughness)&lt;/li>
&lt;li>简洁明了, 能显示详细信息的 GUI&lt;/li>
&lt;li>能够自定义物品和盔甲上的特殊属性&lt;/li>
&lt;li>自定义打怪, 采集和钓鱼获得的特殊物品(掉落表/道具池, 原文为 Loot Table)&lt;/li>
&lt;li>经验值来源及大小均可修改,Beta 1.1.1以后不再支持 MythicMobs 自定义怪物作为经验来源&lt;/li>
&lt;li>多语言支持&lt;/li>
&lt;li>ActionBar 与 BossBar 位置显示&lt;/li>
&lt;li>可供开发者使用的 API&lt;/li>
&lt;li>支持 MySQL&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;p>/skills 或 /skill 或 /sk - 打开技能菜单,详见MCBBS
MCbbs搬运：&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=1094927" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=1094927&lt;/a>
&lt;a class="link" href="https://www.spigotmc.org/resources/aurelium-skills-advanced-skills-stats-abilities-and-more.81069/" target="_blank" rel="noopener"
>https://www.spigotmc.org/resources/aurelium-skills-advanced-skills-stats-abilities-and-more.81069/&lt;/a>&lt;/p>
&lt;h4 id="blocklocker">BlockLocker
&lt;/h4>&lt;p>{% asset_img 20211107_111619_41f1202f45cd6bc7d4f8574c9e32ec12d9b92aef.png %}&lt;/p>
&lt;p>上锁插件&lt;/p>
&lt;p>&lt;strong>使用方法&lt;/strong>&lt;/p>
&lt;p>&lt;strong>1. 放置木牌&lt;/strong>
对于容器类: 只需放置木牌即可,[私有]和玩家名会被自动生成.
对于门类: 放置木牌在门上或周围的方块上即可,内容会自动生成.&lt;/p>
&lt;p>其他:你也可以自己添加锁定信息,按照生成木牌的格式填写即可~&lt;/p>
&lt;p>&lt;strong>2.编辑木牌&lt;/strong>
右击木牌,输入&amp;quot;/blocklocker &amp;lt;行数&amp;gt; &amp;lt;文本&amp;gt;&amp;ldquo;来编辑木牌.
指令简写: &amp;ldquo;/bl&amp;rdquo; = &amp;ldquo;/blocklocker&amp;rdquo;,方法为: &amp;ldquo;/bl &amp;lt;行数&amp;gt; &amp;lt;文本&amp;gt;&amp;rdquo;.
可添加其他字符来避免被识别为玩家名,例如 &amp;ldquo;~&amp;rdquo;.&lt;/p>
&lt;p>&lt;strong>3.信任其他玩家&lt;/strong>
在第二步的 &amp;lt;文本&amp;gt; 内容中添加你要信任的玩家名即可.
如果想添加两个以上的玩家名,再放置一个木牌即可,内容会自动添加.
第二个木牌添加内容 &amp;ldquo;‘[更多使用者]’ ‘[所有人]’&amp;rdquo;.
&amp;ldquo;[所有人]&amp;ldquo;标签将允许所有人访问容器.请更改.&lt;/p>
&lt;p>MCbbs搬运：&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=1173296" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=1173296&lt;/a>
&lt;a class="link" href="https://www.spigotmc.org/resources/blocklocker.3268/" target="_blank" rel="noopener"
>https://www.spigotmc.org/resources/blocklocker.3268/&lt;/a>&lt;/p>
&lt;h4 id="bossshoppro">&lt;del>BossShopPro&lt;/del>
&lt;/h4>&lt;p>已移除
商店系统&lt;/p>
&lt;p>&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=829068" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=829068&lt;/a>
商店页面编辑器：&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=1273221" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=1273221&lt;/a>&lt;/p>
&lt;h4 id="catseedlogin">CatSeedLogin
&lt;/h4>&lt;p>{% asset_img 20211107_112829_171910d8x8aft4h64fczc7.png %}&lt;/p>
&lt;p>种子猫登录插件
基岩入口和java入口都关闭了正版验证，所以加了登录插件来管理玩家的账号，此插件备选可替换AuthMe&lt;/p>
&lt;blockquote>
&lt;p>登录
    /login 密码
    /l 密码
注册密码
  /register 密码 重复密码
  /reg 密码 重复密码
修改密码
  /changepassword 旧密码 新密码 重复新密码
  /changepw 旧密码 新密码 重复新密码&lt;/p>
&lt;p>绑定邮箱  
/bindemail set 邮箱  
/bdmail set 邮箱
用邮箱收到的验证码完成绑定  
/bindemail verify 验证码  
/bdmail verify 验证码
忘记密码，请求服务器给自己绑定的邮箱发送重置密码的验证码
  /resetpassword forget  /repw forget
用邮箱收到的验证码重置密码
  /resetpassword re 验证码 新密码
  /repw re 验证码 新密码&lt;/p>&lt;/blockquote>
&lt;p>MCBBS:&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=847859" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=847859&lt;/a>&lt;/p>
&lt;h4 id="dynmap">&lt;del>Dynmap&lt;/del>
&lt;/h4>&lt;p>{% asset_img 20211107_120618_QQ_20211107120538.png %}&lt;/p>
&lt;p>20230825更新：会消耗过多云服务资源暂移除&lt;/p>
&lt;p>Web端卫星地图，还可3d显示，实时显示在线玩家位置，上帝视角&lt;/p>
&lt;p>Mcbbs:&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=990539" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=990539&lt;/a>
&lt;a class="link" href="https://dynmap.us/builds/dynmap/" target="_blank" rel="noopener"
>https://dynmap.us/builds/dynmap/&lt;/a>&lt;/p>
&lt;h4 id="essentialsx">EssentialsX
&lt;/h4>&lt;p>系列管理插件&lt;/p>
&lt;p>&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=619883" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=619883&lt;/a>&lt;/p>
&lt;h4 id="geyser-spigot">Geyser-Spigot
&lt;/h4>&lt;p>{% asset_img 20211107_122221_171511lt5zn1n8hash1d8z.png.thumb.jpg %}&lt;/p>
&lt;p>该插件让基岩版玩家可以进入本服务器&lt;/p>
&lt;p>&lt;a class="link" href="https://geysermc.org/" target="_blank" rel="noopener"
>https://geysermc.org/&lt;/a>
&lt;a class="link" href="https://www.mcbbs.net/thread-973002-1-1.html" target="_blank" rel="noopener"
>https://www.mcbbs.net/thread-973002-1-1.html&lt;/a>&lt;/p>
&lt;h4 id="giftpack">&lt;del>GiftPack&lt;/del>
&lt;/h4>&lt;p>已移除
礼包插件&lt;/p>
&lt;p>&lt;a class="link" href="https://www.mcbbs.net/thread-1141658-1-1.html" target="_blank" rel="noopener"
>https://www.mcbbs.net/thread-1141658-1-1.html&lt;/a>&lt;/p>
&lt;h4 id="gsit">GSit
&lt;/h4>&lt;p>{% asset_img 20211107_124600_032148vqs1sp8y86p8k6pk.jpg.thumb.jpg %}&lt;/p>
&lt;p>座椅子插件&lt;/p>
&lt;p>/gsit(/sit) 坐在方块上
/glgy(/lay) 躺在方块上
/gcrawl(/crawl) 趴在方块上
/gsittoggle(/sittoggle) 开关右键坐下
/gsitreload(/gsitrl) 重载插件配置&lt;/p>
&lt;p>&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=1107053" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=1107053&lt;/a>
&lt;a class="link" href="https://www.spigotmc.org/resources/gsit-modern-sit-seat-and-chair-lay-and-crawl-plugin-1-13-x-1-17-x.62325/" target="_blank" rel="noopener"
>https://www.spigotmc.org/resources/gsit-modern-sit-seat-and-chair-lay-and-crawl-plugin-1-13-x-1-17-x.62325/&lt;/a>&lt;/p>
&lt;h4 id="luckperms">LuckPerms
&lt;/h4>&lt;p>{% asset_img 20211107_124934_534e2167e153aa1cbba149484e5d84fe15ab431a.png %}&lt;/p>
&lt;p>权限管理
&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=676818" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=676818&lt;/a>
&lt;a class="link" href="https://www.spigotmc.org/resources/luckperms.28140/" target="_blank" rel="noopener"
>https://www.spigotmc.org/resources/luckperms.28140/&lt;/a>&lt;/p>
&lt;h4 id="miaochat">&lt;del>MiaoChat&lt;/del>
&lt;/h4>&lt;p>{% asset_img 20211107_130410_player.png %}
聊天功能增加&lt;/p>
&lt;p>20230825更新：移除，被曝有后台&lt;/p>
&lt;p>聊天的时候输出%数字，代表展示手上物品
%1-9 代表快捷物品栏1-9号格子的物品&lt;/p>
&lt;p>&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=631240" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=631240&lt;/a>&lt;/p>
&lt;h4 id="nekomaid">NekoMaid
&lt;/h4>&lt;p>{% asset_img 20211107_130817_005546dtz88n1h8s3fff2h.png %}&lt;/p>
&lt;p>Wed后台管理插件&lt;/p>
&lt;p>&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=1230139" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=1230139&lt;/a>&lt;/p>
&lt;h4 id="pocketgamespo">PocketGamesPo
&lt;/h4>&lt;p>{% asset_img 20211107_132118_101703t8dh21764rt0tj2a.png.thumb.jpg %}&lt;/p>
&lt;p>34+口袋游戏|随时随地想玩就玩&lt;/p>
&lt;p>&lt;strong>玩家命令:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/pocketgames|/pocket|/pg - 打开游戏菜单&lt;/strong>&lt;/li>
&lt;li>&lt;strong>/pg help - 打开插件帮助&lt;/strong>&lt;/li>
&lt;li>/pg menu [玩家名] - 为指定玩家打开游戏菜单&lt;/li>
&lt;li>/pg multiplayer [玩家名] - 为指定玩家打开多人游戏菜单&lt;/li>
&lt;li>/pg spectate [玩家名] - 为指定玩家打开观战菜单&lt;/li>
&lt;li>/pg play &amp;lt;游戏ID&amp;gt; [玩家名] - 让指定的玩家玩指定的游戏&lt;/li>
&lt;li>/pg highscore &amp;lt;游戏ID&amp;gt; [玩家名] - 为指定玩家打开指定游戏的高分榜&lt;/li>
&lt;li>/pg duel &amp;lt;a/d/玩家名&amp;gt; [游戏ID] - 接受邀请/拒绝邀请/邀请玩家进行多人游戏&lt;/li>
&lt;li>/pg check &amp;lt;玩家名&amp;gt; - 检查玩家是否在玩游戏以及玩的什么游戏&lt;/li>
&lt;li>/pg list - 插件的游戏列表&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>管理员命令:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/pocketgamesadmin|/pga - 管理员帮助信息&lt;/strong>&lt;/li>
&lt;li>/pga reset file &amp;lt;文件名&amp;gt; [只可填highscores.yml]&lt;/li>
&lt;li>/pga reset database [表] - 刷新数据库指定的表&lt;/li>
&lt;li>/pga info - 插件信息&lt;/li>
&lt;li>/pga reload - 重载插件&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=913753" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=913753&lt;/a>&lt;/p>
&lt;h4 id="residence">Residence
&lt;/h4>&lt;p>{% asset_img 20211107_132529_114058j3twwd0zpthmq8op.png %}&lt;/p>
&lt;p>圈地插件&lt;/p>
&lt;p>/res ? —— 查看帮助&lt;/p>
&lt;p>&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=631343" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=631343&lt;/a>&lt;/p>
&lt;h4 id="serverminimap">&lt;del>Serverminimap&lt;/del>
&lt;/h4>&lt;p>小地图&lt;/p>
&lt;p>20230825更新：似乎没啥用，移除&lt;/p>
&lt;p>/minimap - 为您提供小地图项目
/waypoint help [command] - 为您提供有关此命令的信息
/waypoint add [x] [z] - 在您当前的位置或指定的 x 和 z 坐标上添加一个航点。
/waypoint list - 列出所有航点及其索引
/waypoint remove &lt;index> - 删除索引为 &lt;index> 的航点。注意：删除航点时，索引会发生变化。
/waypoint hide &lt;index> [true|false] - 切换航点的可见性，或将其设置为给定的布尔值。&lt;/p>
&lt;blockquote>
&lt;p>/lp group admin permission set minimap.fastupdate
/lp group admin permission set minimap.command.minimap
/lp group admin permission set minimap.command.waypoint.help
/lp group admin permission set minimap.command.waypoint.list
/lp group admin permission set minimap.command.waypoint.add
/lp group admin permission set minimap.command.waypoint.remove
/lp group admin permission set minimap.command.waypoint.hide&lt;/p>&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://dev.bukkit.org/projects/serverminimap" target="_blank" rel="noopener"
>https://dev.bukkit.org/projects/serverminimap&lt;/a>&lt;/p>
&lt;h4 id="tree-feller">Tree Feller
&lt;/h4>&lt;p>一键砍树插件&lt;/p>
&lt;p>&lt;a class="link" href="https://www.spigotmc.org/resources/tree-feller.92998/" target="_blank" rel="noopener"
>https://www.spigotmc.org/resources/tree-feller.92998/&lt;/a>&lt;/p>
&lt;h4 id="multiverse">Multiverse
&lt;/h4>&lt;p>多世界插件&lt;/p>
&lt;p>#命令语法&lt;/p>
&lt;blockquote>
&lt;p>mv [FILTER] [PAGE #]
#发送版本信息至控制台&lt;/p>
&lt;p>mv version -[pbg]
#列出所有世界名称&lt;/p>
&lt;p>mv list
#列出综合信息&lt;/p>
&lt;p>mv info [WORLD] [PAGE]
*/mv info [世界名称] [页码]&lt;/p>
&lt;p>#创建世界
mv create {名字} {环境} -s [种子] -g [生成器[:ID]] -t [生成器] [-n] -a [true|false]&lt;/p>
&lt;p>#复制某个世界
mv clone {目标} {名字} -g [生成器[:ID]]&lt;/p>
&lt;p>#转换某个世界的类型
mv import {名字} {环境} -g [生成器[:ID]] [-n]&lt;/p>
&lt;p>#重新加载配置文件
mv reload&lt;/p>
&lt;p>#重置当前世界的默认出生点为脚下
mv setspawn&lt;/p>&lt;/blockquote>
&lt;p>mcbbs:&lt;a class="link" href="https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=1016455" target="_blank" rel="noopener"
>https://www.mcbbs.net/forum.php?mod=viewthread&amp;amp;tid=1016455&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.spigotmc.org/resources/multiverse-core.390/" target="_blank" rel="noopener"
>https://www.spigotmc.org/resources/multiverse-core.390/&lt;/a>&lt;/p></description></item><item><title>ArchLinux命令集</title><link>https://winotmk.github.io/posts/archlinux%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 24 Oct 2021 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/archlinux%E5%91%BD%E4%BB%A4/</guid><description>&lt;p>刚装完archlinux后ifconfig无法使用?&lt;/p>
&lt;pre>&lt;code class="language-console"># pacman -S net-tools dnsutils inetutils iproute2
&lt;/code>&lt;/pre>
&lt;h3 id="archlinux开启ssh服务命令">Archlinux开启ssh服务命令：
&lt;/h3>&lt;pre>&lt;code class="language-console"># systemctl enable sshd.service 开机启动
# systemctl start sshd.service 立即启动
# systemctl restart sshd.service 立即重启
&lt;/code>&lt;/pre>
&lt;h3 id="关于systemctl">关于systemctl:
&lt;/h3>&lt;p>&lt;a class="link" href="https://wiki.archlinux.org/title/Systemd_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" target="_blank" rel="noopener"
>https://wiki.archlinux.org/title/Systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&lt;/a>&lt;/p>
&lt;p>比如：关闭开机启用KDE桌面环境&lt;/p>
&lt;pre>&lt;code class="language-console"># systemctl disable sddm
&lt;/code>&lt;/pre>
&lt;h3 id="切换到root用户">切换到root用户：
&lt;/h3>&lt;pre>&lt;code class="language-shell"># su
&lt;/code>&lt;/pre>
&lt;!-- more -->
&lt;hr>
&lt;p>以下无用，应该是旧版本PuTTY密钥算法支持有限，请更新PuTTY。。&lt;/p>
&lt;p>用PuTTY登录报错：&lt;/p>
&lt;p>couldn&amp;rsquo;t agree a host key algorithm&lt;/p>
&lt;p>解决，生成密钥：（出处：&lt;a class="link" href="https://forums.centos.org/viewtopic.php?t=52892" target="_blank" rel="noopener"
>https://forums.centos.org/viewtopic.php?t=52892&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-shell"># cd /etc/ssh
# ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key
# vi /etc/ssh/sshd_config
Uncomment this line:
# HostKey /etc/ssh/ssh_host_dsa_key
# chgrp ssh_keys ssh_host_dsa_key
# service sshd restart
&lt;/code>&lt;/pre>
&lt;p>如果putty连接报Network error:connection refused
关闭防火墙&lt;/p>
&lt;pre>&lt;code class="language-shell"># systemctl start iptables
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h3 id="安装jre环境">安装jre环境
&lt;/h3>&lt;pre>&lt;code class="language-shell"># pacman -S jre8-openjdk
&lt;/code>&lt;/pre>
&lt;p>高版本mc需要高JDK&lt;/p>
&lt;pre>&lt;code class="language-shell"># pacman -S jre17-openjdk
&lt;/code>&lt;/pre>
&lt;p>切换java版本&lt;/p>
&lt;pre>&lt;code class="language-shell"># sudo archlinux-java set java-17-openjdk
&lt;/code>&lt;/pre>
&lt;p>查看java状态&lt;/p>
&lt;pre>&lt;code class="language-shell"># java -version
&lt;/code>&lt;/pre>
&lt;h3 id="启动一个mc服务器">启动一个mc服务器
&lt;/h3>&lt;p>&lt;a class="link" href="https://cloud.tencent.com/developer/article/1622545" target="_blank" rel="noopener"
>https://cloud.tencent.com/developer/article/1622545&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-shell"># java -Xms1024MB -Xmx2048MB -jar iserver.jar
&lt;/code>&lt;/pre>
&lt;h3 id="设置中文环境">设置中文环境
&lt;/h3>&lt;pre>&lt;code class="language-shell"># vim /etc/locale.conf
&lt;/code>&lt;/pre>
&lt;p>增加以下内容
LANG=zh_CN.UTF-8&lt;/p>
&lt;p>下次重新登录就是中文啦。可以输入date查看日期，如果显示中文，就说明设置正常啦&lt;/p>
&lt;h3 id="关于linux任务前后台处理">关于linux任务前后台处理：
&lt;/h3>&lt;p>&lt;a class="link" href="https://blog.csdn.net/timonium/article/details/116245621" target="_blank" rel="noopener"
>https://blog.csdn.net/timonium/article/details/116245621&lt;/a>
&lt;a class="link" href="https://www.cnblogs.com/xiaoleiel/p/8349675.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/xiaoleiel/p/8349675.html&lt;/a>&lt;/p>
&lt;p>正在前台运行的命令暂停且放到后台：&lt;/p>
&lt;pre>&lt;code class="language-shell"># Ctrl+z
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-shell"># jobs ## 查看后台进程编号
# jobs -l ##查看进程PID，可以配合kill干掉进程
&lt;/code>&lt;/pre>
&lt;p>bg在后台继续执行，fg调回前台执行&lt;/p>
&lt;pre>&lt;code class="language-shell"># bg [作业编号]
# fg [作业编号]
&lt;/code>&lt;/pre>
&lt;p>一开始就后台执行：
&lt;a class="link" href="https://www.cnblogs.com/linnuo/p/9084125.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/linnuo/p/9084125.html&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-shell"># java -jar shareniu.jar &amp;amp;
&lt;/code>&lt;/pre>
&lt;p>&amp;amp;代表在后台运行&lt;/p>
&lt;pre>&lt;code class="language-shell"># nohup java -jar shareniu.jar &amp;amp;
&lt;/code>&lt;/pre>
&lt;p>nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行
当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。&lt;/p>
&lt;p>ps：我觉得上面的后台操作不好用不如试试Screen&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/han0373/article/details/81352663" target="_blank" rel="noopener"
>https://blog.csdn.net/han0373/article/details/81352663&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>screen -S yourname -&amp;gt; 新建一个叫yourname的session
screen -ls -&amp;gt; 列出当前所有的session
screen -r yourname -&amp;gt; 回到yourname这个session
screen -d yourname -&amp;gt; 远程detach某个session
screen -d -r yourname -&amp;gt; 结束当前session并回到yourname这个session&lt;/p>&lt;/blockquote>
&lt;p>回到MCSManager的面板&lt;/p>
&lt;pre>&lt;code># screen -r mcsm
&lt;/code>&lt;/pre>
&lt;h3 id="看进程">看进程
&lt;/h3>&lt;pre>&lt;code class="language-shell"># ps aux
或者
# top
&lt;/code>&lt;/pre>
&lt;h3 id="压缩">压缩
&lt;/h3>&lt;p>&lt;a class="link" href="https://www.jianshu.com/p/59d93f942506" target="_blank" rel="noopener"
>https://www.jianshu.com/p/59d93f942506&lt;/a>&lt;/p>
&lt;pre>&lt;code>01-.tar格式
解包：# tar xvf FileName.tar
打包：# tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）
02-.gz格式
解压1：# gunzip FileName.gz
解压2：# gzip -d FileName.gz
压 缩：# gzip FileName
03-.tar.gz格式
解压：# tar zxvf FileName.tar.gz
压缩：# tar zcvf FileName.tar.gz DirName
&lt;/code>&lt;/pre></description></item><item><title>hexo+github</title><link>https://winotmk.github.io/posts/hexo+github/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/hexo+github/</guid><description>&lt;p>&lt;a class="link" href="https://winotmk.github.io/" target="_blank" rel="noopener"
>https://winotmk.github.io/&lt;/a>&lt;/p>
&lt;p>github：&lt;a class="link" href="https://github.com/winotmk/winotmk.github.io" target="_blank" rel="noopener"
>https://github.com/winotmk/winotmk.github.io&lt;/a>&lt;/p>
&lt;p>总有一些零碎的想法，需要记录下来，写全面的文章没有时间，不写下来又会忘，日记app又不方便整理，同时也想利用一下树莓派，网上搜索便发现hexo+github部署的方式，于是想尝试尝试，一路遇到很多问题&lt;/p>
&lt;p>主要参考：&lt;a class="link" href="https://cuifengwei.com/2020/02/21/%E5%9F%BA%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0GitHub/" target="_blank" rel="noopener"
>基于树莓派搭建Hexo博客部署到GitHub/Gitee&lt;/a>&lt;/p>
&lt;p>前期第二参考：&lt;a class="link" href="https://zhuanlan.zhihu.com/p/44233946" target="_blank" rel="noopener"
>hexo——轻量、简易、高逼格的博客&lt;/a>&lt;/p>
&lt;p>更详细的安装过程：&lt;a class="link" href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener"
>GitHub+Hexo 搭建个人网站详细教程&lt;/a>&lt;/p>
&lt;p>hexo官方文档：&lt;a class="link" href="https://hexo.io/docs/" target="_blank" rel="noopener"
>https://hexo.io/docs/&lt;/a>&lt;/p>
&lt;p>hexo博客文档（似乎和上面有不少内容重叠）：&lt;a class="link" href="https://theme-next.js.org/docs/" target="_blank" rel="noopener"
>https://theme-next.js.org/docs/&lt;/a>&lt;/p>
&lt;h2 id="安装hexo">安装hexo
&lt;/h2>&lt;p>下载armv7版本的node.js：&lt;a class="link" href="https://nodejs.org/en/download/" target="_blank" rel="noopener"
>nodejs下载&lt;/a>&lt;/p>
&lt;!-- more -->
&lt;h2 id="配置github">配置github
&lt;/h2>&lt;p>git key配置：&lt;a class="link" href="https://blog.csdn.net/qq_36711388/article/details/88780372" target="_blank" rel="noopener"
>github每次需要输入密码和用户名的问题&amp;hellip;&lt;/a>&lt;/p>
&lt;p>取消使用key令牌后还要输入密码：&lt;a class="link" href="https://cloud.tencent.com/developer/article/1095516" target="_blank" rel="noopener"
>取消 SSH 私钥密码&lt;/a>&lt;/p>
&lt;h2 id="后期配置">后期配置
&lt;/h2>&lt;h3 id="hexo配置">hexo配置
&lt;/h3>&lt;p>官方文档：&lt;a class="link" href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener"
>https://hexo.io/zh-cn/docs/configuration&lt;/a>&lt;/p>
&lt;h3 id="主题">主题
&lt;/h3>&lt;p>Next主题github：&lt;a class="link" href="https://github.com/next-theme/hexo-theme-next" target="_blank" rel="noopener"
>https://github.com/next-theme/hexo-theme-next&lt;/a>&lt;/p>
&lt;p>Next主题的文档(ps.页面样式好看可参考)：&lt;a class="link" href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener"
>第三方服务集成&lt;/a>&lt;/p>
&lt;p>Next主题代码框高亮预览设置：&lt;a class="link" href="https://theme-next.js.org/highlight/" target="_blank" rel="noopener"
>https://theme-next.js.org/highlight/&lt;/a>&lt;/p>
&lt;h3 id="资产文件夹">资产文件夹
&lt;/h3>&lt;p>&lt;a class="link" href="https://hexo.io/docs/asset-folders" target="_blank" rel="noopener"
>https://hexo.io/docs/asset-folders&lt;/a>&lt;/p>
&lt;h3 id="访客统计">访客统计
&lt;/h3>&lt;p>&lt;a class="link" href="https://www.dazhuanlan.com/jane2382/topics/1350442https:/" target="_blank" rel="noopener"
>DevOps 访客数统计 &amp;amp; google analytics 数据分析&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://qiuyiwu.github.io/2019/01/26/Hexo-View/" target="_blank" rel="noopener"
>将文章视图添加到您的 Hexo 博客&lt;/a>(有LeanCloud和Firebase比较分析）&lt;/p>
&lt;p>&lt;a class="link" href="https://zhangjh.me/2016/04/12/hexo-visit-analytics-md/" target="_blank" rel="noopener"
>给hexo博客文章添加阅读次数统计&lt;/a>&lt;/p>
&lt;p>hexo next主题的leancloud安全插件github：&lt;a class="link" href="https://github.com/theme-next/hexo-leancloud-counter-security" target="_blank" rel="noopener"
>https://github.com/theme-nex&amp;hellip;&lt;/a>&lt;/p>
&lt;p>上面链接的说明：&lt;a class="link" href="https://leaferx.online/2018/02/11/lc-security/" target="_blank" rel="noopener"
>Leancloud访客统计插件重大安全漏洞修复指南&lt;/a>&lt;/p>
&lt;p>Firebase:&lt;a class="link" href="https://console.firebase.google.com/project/winnote-visitor/overview" target="_blank" rel="noopener"
>https://console.firebase.google&amp;hellip;&lt;/a>&lt;/p>
&lt;h3 id="评论">评论
&lt;/h3>&lt;p>畅言：&lt;a class="link" href="https://changyan.kuaizhan.com/v3/changyan/overview" target="_blank" rel="noopener"
>https://changyan.kuaizhan.com/v3/changyan/overview&lt;/a>
valine：&lt;a class="link" href="https://valine.js.org" target="_blank" rel="noopener"
>https://valine.js.org&lt;/a>&lt;/p>
&lt;h2 id="其他">其他
&lt;/h2>&lt;h3 id="配置vscode">配置vscode：
&lt;/h3>&lt;p>本来都是用&lt;strong>putty&lt;/strong>打指令，用&lt;strong>WinSCP&lt;/strong>访问我的目录操作的，但是&lt;strong>WinSCP&lt;/strong>自带的文本编辑过与拉跨，有几次多打空格没看出来导致直接&lt;code>hexo g&lt;/code>失败，后来突发奇想为啥不找个轻量级的IDE直接去写这些呢，于是用起了vscode&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/weixin_42592326/article/details/108058711https:/" target="_blank" rel="noopener"
>Vscode配置ftp连接远程服务器（上传本地文件）&lt;/a>&lt;/p>
&lt;p>不过自己测试发现不好用，于是用了&lt;strong>SSH FS&lt;/strong>这个vscode插件&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/qq_34769573/article/details/80445681" target="_blank" rel="noopener"
>相对路径./与../区别&lt;/a>&lt;/p></description></item><item><title>Links</title><link>https://winotmk.github.io/links/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/links/</guid><description>&lt;!--
To use this feature, add `links` section to frontmatter.
This page's frontmatter:
```yaml
links:
- title: GitHub
description: GitHub is the world's largest software development platform.
website: https://github.com
image: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png
- title: TypeScript
description: TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.
website: https://www.typescriptlang.org
image: ts-logo-128.jpg
```
`image` field accepts both local and external images.
--></description></item><item><title>linux文件和目录权限</title><link>https://winotmk.github.io/posts/linux%E6%9D%83%E9%99%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/linux%E6%9D%83%E9%99%90/</guid><description>&lt;p>*本文摘录整理为主&lt;/p>
&lt;p>用&lt;code>ls -l&lt;/code>查看权限：&lt;/p>
&lt;pre>&lt;code>文件属性 文件数 拥有者 所属的group 文件大小 建档日期 文件名　　
drwx--x--x 1 root wheel 6872 2 7 22:41 compressedPackage/
drwxr-xr-x 1 liuml wheel 8620 2 15 09:32 wwwroot/　　
lrwxrwxrwx 1 liuml wheel 46 2 24 19:30 abc@ -&amp;gt; home/abc
-rwxr-xr-x 1 liuml wheel 68568 2 29 07:43 test*　　
- 文件名栏位 文件后面的符号含义
- / ：表明是一个目录
- @ ：表明是到其它文件的符号链接
- * ：表明是一个可执行文件。
- 对于权限设置的解释
- r 是读，w 是写，x 是执行
- 对应数字如下:
- r = 4 w = 2 x = 1
- rwx ：4+2+1 = 7
- rw- ：4+2 = 6
- r-x ：4+1 = 5
- drwxr-xr-x ：755
- 第 0-1位 文件类型
- “-” ：表示普通文件；
- “d” ：表示目录；
- “l” ：表示链接文件；
- “p” ：表示管理文件；
- “b” ：表示块设备文件；
- “c” ：表示字符设备文件；
- “s” ：表示套接字文件；
- 第 2-4位 文件所有者权限 [User]
- 第 5-7位 文件所有者所在组权限 [Group]
- 第 8-10位 其他用户权限 [Others]
- 没有的权限用 “-” 来表示
————————————————
版权声明：本文为CSDN博主「烟雨弥漫了江南」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u010324331/article/details/88035175/
&lt;/code>&lt;/pre>
&lt;!-- more -->
&lt;p>{% asset_img 20211012_231624_2018091016360849.png 800 %}&lt;/p>
&lt;p>图片来源：&lt;a class="link" href="https://blog.csdn.net/zhuoya_/article/details/77418413" target="_blank" rel="noopener"
>https://blog.csdn.net/zhuoya_/article/details/77418413&lt;/a>&lt;/p>
&lt;p>共显示了七列信息，从左至右依次为：权限、文件数、归属用户、归属群组、文件大小、创建日期、文件名称
d ：第一位表示文件类型&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">第一位字符&lt;/th>
&lt;th>文件类型&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">d&lt;/td>
&lt;td>文件夹&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">-&lt;/td>
&lt;td>普通文件&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">l&lt;/td>
&lt;td>链接&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">b&lt;/td>
&lt;td>块设备文件&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">p&lt;/td>
&lt;td>管道文件&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">c&lt;/td>
&lt;td>字符设备文件&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">s&lt;/td>
&lt;td>套接口文件&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>rxw和数值权限的对应：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>rxw&lt;/th>
&lt;th>数值&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>r(读)&lt;/td>
&lt;td>4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>w(写)&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>x(执行)&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>所以，例如：
rwx rw- r&amp;ndash;
7 6 4
三个一组,rwx权限分别对应421相加得7,rw-对应42相加,r&amp;ndash;对应4&lt;/p>
&lt;p>{% asset_img 20211012_232003_20180910175047158.gif 500 %}&lt;/p>
&lt;p>图片来源：&lt;a class="link" href="http://man.linuxde.net/chmod" target="_blank" rel="noopener"
>http://man.linuxde.net/chmod&lt;/a>&lt;/p>
&lt;p>举例：-rw-r&amp;ndash;r&amp;ndash;，即为644权限
6对应4+2 rw-
4对应 r&amp;ndash;
那么这个文件的权限就是所有者rw-,所属组r&amp;ndash;,其他人r&amp;ndash;&lt;/p>
&lt;p>常用的linux权限对应：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数值&lt;/th>
&lt;th>rxw&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>444&lt;/td>
&lt;td>r&amp;ndash;r&amp;ndash;r&amp;ndash;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>600&lt;/td>
&lt;td>rw&amp;mdash;&amp;mdash;-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>644&lt;/td>
&lt;td>rw-r&amp;ndash;r&amp;ndash;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>666&lt;/td>
&lt;td>rw-rw-rw-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>700&lt;/td>
&lt;td>rwx&amp;mdash;&amp;mdash;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>744&lt;/td>
&lt;td>rwxr&amp;ndash;r&amp;ndash;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>755&lt;/td>
&lt;td>rwxr-xr-x&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>777&lt;/td>
&lt;td>rwxrwxrwx&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="命令修改权限">命令修改权限
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>权限管理命令chmod&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>修改文件或者目录的权限
全拼: change permissions mode of a file
语法:&lt;/p>
&lt;pre>&lt;code>chmod [{ugoa}{+-=}{rwx}] [文件或目录]
[mode=421] [文件或目录]
-R 递归修改
u:所有者, g:所属组,o:其他人,a:所有;
+:添加权限,-减少权限,=直接赋值成这个权限
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>&lt;strong>创建目录mkdir时加权限&lt;/strong>&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>$ mkdir -m=r-- letter
&lt;/code>&lt;/pre>
&lt;p>上面的命令会创建一个名为 letter 的目录，同时为&lt;strong>目录所有者、用户组和其他用户&lt;/strong> 针对该目录赋予&lt;strong>只读权限&lt;/strong>&lt;/p>
&lt;p>mkdir命令小参考：&lt;a class="link" href="https://linux.cn/article-2713-1.html" target="_blank" rel="noopener"
>在 Linux 下用 mkdir 命令来创建目录和子目录&lt;/a>&lt;/p>
&lt;h2 id="参考">参考：
&lt;/h2>&lt;p>&lt;a class="link" href="https://www.cnblogs.com/tianchao/p/11821556.html" target="_blank" rel="noopener"
>linux权限drwxrwxrwx所代表的意义&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/u010324331/article/details/88035175/" target="_blank" rel="noopener"
>linux ls -l命令显示详解&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/ken1583096683/article/details/82594037" target="_blank" rel="noopener"
>linux更改文件(夹)权限或所有者&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://jingyan.baidu.com/article/4853e1e5413b541909f72632.html" target="_blank" rel="noopener"
>Linux 文件权限查看及修改&lt;/a>&lt;/p></description></item><item><title>MayaMASH动力学做链子</title><link>https://winotmk.github.io/posts/maya_mash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/maya_mash/</guid><description>&lt;p>{% asset_img 20211009_110403_2021100901.gif 500 %}&lt;/p>
&lt;!-- more -->
&lt;p>{% asset_img 20211009_110414_2021100902.jpg 750 %}&lt;/p></description></item><item><title>Search</title><link>https://winotmk.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/search/</guid><description/></item><item><title>安装ArchLinux系统（详细过程）</title><link>https://winotmk.github.io/posts/%E5%AE%89%E8%A3%85arch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/%E5%AE%89%E8%A3%85arch/</guid><description>&lt;p>参考文章：&lt;a class="link" href="https://zhuanlan.zhihu.com/p/138951848" target="_blank" rel="noopener"
>https://zhuanlan.zhihu.com/p/138951848&lt;/a>&lt;/p>
&lt;p>官方WIKI安装指南（上文和本文大致流程基于此）：&lt;a class="link" href="https://wiki.archlinux.org/title/Installation_guide" target="_blank" rel="noopener"
>https://wiki.archlinux.org/title/Installation_guide&lt;/a>&lt;/p>
&lt;p>家里旧笔记本淘汰装个Linux跑跑服务发挥余热，
这里是彻底格式化硬盘新安装，而不需要多系统引导&lt;/p>
&lt;p>我的环境有：&lt;/p>
&lt;ul>
&lt;li>2核 Intel(R) Pentium(R) CPU 997 @ 1.60GHz&lt;/li>
&lt;li>4GB 1600内存&lt;/li>
&lt;li>UEFI启动（不能为BIOS）&lt;/li>
&lt;li>Samsang 850 EVO 250G 2.5寸SATA接口&lt;/li>
&lt;li>无线网卡拆掉了，用得是网线&lt;/li>
&lt;li>路由器上全局梯子（所以我没有换源，用官方源速度足够了）&lt;/li>
&lt;/ul>
&lt;h2 id="准备镜像">准备镜像
&lt;/h2>&lt;p>&lt;a class="link" href="https://archlinux.org/download/" target="_blank" rel="noopener"
>https://archlinux.org/download/&lt;/a>
下载发行版的Linux的ISO
然后制作U盘启动，我是在mac下用balenaEtcher做的，操作非常方便&lt;/p>
&lt;p>{% asset_img 20211024_224012.png 800 %}&lt;/p>
&lt;!-- more -->
&lt;p>然后重启电脑从U盘启动&lt;/p>
&lt;h2 id="硬盘准备">硬盘准备
&lt;/h2>&lt;p>进入U盘系统后先连pacman试试&lt;/p>
&lt;pre>&lt;code class="language-Shell">pacman -Syyy
&lt;/code>&lt;/pre>
&lt;p>{% asset_img 20211024_224554_v2-da5d5bc2996a7b6990673c4c4700d77a_1440w.png 800 %}&lt;/p>
&lt;h3 id="检查硬盘">检查硬盘
&lt;/h3>&lt;pre>&lt;code class="language-Shell">lsblk
&lt;/code>&lt;/pre>
&lt;p>{% asset_img 20211024_231805.png 500 %}&lt;/p>
&lt;h3 id="建立分区">建立分区
&lt;/h3>&lt;pre>&lt;code class="language-Shell">cfdisk /dev/sda
&lt;/code>&lt;/pre>
&lt;p>选择New 回车，然后
选择Write 回车 输入 yes 回车
写入完成 选择Quit 回车退出&lt;/p>
&lt;h3 id="格式化">格式化
&lt;/h3>&lt;p>将刚刚分好的区格式化为ext4格式，这里认准分区号sda1&lt;/p>
&lt;pre>&lt;code class="language-Shell">mkfs.ext4 /dev/sda1
&lt;/code>&lt;/pre>
&lt;h3 id="挂载分区">挂载分区
&lt;/h3>&lt;p>sda1&lt;/p>
&lt;pre>&lt;code class="language-Shell">mount /dev/sda1 /mnt
&lt;/code>&lt;/pre>
&lt;h2 id="安装系统">安装系统
&lt;/h2>&lt;pre>&lt;code class="language-Shell">pacstrap /mnt base linux linux-firmware nano
&lt;/code>&lt;/pre>
&lt;h2 id="生成fstab文件">生成fstab文件
&lt;/h2>&lt;pre>&lt;code class="language-Shell">genfstab -U /mnt &amp;gt;&amp;gt; /mnt/etc/fstab
&lt;/code>&lt;/pre>
&lt;p>检查生成的fstab文件&lt;/p>
&lt;pre>&lt;code class="language-Shell">cat /mnt/etc/fstab
&lt;/code>&lt;/pre>
&lt;h2 id="配置新系统">配置新系统
&lt;/h2>&lt;h3 id="切换到装好的系统">切换到装好的系统
&lt;/h3>&lt;pre>&lt;code class="language-Shell">arch-chroot /mnt
&lt;/code>&lt;/pre>
&lt;h3 id="设置时区">设置时区
&lt;/h3>&lt;pre>&lt;code class="language-Shell">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
&lt;/code>&lt;/pre>
&lt;h3 id="设置locale">设置locale
&lt;/h3>&lt;pre>&lt;code class="language-Shell">nano /etc/locale.gen
&lt;/code>&lt;/pre>
&lt;p>Ctrl+W 输入 #en_US 回车 找到UTF-8那一行 删掉前面的#&lt;/p>
&lt;p>Ctrl+W 输入 #zh_CN 回车 找到UTF-8那一行 删掉前面的#
Ctrl+X 然后Y保存退出
生成locale&lt;/p>
&lt;pre>&lt;code class="language-Shell">locale-gen
&lt;/code>&lt;/pre>
&lt;p>创建并写入/etc/locale.conf文件&lt;/p>
&lt;pre>&lt;code class="language-Shell">nano /etc/locale.conf
&lt;/code>&lt;/pre>
&lt;p>填入内容，注意这里只能填这个&lt;/p>
&lt;pre>&lt;code class="language-Shell">LANG=en_US.UTF-8
&lt;/code>&lt;/pre>
&lt;h3 id="创建并写入hostname">创建并写入hostname
&lt;/h3>&lt;pre>&lt;code class="language-Shell">nano /etc/hostname
&lt;/code>&lt;/pre>
&lt;p>我这里名字叫WinArch
保存退出&lt;/p>
&lt;h3 id="修改hosts">修改hosts
&lt;/h3>&lt;pre>&lt;code class="language-Shell">nano /etc/hosts
&lt;/code>&lt;/pre>
&lt;p>写入内容如图（中间的空白用tab而非空格），arch替换为你之前在hostname里写入的内容，其他都按照图里面的写（注意最后一行的ip是127.0.1.1）&lt;/p>
&lt;p>{% asset_img 20211024_234039_v2-54fc38004dc15b76d68983a78e59928a_r.jpg 800 %}&lt;/p>
&lt;p>保存退出&lt;/p>
&lt;p>建议上述编辑的内容都用cat输出检查一下&lt;/p>
&lt;h3 id="root用户创建密码">root用户创建密码
&lt;/h3>&lt;pre>&lt;code class="language-Shell">passwd
&lt;/code>&lt;/pre>
&lt;p>然后输入并确认密码&lt;/p>
&lt;h3 id="装启动器和一些软件">装启动器和一些软件
&lt;/h3>&lt;p>包含了一些常用到的软件&lt;/p>
&lt;pre>&lt;code class="language-Shell">pacman -S grub efibootmgr networkmanager network-manager-applet dialog wireless_tools wpa_supplicant os-prober mtools dosfstools ntfs-3g base-devel linux-headers reflector git sudo
&lt;/code>&lt;/pre>
&lt;p>intel的cpu，需要安装intel的微码文件&lt;/p>
&lt;pre>&lt;code class="language-Shell">pacman -S intel-ucode
&lt;/code>&lt;/pre>
&lt;p>完成之后输入&lt;/p>
&lt;pre>&lt;code class="language-Shell">grub-install /dev/sda
&lt;/code>&lt;/pre>
&lt;p>注意是硬盘位置不是分区位置，硬盘上也只有刚刚安装的Arch系统&lt;/p>
&lt;p>生成grub.cfg&lt;/p>
&lt;pre>&lt;code class="language-Shell">grub-mkconfig -o /boot/grub/grub.cfg
&lt;/code>&lt;/pre>
&lt;p>出现吧啦吧啦done就完成了&lt;/p>
&lt;h2 id="退出新系统重启">退出新系统重启
&lt;/h2>&lt;pre>&lt;code class="language-shell">exit
reboot
&lt;/code>&lt;/pre>
&lt;p>不装桌面环境的话，到这步即可使用了，后续需要什么再装不迟&lt;/p>
&lt;h2 id="新建用户并授权">新建用户并授权
&lt;/h2>&lt;pre>&lt;code class="language-Shell">useradd -m -G wheel winotmk
&lt;/code>&lt;/pre>
&lt;p>我的用户是winotkm，这里主要是创建一个非root的账户，桌面环境一般无法用root登陆的
创建密码&lt;/p>
&lt;pre>&lt;code class="language-Shell">passwd winotmk
&lt;/code>&lt;/pre>
&lt;p>授权&lt;/p>
&lt;pre>&lt;code class="language-Shell">EDITOR=nano visudo
&lt;/code>&lt;/pre>
&lt;p>Ctrl+W 输入 # %wheel 回车 找到这行 删除前面的 #（取消注释）&lt;/p>
&lt;h2 id="安装display-server和display-manager">安装Display Server和Display Manager
&lt;/h2>&lt;pre>&lt;code class="language-Shell">pacman -S xorg
&lt;/code>&lt;/pre>
&lt;p>然后我喜欢KDE桌面，所以装：&lt;/p>
&lt;pre>&lt;code class="language-Shell">pacman -S sddm
&lt;/code>&lt;/pre>
&lt;p>设置开机启动&lt;/p>
&lt;pre>&lt;code class="language-Shell">systemctl enable sddm
&lt;/code>&lt;/pre>
&lt;p>PS.取消开机启动是&lt;/p>
&lt;pre>&lt;code class="language-Shell">systemctl disable sddm
&lt;/code>&lt;/pre>
&lt;h2 id="安装desktop-environment">安装Desktop Environment
&lt;/h2>&lt;p>KDE：&lt;/p>
&lt;pre>&lt;code class="language-Shell">pacman -S plasma kde-applications packagekit-qt5
&lt;/code>&lt;/pre>
&lt;p>安装中文的字体&lt;/p>
&lt;pre>&lt;code class="language-Shell">pacman -S noto-fonts-cjk
&lt;/code>&lt;/pre>
&lt;p>好了，大功告成&lt;/p>
&lt;pre>&lt;code class="language-Shell">reboot
&lt;/code>&lt;/pre>
&lt;p>{% asset_img 20211025_000315_87B60562-6700-4593-B70A-F543B38B30E5_1_105_c.jpeg 800 %}&lt;/p></description></item><item><title>流量异常排查</title><link>https://winotmk.github.io/posts/%E6%B5%81%E9%87%8F%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/%E6%B5%81%E9%87%8F%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/</guid><description>&lt;p>&lt;img src="https://winotmk.github.io/images/20230618000510.png"
loading="lazy"
>
挖个坑。。。&lt;/p></description></item><item><title>生成秘钥连接至github————用来推hexo</title><link>https://winotmk.github.io/posts/%E7%94%9F%E6%88%90%E7%A7%98%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%87%B3github_%E7%94%A8%E6%9D%A5%E6%8E%A8hexo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/%E7%94%9F%E6%88%90%E7%A7%98%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%87%B3github_%E7%94%A8%E6%9D%A5%E6%8E%A8hexo/</guid><description>&lt;h2 id="生成秘钥">生成秘钥
&lt;/h2>&lt;pre>&lt;code>ssh-keygen -t ed25519 -C &amp;quot;550330147@qq.com&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>邮箱自然是我的git注册邮箱&lt;/p>
&lt;h2 id="如果修改passphrade密码">如果修改passphrade密码
&lt;/h2>&lt;pre>&lt;code>ssh-keygen -p -f ~/.ssh/id_ed25519
&lt;/code>&lt;/pre>
&lt;p>直接enter即密码为空，这是秘钥的密码&lt;/p>
&lt;h2 id="复制秘钥到github">复制秘钥到github
&lt;/h2>&lt;p>&lt;img src="https://winotmk.github.io/images/20230618002355.png"
loading="lazy"
>
打开/root/.ssh/id_ed25519.pub
复制到这里
&lt;img src="https://winotmk.github.io/images/20230618002554.png"
loading="lazy"
>
&lt;a class="link" href="https://github.com/settings/ssh/new" target="_blank" rel="noopener"
>https://github.com/settings/ssh/new&lt;/a>&lt;/p>
&lt;p>PS官方已不推荐用rsa加密&lt;/p>
&lt;h2 id="测试">测试
&lt;/h2>&lt;pre>&lt;code>ssh -T git@github.com
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://winotmk.github.io/images/20230618003332.png"
loading="lazy"
>
这里输入yes
&lt;img src="https://winotmk.github.io/images/20230618003428.png"
loading="lazy"
>
成功！&lt;/p></description></item><item><title>树莓派路由器</title><link>https://winotmk.github.io/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B7%AF%E7%94%B1%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B7%AF%E7%94%B1%E5%99%A8/</guid><description>&lt;h2 id="树莓派cm4的">树莓派CM4的
&lt;/h2>&lt;p>&lt;img src="https://winotmk.github.io/images/20230614212800.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="openwrt-web界面安装中文">openWrt web界面安装中文
&lt;/h2>&lt;p>&lt;a class="link" href="https://www.jianshu.com/p/da01ce070688" target="_blank" rel="noopener"
>https://www.jianshu.com/p/da01ce070688&lt;/a>
更新包目录：&lt;/p>
&lt;pre>&lt;code class="language-shell">opkg update
&lt;/code>&lt;/pre>
&lt;p>这里一开始我不行，ping1.1.1.1和ping8.8.8.8都ping不通，然后忽然想起自己的科学梯子路由网关是192.168.50.4
改之!!&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20230614001635.png"
loading="lazy"
>&lt;/p>
&lt;p>可能还不行
&lt;img src="https://winotmk.github.io/images/20230617224422.png"
loading="lazy"
>
这俩防火墙设置一下&lt;/p>
&lt;p>如果还不行
&lt;img src="https://winotmk.github.io/images/20230617231305.png"
loading="lazy"
>
DNS记得指定一下&lt;/p>
&lt;p>这下就能通了&lt;/p>
&lt;p>PS也可以点配置opkg，然后加一条&lt;/p>
&lt;pre>&lt;code class="language-shell">src/gz openwrt_packages https://mirrors.ustc.edu.cn/openwrt/releases/22.03.5/packages/aarch64_cortex-a72/packages/
&lt;/code>&lt;/pre>
&lt;p>把源换为国内&lt;/p>
&lt;p>然后&lt;/p>
&lt;pre>&lt;code class="language-shell">opkg install luci-i18n-base-zh-cn
&lt;/code>&lt;/pre>
&lt;p>提示&lt;/p>
&lt;pre>&lt;code class="language-shell">Configuring luci-i18n-base-zh-cn
&lt;/code>&lt;/pre>
&lt;p>再回来看web界面就已经是中文了
&lt;img src="https://winotmk.github.io/images/20230614001825.png"
loading="lazy"
>&lt;/p>
&lt;!-- more -->
&lt;h2 id="如果要开启sftp传输服务">如果要开启sftp传输服务
&lt;/h2>&lt;p>&lt;a class="link" href="https://github.com/twn39/code/issues/279" target="_blank" rel="noopener"
>https://github.com/twn39/code/issues/279&lt;/a>&lt;/p>
&lt;p>开启sftp的话可以很方便用WinSCP登录，文件管理神器
&lt;img src="https://winotmk.github.io/images/20230614002052.png"
loading="lazy"
>
那么如何启用 sftp 服务呢？先安装对应的软件：&lt;/p>
&lt;p>opkg install vsftpd openssh-sftp-server
设置系统开启后自动启动 sftp 服务：&lt;/p>
&lt;pre>&lt;code class="language-shell">/etc/init.d/vsftpd enable
&lt;/code>&lt;/pre>
&lt;p>启动 sftp 服务：&lt;/p>
&lt;pre>&lt;code class="language-shell"> /etc/init.d/vsftpd start
&lt;/code>&lt;/pre>
&lt;p>这样 Openwrt 就已经启用了 sftp 服务了，可以使用客户端进行文件的传输。&lt;/p>
&lt;h2 id="装网卡驱动">装网卡驱动
&lt;/h2>&lt;p>我的CM4拓展板子是微雪的这个
&lt;img src="https://winotmk.github.io/images/20230617234921.png"
loading="lazy"
>
&lt;a class="link" href="https://www.waveshare.net/wiki/CM4-DUAL-ETH-MINI" target="_blank" rel="noopener"
>https://www.waveshare.net/wiki/CM4-DUAL-ETH-MINI&lt;/a>
有两个网口ETH0是原生ETH1是PCIe转出来的，需要安装RTL8111H芯片的网卡驱动，查了一下软件包里是有的
&lt;a class="link" href="https://openwrt.org/packages/pkgdata/kmod-r8169" target="_blank" rel="noopener"
>https://openwrt.org/packages/pkgdata/kmod-r8169&lt;/a>
那么就好办了
安装就行了：&lt;/p>
&lt;pre>&lt;code class="language-shell"> opkg install kmod-r8169
&lt;/code>&lt;/pre>
&lt;p>安装完成以重启openwrt我们看到这里已经读到了eth1口
&lt;img src="https://winotmk.github.io/images/20230614003210.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="设置路由器wan口">设置路由器WAN口
&lt;/h2>&lt;p>添加新端口，设备选装好驱动以后出现的eth1，协议我选pppoe因为我拿路由拨号&lt;/p>
&lt;p>&lt;img src="https://winotmk.github.io/images/20230614003850.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="如果要自己加安装包">如果要自己加安装包：
&lt;/h2>&lt;p>放到一个tmp目录里
CD到tmp目录&lt;/p>
&lt;pre>&lt;code>opkg install *.ipk
&lt;/code>&lt;/pre>
&lt;h2 id="关于扩容挂载点">关于扩容挂载点
&lt;/h2>&lt;p>参考资料：
&lt;a class="link" href="https://www.jianshu.com/p/e83459242afb" target="_blank" rel="noopener"
>https://www.jianshu.com/p/e83459242afb&lt;/a>
&lt;a class="link" href="https://blog.csdn.net/ls0111/article/details/128769859" target="_blank" rel="noopener"
>https://blog.csdn.net/ls0111/article/details/128769859&lt;/a>&lt;/p>
&lt;p>PS我选的是树莓派cpu对应的ext4文件系统的固件，SQUASHFS就不碰了不熟悉
首先安装安装cfdisk，注意这里要先更新下opkg&lt;/p>
&lt;pre>&lt;code class="language-shell">opkg update
opkg install cfdisk
&lt;/code>&lt;/pre>
&lt;p>然后打开cfdisk&lt;/p>
&lt;pre>&lt;code class="language-shell">cfdisk
&lt;/code>&lt;/pre>
&lt;p>但是我打不开
比如我的这块硬盘是内置EMMC硬盘, 显示名称是/dev/mmcblk0.
一般的内置硬盘应该是/dev/sda之类的.&lt;/p>
&lt;p>使用cfdisk命令，进入分区页面&lt;/p>
&lt;pre>&lt;code class="language-shell">cfdisk /dev/mmcblk0
&lt;/code>&lt;/pre>
&lt;p>如果普通是内置硬盘&lt;/p>
&lt;pre>&lt;code class="language-shell">cfdisk
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://winotmk.github.io/images/20230617234233.png"
loading="lazy"
>
按照参考资料中的教程一路继续
做到格式化新分区就可以了，注意mmcblk0p3要替换成自己的盘符&lt;/p>
&lt;pre>&lt;code class="language-shell">mkfs.ext4 /dev/mmcblk0p3
&lt;/code>&lt;/pre>
&lt;p>运行&lt;/p>
&lt;pre>&lt;code>fdisk -l
&lt;/code>&lt;/pre>
&lt;p>或者&lt;/p>
&lt;pre>&lt;code>df -h
&lt;/code>&lt;/pre>
&lt;p>命令，查看是否成功创建新分区。&lt;/p>
&lt;p>然后在Luci web界面里面增加挂载点：
我是直接从OpenWrt官网下的，不是修改版，所以木有这个选项。&lt;/p>
&lt;pre>&lt;code class="language-shell">opkg update
opkg install block-mount
&lt;/code>&lt;/pre>
&lt;p>重启路由，界面会有挂载点出现，进入
&lt;img src="https://winotmk.github.io/images/20230614222923.png"
loading="lazy"
>&lt;/p>
&lt;p>挂载刚才格式化的硬盘以后
&lt;img src="https://winotmk.github.io/images/20230614223908.png"
loading="lazy"
>&lt;/p>
&lt;p>复制这段&lt;/p>
&lt;pre>&lt;code class="language-shell">mkdir -p /tmp/introot
mkdir -p /tmp/extroot
mount --bind / /tmp/introot
mount /dev/sda1 /tmp/extroot
tar -C /tmp/introot -cvf - . | tar -C /tmp/extroot -xf -
umount /tmp/introot
umount /tmp/extroot
&lt;/code>&lt;/pre>
&lt;p>其中的&lt;/p>
&lt;pre>&lt;code>mount /dev/sda1 /tmp/extroot
&lt;/code>&lt;/pre>
&lt;p>要改为&lt;/p>
&lt;pre>&lt;code>mount /dev/mmcblk0p3 /tmp/extroot
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://winotmk.github.io/images/20230617234310.png"
loading="lazy"
>
满血了！！&lt;/p></description></item><item><title>树莓派上架设TimeMachine服务</title><link>https://winotmk.github.io/posts/%E6%A0%91%E8%8E%93%E6%B4%BEtimemachine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://winotmk.github.io/posts/%E6%A0%91%E8%8E%93%E6%B4%BEtimemachine/</guid><description>&lt;p>{% asset_img 20211013_002640.png 800 %}&lt;/p>
&lt;h2 id="命令">命令
&lt;/h2>&lt;p>前半参考：
&lt;a class="link" href="https://zhuanlan.zhihu.com/p/335259509" target="_blank" rel="noopener"
>从此Mac上的文件再也不会丟了&lt;/a>&lt;/p>
&lt;p>后半参考：
&lt;a class="link" href="https://www.jianshu.com/p/d9b180f6d397" target="_blank" rel="noopener"
>如何自己搭建一个Time Machine服务器&lt;/a>&lt;/p>
&lt;p>挂载硬盘目录&lt;/p>
&lt;pre>&lt;code>sudo mount /dev/sda2 /mnt/WinSource
&lt;/code>&lt;/pre>
&lt;p>1.安装netatalk和avahi（自己感觉avahi不装也行&lt;/p>
&lt;pre>&lt;code>sudo apt install netatalk avahi-daemon -y
&lt;/code>&lt;/pre>
&lt;p>2.创建账户wintm来访问TimeMachine，&lt;strong>至少别用root，root访问不能！&lt;/strong>&lt;/p>
&lt;pre>&lt;code>useradd -c &amp;quot;Time machine&amp;quot; -m -s /bin/bash wintm
&lt;/code>&lt;/pre>
&lt;p>然后设置密码&lt;/p>
&lt;pre>&lt;code>sudo passwd wintm
&lt;/code>&lt;/pre>
&lt;!-- more -->
&lt;p>3.配置netatalk&lt;/p>
&lt;pre>&lt;code>sudo nano /etc/netatalk/AppleVolumes.default
&lt;/code>&lt;/pre>
&lt;p>这个文件似乎一行代表一个服务
可以在&lt;/p>
&lt;pre>&lt;code># The line below sets some DEFAULT, starting with Netatalk 2.1.
:DEFAULT: options:upriv,usedots
# By default all users have access to their home directories.
~/ &amp;quot;Home Directory&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>下面加上一行&lt;/p>
&lt;pre>&lt;code>/mnt/WinSource/TimeMachine WinMachine allow:wintm options:tm
#挂在硬盘里的文件夹 afp服务名 允许wintm用户登陆 开启timemachine
&lt;/code>&lt;/pre>
&lt;p>4.重启服务&lt;/p>
&lt;pre>&lt;code>sudo service netatalk restart
sudo service avahi-daemon restart
&lt;/code>&lt;/pre>
&lt;h2 id="一些坑">一些坑
&lt;/h2>&lt;ul>
&lt;li>试图直接使用root账户连接，在这里卡了很久，还尝试在&lt;strong>AppleVolumes.default&lt;/strong>设置里写上例如&lt;/li>
&lt;/ul>
&lt;p>&lt;code>/mnt/WinSource/TimeMachine WinMachine allow:root rwlist:root options:tm&lt;/code>&lt;/p>
&lt;p>翻到这篇：&lt;a class="link" href="https://www.it610.com/article/1297957643536637952.htm" target="_blank" rel="noopener"
>[NAS之旅]-基于Centos7搭建Netatalk为Windows增加AFP协议&lt;/a>&lt;/p>
&lt;p>才忽然醒悟，&lt;strong>root用户是禁止登录AFP服务&lt;/strong>的，得嘞，新开个专门的用户吧&lt;/p>
&lt;p>提到了新建一个用户来跑timemachine：&lt;a class="link" href="https://www.jianshu.com/p/d9b180f6d397" target="_blank" rel="noopener"
>如何自己搭建一个Time Machine服务器&lt;/a>&lt;/p>
&lt;ul>
&lt;li>一开始习惯将硬盘挂载到&lt;code>/root/WinSource&lt;/code>，然鹅这似乎导致即便mac上TimeMachine连接上了也报错没法开始备份，想想也是wintm用户没有权限进root。。总结为避免不必要的麻烦以后硬盘不挂&lt;code>/root&lt;/code>里，这里我挂进了&lt;code>/mnt&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>ps:当时还试图对&lt;code>/root/WinSource&lt;/code>使用chown&lt;/p>
&lt;pre>&lt;code>sudo chown -R wintm:wintm /root/WinSource
&lt;/code>&lt;/pre>
&lt;p>见这篇：&lt;a class="link" href="https://aaron67.cc/2017/01/14/rpi-as-time-capsule/" target="_blank" rel="noopener"
>用树莓派实现 Time Capsule&lt;/a>&lt;/p>
&lt;p>无解，chown改不了&lt;code>WinSource&lt;/code>目录的所有者，root强而有力，认输&lt;/p>
&lt;h2 id="补充连接">补充连接
&lt;/h2>&lt;p>NetaTalk官方文档和下载：&lt;a class="link" href="http://netatalk.sourceforge.net/3.1/htmldocs/afp.conf.5.html" target="_blank" rel="noopener"
>http://netatalk.sourceforge.net/3.1/htmldocs/afp.conf.5.html&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://openwrt.org/zh/docs/guide-user/services/nas/netatalk_configuration#afp_netatalk_%e5%88%86%e4%ba%ab%e9%85%8d%e7%bd%ae_%e5%8f%88%e5%90%8d_apple_time_machine" target="_blank" rel="noopener"
>AFP Netatalk 分享配置 (又名 Apple Time Machine).&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.maxisvest.com/%e4%bd%bf%e7%94%a8netatalk%e6%89%93%e9%80%a0%e4%b8%80%e6%ac%be%e5%b1%9e%e4%ba%8e%e8%87%aa%e5%b7%b1%e7%9a%84Time-Machine%e5%9c%a8%e7%ba%bf%e5%a4%87%e4%bb%bd%e6%9c%8d%e5%8a%a1%e5%99%a8/" target="_blank" rel="noopener"
>使用netatalk打造一款属于自己的Time-Machine在线备份服务器&lt;/a>&lt;/p></description></item></channel></rss>