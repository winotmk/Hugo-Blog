<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Rashbeerypi on WinNote</title>
        <link>http://localhost:8560/tags/rashbeerypi/</link>
        <description>Recent content in Rashbeerypi on WinNote</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>winotmk</copyright>
        <lastBuildDate>Wed, 24 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:8560/tags/rashbeerypi/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>段码屏开发—GPT4o带来的一点点震撼</title>
        <link>http://localhost:8560/posts/240724_%E6%AE%B5%E7%A0%81%E5%B1%8F%E5%BC%80%E5%8F%91gpt4o%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E9%9C%87%E6%92%BC/</link>
        <pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:8560/posts/240724_%E6%AE%B5%E7%A0%81%E5%B1%8F%E5%BC%80%E5%8F%91gpt4o%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E9%9C%87%E6%92%BC/</guid>
        <description>&lt;h2 id=&#34;硬件简介&#34;&gt;硬件简介
&lt;/h2&gt;&lt;h3 id=&#34;屏幕&#34;&gt;屏幕
&lt;/h3&gt;&lt;p&gt;屏幕使用了一块微雪的电子墨水段码屏&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240726135400.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
文档在这里：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.waveshare.net/wiki/1.9inch_Segment_e-Paper_Module_Manual&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.waveshare.net/wiki/1.9inch_Segment_e-Paper_Module_Manual&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;mcu&#34;&gt;MCU
&lt;/h3&gt;&lt;p&gt;MCU方面就是树莓派的PICO，只不过是物理体积更小的版本，用法是一模一样的&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240726135455.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.waveshare.net/wiki/RP2040-Zero&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.waveshare.net/wiki/RP2040-Zero&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;字节byte和比特bit的对应&#34;&gt;字节(byte)和比特(bit)的对应
&lt;/h2&gt;&lt;p&gt;最近买了块高颜值段码屏，电子墨水屏原理的，一直没弄明白这个文档里说得是个啥意思，恰好最近尝试使用GPT来解决我遇到的一些编程问题，&lt;br&gt;
本来只是抱着试试看的态度，因为自从chatgpt火了以后一直持观望态度，印象中还只是能给它设定模仿人格写写小说一类的，然而这次实在小震撼到我&lt;br&gt;
起初这个表对于完全没接触过这块的我完全不动他是什么意思&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:8560/images/20240724185010.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;疑惑的关键在于0x00怎么就全0，而0xff怎么就全1了呢，于是我问GPT：&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240724185139.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
*&lt;strong&gt;以下是GPT的回答&lt;/strong&gt;&lt;br&gt;
在这个图表中，每个字节（byte）由 8 个比特（bit）组成，且每个比特都可以存储一个二进制值（0 或 1）。这些比特在图像中对应的像素（pixel）上，决定了每个像素的颜色（例如，黑色或白色）。&lt;/p&gt;
&lt;h3 id=&#34;理解图表中的内容&#34;&gt;理解图表中的内容
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;像素 (pixel): 从 1 到 16 的编号表示每个像素的位置。&lt;/li&gt;
&lt;li&gt;比特 (bit): 每个像素位置对应一个比特，从 7 到 0 代表一个字节中的每一位。&lt;/li&gt;
&lt;li&gt;存储的数据: 存储在比特中的数据值（0 或 1）。&lt;/li&gt;
&lt;li&gt;对应的颜色: 由数据值决定的像素颜色（黑色或白色）。&lt;br&gt;
5。 字节 (byte): 0x00 和 0xff 表示字节的十六进制值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;字节和比特的对应关系&#34;&gt;字节和比特的对应关系
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个字节有 8 位，每一位可以是 0 或 1。&lt;/li&gt;
&lt;li&gt;0x00 表示 8 个比特全部为 0，转换为二进制是 00000000。&lt;/li&gt;
&lt;li&gt;0xff 表示 8 个比特全部为 1，转换为二进制是 11111111。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解释示例&#34;&gt;解释示例
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;0x00 字节:
&lt;ul&gt;
&lt;li&gt;二进制表示：00000000&lt;/li&gt;
&lt;li&gt;每个比特位都是 0，因此对应的像素颜色是黑色。&lt;/li&gt;
&lt;li&gt;从像素 1 到 8 的存储数据都是 0，所以对应颜色都是黑色。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;0xff 字节:
&lt;ul&gt;
&lt;li&gt;二进制表示：11111111&lt;/li&gt;
&lt;li&gt;每个比特位都是 1，因此对应的像素颜色是白色。&lt;/li&gt;
&lt;li&gt;从像素 9 到 16 的存储数据都是 1，所以对应颜色都是白色。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例代码解释&#34;&gt;示例代码解释
&lt;/h3&gt;&lt;p&gt;如果你想用代码来解释字节和比特之间的关系，可以如下示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 示例字节
byte_00 = 0x00  # 所有比特位都是 0
byte_ff = 0xff  # 所有比特位都是 1

# 打印二进制表示
print(f&amp;quot;0x00 的二进制表示: {bin(byte_00)[2:].zfill(8)}&amp;quot;)
print(f&amp;quot;0xff 的二进制表示: {bin(byte_ff)[2:].zfill(8)}&amp;quot;)

# 转换为像素颜色
pixels_00 = [&amp;quot;■&amp;quot; if bit == &#39;0&#39; else &amp;quot;□&amp;quot; for bit in bin(byte_00)[2:].zfill(8)]
pixels_ff = [&amp;quot;■&amp;quot; if bit == &#39;0&#39; else &amp;quot;□&amp;quot; for bit in bin(byte_ff)[2:].zfill(8)]

print(f&amp;quot;0x00 对应的像素颜色: {&#39;&#39;.join(pixels_00)}&amp;quot;)
print(f&amp;quot;0xff 对应的像素颜色: {&#39;&#39;.join(pixels_ff)}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出&#34;&gt;输出
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;复制代码
0x00 的二进制表示: 00000000
0xff 的二进制表示: 11111111
0x00 对应的像素颜色: ■■■■■■■■
0xff 对应的像素颜色: □□□□□□□□
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里，■ 表示黑色像素，□ 表示白色像素。这个代码示例展示了如何根据字节中的比特值确定像素颜色。&lt;/p&gt;
 &lt;!-- more --&gt;
&lt;p&gt;天呐！有理有据条例清晰，秒懂了，原来byte是十六进制要转为二进制的！而8位二进制就可以表示8个数码管的开与关了！&lt;/p&gt;
&lt;h2 id=&#34;数字显示与byte的对应&#34;&gt;数字显示与byte的对应
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:8560/images/20240724190425.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;*&lt;strong&gt;GPT回答：&lt;/strong&gt;&lt;br&gt;
为了将数字 23.8 和 54.9 表示为 DSPNUM_1in9_off 数组中的十六进制值，我们需要将每一位数字对应的十六进制编码放入数组的正确位置。根据你提供的映射：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;0 ：0xbf, 0x1f&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1 ：0x00, 0x1f&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2 ：0xfd, 0x17&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3 ：0xf5, 0x1f&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4 ：0x47, 0x1f&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5 ：0xf7, 0x1d&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6 ：0xff, 0x1d&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;7 ：0x21, 0x1f&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;8 ：0xff, 0x1f&lt;br&gt;
-9 ：0xf7, 0x1f&lt;br&gt;
根据你的要求：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字 A 为 23.8&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;十位 2 对应 DSPNUM_1in9_off[1] 和 DSPNUM_1in9_off[2]&lt;/li&gt;
&lt;li&gt;个位 3 对应 DSPNUM_1in9_off[3] 和 DSPNUM_1in9_off[4]&lt;/li&gt;
&lt;li&gt;小数点后一位 8 对应 DSPNUM_1in9_off[11] 和 DSPNUM_1in9_off[12]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字 B 为 54.9&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;十位 5 对应 DSPNUM_1in9_off[5] 和 DSPNUM_1in9_off[6]&lt;/li&gt;
&lt;li&gt;个位 4 对应 DSPNUM_1in9_off[7] 和 DSPNUM_1in9_off[8]&lt;/li&gt;
&lt;li&gt;小数点后一位 9 对应 DSPNUM_1in9_off[9] 和 DSPNUM_1in9_off[10]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;替换数组&#34;&gt;替换数组
&lt;/h3&gt;&lt;p&gt;将这些值替换到数组 DSPNUM_1in9_off 中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;unsigned char DSPNUM_1in9_off[] = {
    0x00,  // [0]  保持为 0x00
    0xfd,  // [1]  数字 A 的十位 2 对应
    0x17,  // [2]  数字 A 的十位 2 对应
    0xf5,  // [3]  数字 A 的个位 3 对应
    0x1f,  // [4]  数字 A 的个位 3 对应
    0xf7,  // [5]  数字 B 的十位 5 对应
    0x1d,  // [6]  数字 B 的十位 5 对应
    0x47,  // [7]  数字 B 的个位 4 对应
    0x1f,  // [8]  数字 B 的个位 4 对应
    0xf7,  // [9]  数字 B 的小数点后一位 9 对应
    0x1f,  // [10] 数字 B 的小数点后一位 9 对应
    0xff,  // [11] 数字 A 的小数点后一位 8 对应
    0x1f,  // [12] 数字 A 的小数点后一位 8 对应
    0x00,  // [13] 保持为 0x00
    0x00,  // [14] 保持为 0x00
    0x00   // [15] 保持为 0x00
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;最终数组&#34;&gt;最终数组
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;unsigned char DSPNUM_1in9_off[] = {
    0x00, 0xfd, 0x17, 0xf5, 0x1f, 0xf7, 0x1d, 0x47, 0x1f, 0xf7, 0x1f, 0xff, 0x1f, 0x00, 0x00, 0x00
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个数组 DSPNUM_1in9_off 现在包含了你要求的数字 A 和 B 的十六进制表示形式。&lt;/p&gt;
&lt;p&gt;GPT准确无误的理解了我的意思，这是这段代码直接得到的结果！！：&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240726134530.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;动态将数字转换为对应的段码&#34;&gt;动态将数字转换为对应的段码
&lt;/h2&gt;&lt;p&gt;上面一段只是实现了数字到段码的转换，作为一个温度计肯定需要每隔一段时间就将读取的温度传到这个数组里，所以我继续问&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240726134819.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
GPT又准确无误的给了我方案：&lt;/p&gt;
&lt;h3 id=&#34;动态调整数组的代码&#34;&gt;动态调整数组的代码
&lt;/h3&gt;&lt;p&gt;为了动态调整 DSPNUM_1in9_off 数组，你可以编写一个函数，根据给定的 A 和 B 数值，动态设置数组的值。这个函数可以使用一个查找表来将数字映射到相应的字节值。&lt;/p&gt;
&lt;p&gt;以下是一个实现示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

// 定义数字对应的字节数组
unsigned char digit_bytes[10][2] = {
    {0xbf, 0x1f},  // 0
    {0x00, 0x1f},  // 1
    {0xfd, 0x17},  // 2
    {0xf5, 0x1f},  // 3
    {0x47, 0x1f},  // 4
    {0xf7, 0x1d},  // 5
    {0xff, 0x1d},  // 6
    {0x21, 0x1f},  // 7
    {0xff, 0x1f},  // 8
    {0xf7, 0x1f}   // 9
};

// 定义DSPNUM_1in9_off数组
unsigned char DSPNUM_1in9_off[16] = {0};

// 更新数组的函数
void update_display(double A, double B) {
    // 提取 A 和 B 的各位数字
    int A_tens = (int)(A / 10) % 10;
    int A_units = (int)A % 10;
    int A_decimal = (int)(A * 10) % 10;
    
    int B_tens = (int)(B / 10) % 10;
    int B_units = (int)B % 10;
    int B_decimal = (int)(B * 10) % 10;
    
    // 设置数字 A
    DSPNUM_1in9_off[1] = digit_bytes[A_tens][0];
    DSPNUM_1in9_off[2] = digit_bytes[A_tens][1];
    DSPNUM_1in9_off[3] = digit_bytes[A_units][0];
    DSPNUM_1in9_off[4] = digit_bytes[A_units][1];
    DSPNUM_1in9_off[11] = digit_bytes[A_decimal][0];
    DSPNUM_1in9_off[12] = digit_bytes[A_decimal][1];
    
    // 设置数字 B
    DSPNUM_1in9_off[5] = digit_bytes[B_tens][0];
    DSPNUM_1in9_off[6] = digit_bytes[B_tens][1];
    DSPNUM_1in9_off[7] = digit_bytes[B_units][0];
    DSPNUM_1in9_off[8] = digit_bytes[B_units][1];
    DSPNUM_1in9_off[9] = digit_bytes[B_decimal][0];
    DSPNUM_1in9_off[10] = digit_bytes[B_decimal][1];
}

int main() {
    double A = 23.8;
    double B = 54.9;

    // 更新显示
    update_display(A, B);

    // 打印数组内容以验证
    for (int i = 0; i &amp;lt; 16; i++) {
        printf(&amp;quot;0x%02x &amp;quot;, DSPNUM_1in9_off[i]);
    }
    printf(&amp;quot;\n&amp;quot;);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解释&#34;&gt;解释
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数字到字节的映射表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;digit_bytes 数组包含了每个数字（0 到 9）对应的两个字节的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提取数字位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用整数除法和取模运算提取 A 和 B 的十位、个位和小数点后一位。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新显示数组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用提取到的数字位将 DSPNUM_1in9_off 数组的相应位置更新为查找表中的字节值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义 A 和 B 的值，调用 update_display 函数更新显示数组，并打印数组内容以验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，DSPNUM_1in9_off 数组将根据传入的 A 和 B 值动态更新。&lt;/p&gt;
&lt;h2 id=&#34;小数点的处理&#34;&gt;小数点的处理
&lt;/h2&gt;&lt;p&gt;上面已经完整实现了两个数字到数组内的转换，但是转出来没有小数点，根据文档：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:8560/images/20240726135629.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;所以要在数组的第4，8，10位做些处理&lt;/p&gt;
&lt;p&gt;我继续对GPT说&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:8560/images/20240726135810.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;GPT回答：&lt;/p&gt;
&lt;p&gt;为了实现这个功能，我们需要将特定数组位置的十六进制数转换为二进制，修改二进制数中的特定位，然后将其转换回十六进制并存储在数组中。&lt;/p&gt;
&lt;p&gt;以下是修改后的代码，包括处理 DSPNUM_1in9_off[4], DSPNUM_1in9_off[8] 和 DSPNUM_1in9_off[10]：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

// 定义数字对应的字节数组
unsigned char digit_bytes[10][2] = {
    {0xbf, 0x1f},  // 0
    {0x00, 0x1f},  // 1
    {0xfd, 0x17},  // 2
    {0xf5, 0x1f},  // 3
    {0x47, 0x1f},  // 4
    {0xf7, 0x1d},  // 5
    {0xff, 0x1d},  // 6
    {0x21, 0x1f},  // 7
    {0xff, 0x1f},  // 8
    {0xf7, 0x1f}   // 9
};

// 定义DSPNUM_1in9_off数组
unsigned char DSPNUM_1in9_off[16] = {0};

// 将第六位从右往左数改成1的函数
unsigned char set_sixth_bit_to_one(unsigned char value) {
    return value | (1 &amp;lt;&amp;lt; 5);  // 第六位对应的二进制位是 5，从0开始计数
}

// 更新数组的函数
void update_display(double A, double B) {
    // 提取 A 和 B 的各位数字
    int A_tens = (int)(A / 10) % 10;
    int A_units = (int)A % 10;
    int A_decimal = (int)(A * 10) % 10;
    
    int B_tens = (int)(B / 10) % 10;
    int B_units = (int)B % 10;
    int B_decimal = (int)(B * 10) % 10;
    
    // 设置数字 A
    DSPNUM_1in9_off[1] = digit_bytes[A_tens][0];
    DSPNUM_1in9_off[2] = digit_bytes[A_tens][1];
    DSPNUM_1in9_off[3] = digit_bytes[A_units][0];
    DSPNUM_1in9_off[4] = set_sixth_bit_to_one(digit_bytes[A_units][1]);  // 修改第六位
    DSPNUM_1in9_off[11] = digit_bytes[A_decimal][0];
    DSPNUM_1in9_off[12] = digit_bytes[A_decimal][1];
    
    // 设置数字 B
    DSPNUM_1in9_off[5] = digit_bytes[B_tens][0];
    DSPNUM_1in9_off[6] = digit_bytes[B_tens][1];
    DSPNUM_1in9_off[7] = digit_bytes[B_units][0];
    DSPNUM_1in9_off[8] = set_sixth_bit_to_one(digit_bytes[B_units][1]);  // 修改第六位
    DSPNUM_1in9_off[9] = digit_bytes[B_decimal][0];
    DSPNUM_1in9_off[10] = set_sixth_bit_to_one(digit_bytes[B_decimal][1]);  // 修改第六位
}

int main() {
    double A = 23.8;
    double B = 54.9;

    // 更新显示
    update_display(A, B);

    // 打印数组内容以验证
    for (int i = 0; i &amp;lt; 16; i++) {
        printf(&amp;quot;0x%02x &amp;quot;, DSPNUM_1in9_off[i]);
    }
    printf(&amp;quot;\n&amp;quot;);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解释-1&#34;&gt;解释
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;函数 set_sixth_bit_to_one:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用位运算将一个字节的第六位（从右数）设置为 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新 DSPNUM_1in9_off 数组:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照你的要求更新数字 A 和 B 的各个位数字。&lt;/li&gt;
&lt;li&gt;在设置 DSPNUM_1in9_off[4], DSPNUM_1in9_off[8] 和 DSPNUM_1in9_off[10] 时，调用 set_sixth_bit_to_one 函数将其第六位设置为 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;结果&#34;&gt;结果
&lt;/h3&gt;&lt;p&gt;运行代码后，DSPNUM_1in9_off 数组将根据 A 和 B 的值动态更新，并且 DSPNUM_1in9_off[4], DSPNUM_1in9_off[8] 和 DSPNUM_1in9_off[10] 的第六位将被设置为 1。&lt;/p&gt;
&lt;p&gt;然后我就得到了：&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240726142601.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
这里数字是我手动指定的&lt;code&gt;A=73.6&lt;/code&gt;,&lt;code&gt;B=84.9&lt;/code&gt;，可以看到小数点，百分号都已经显示出来了&lt;/p&gt;
&lt;p&gt;再接入传感器读到的数值，温度计就差不多完工啦：&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240726142737.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;顺便一提这里的传感器驱动代码也是GPT帮调整的，真是神奇&lt;/p&gt;
</description>
        </item>
        <item>
        <title>地理数据采集器计划</title>
        <link>http://localhost:8560/posts/240617_%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%99%A8%E8%AE%A1%E5%88%92/</link>
        <pubDate>Mon, 17 Jun 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:8560/posts/240617_%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%99%A8%E8%AE%A1%E5%88%92/</guid>
        <description>&lt;h2 id=&#34;简介&#34;&gt;简介
&lt;/h2&gt;&lt;p&gt;想要做一个便携的小设备，能够实现以下功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录当前地点的气压，温度，湿度等地理信息&lt;/li&gt;
&lt;li&gt;记录GPS坐标信息&lt;/li&gt;
&lt;li&gt;考虑加上摄像头记录当前周围视觉环境，同时可以将上述信息水印（字幕)在照片上&lt;/li&gt;
&lt;li&gt;存储所有记录的数据以便之后进行可视化数据生成，可以用类似XML，Json，或者找有没有嵌入式轻量数据库实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它最好有以下这样的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手机一般大小可以塞进口袋&lt;/li&gt;
&lt;li&gt;一定程度的防摔防水外壳&lt;/li&gt;
&lt;li&gt;续航可以接受2-3天一充电&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以我的打算用现有的能买到的小板子和单片机来做，预算不是大问题，大概1500-2000，（包含试错和学习成本）考虑过几种方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ESP32&lt;/li&gt;
&lt;li&gt;树莓派PICO&lt;/li&gt;
&lt;li&gt;幸狐的板子和摄像头&lt;/li&gt;
&lt;li&gt;树莓派Zero&lt;br&gt;
最后发现现在目前树莓派zero2w的价格只有一百出头了，可能比某些arduino的原版板子还便宜，值得一试，幸狐看起来也不错的样子，回头再研究&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面这是树莓派zero2w跑通串口通信时的样子&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:8560/images/20240617150029.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;这个网站不错：https://pinout.xyz/&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:8560/images/20240618185812.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;可知右上这几个接口就可以实现TTL的UART连接了，我尝试ground是要接的&lt;/p&gt;
&lt;h2 id=&#34;资料&#34;&gt;资料
&lt;/h2&gt;&lt;h3 id=&#34;ft232串口工具&#34;&gt;FT232串口工具
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.waveshare.net/wiki/FT232_USB_UART_Board&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.waveshare.net/wiki/FT232_USB_UART_Board&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240619160444.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;gps模块&#34;&gt;GPS模块
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.waveshare.net/wiki/LC76G_GPS_Module&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.waveshare.net/wiki/LC76G_GPS_Module&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240619160514.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
在准备安装micropyGPS时&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240619160324.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
提示&lt;code&gt;No module namd setuptools&lt;/code&gt;&lt;br&gt;
怀疑需要执行&lt;br&gt;
&lt;code&gt;apt-get install python3-setuptools&lt;/code&gt;&lt;br&gt;
可惜目前没有网络环境，回家尝试了&lt;/p&gt;
&lt;h3 id=&#34;raspberry-zero-2w&#34;&gt;Raspberry Zero 2W
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.waveshare.net/wiki/Raspberry_Pi_Zero_2_W&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.waveshare.net/wiki/Raspberry_Pi_Zero_2_W&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240619160629.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;ups-模块&#34;&gt;UPS 模块
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.waveshare.net/wiki/UPS_HAT_%28C%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.waveshare.net/wiki/UPS_HAT_(C)&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240619160718.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;环境传感器&#34;&gt;环境传感器
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.waveshare.net/shop/Environment-Sensor-HAT.htm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.waveshare.net/shop/Environment-Sensor-HAT.htm&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240619160754.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;项目软件&#34;&gt;项目/软件
&lt;/h2&gt;&lt;h3 id=&#34;数据可视化相关&#34;&gt;数据可视化相关
&lt;/h3&gt;&lt;h4 id=&#34;很不错的开源教程data-science-for-beginners&#34;&gt;很不错的开源教程Data-Science-For-Beginners
&lt;/h4&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://microsoft.github.io/Data-Science-For-Beginners/#/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://microsoft.github.io/Data-Science-For-Beginners/#/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;matplotlib&#34;&gt;Matplotlib
&lt;/h4&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://matplotlib.org/stable/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://matplotlib.org/stable/index.html&lt;/a&gt;&lt;br&gt;
Matplotlib是一个出色的库，可用于创建各种简单和复杂的图表&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://microsoft.github.io/Data-Science-For-Beginners/#/3-Data-Visualization/09-visualization-quantities/README&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://microsoft.github.io/Data-Science-For-Beginners/#/3-Data-Visualization/09-visualization-quantities/README&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240717142402.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;streamlit&#34;&gt;Streamlit
&lt;/h4&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/streamlit/streamlit&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/streamlit/streamlit&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240717143550.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
更偏向于python库直接生成web，同时也有很多数据可视化的内容，更实用？便于展示&lt;/p&gt;
&lt;h4 id=&#34;powerbi&#34;&gt;powerbi
&lt;/h4&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.microsoft.com/en-us/power-platform/products/power-bi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.microsoft.com/en-us/power-platform/products/power-bi&lt;/a&gt;&lt;br&gt;
似乎是微软的web数据可视化绘图&lt;/p&gt;
&lt;h4 id=&#34;gpxsee&#34;&gt;GPXSee
&lt;/h4&gt;&lt;p&gt;配合gps数据收集可以展示出来&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/tumic0/GPXSee&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/tumic0/GPXSee&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240719120310.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;图形库&#34;&gt;图形库
&lt;/h3&gt;&lt;h4 id=&#34;lvgl&#34;&gt;LVGL
&lt;/h4&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://lvgl.100ask.net/master/get-started/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://lvgl.100ask.net/master/get-started/index.html&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/lvgl/lvgl&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/lvgl/lvgl&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240719122911.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;squareline-studio-ui---配合上面的lvgl用&#34;&gt;SquareLine Studio UI - 配合上面的LVGL用
&lt;/h4&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://squareline.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://squareline.io/&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1DX4y1v727/?vd_source=b7b7bdf106a064893c3c79e4a961f383&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV1DX4y1v727/?vd_source=b7b7bdf106a064893c3c79e4a961f383&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:8560/images/20240719121330.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;guiguider-同上类别但免费&#34;&gt;guiguider 同上类别但免费
&lt;/h4&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1yW421R7zK/?spm_id_from=333.788.recommend_more_video.7&amp;amp;vd_source=b7b7bdf106a064893c3c79e4a961f383&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV1yW421R7zK/?spm_id_from=333.788.recommend_more_video.7&amp;vd_source=b7b7bdf106a064893c3c79e4a961f383&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240719122655.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;figma&#34;&gt;figma
&lt;/h4&gt;&lt;p&gt;UI前期设计软件&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20240719121825.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;ui-框架oled-ui-astra&#34;&gt;UI 框架：oled-ui-astra
&lt;/h4&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AstraThreshold/oled-ui-astra&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AstraThreshold/oled-ui-astra&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1i4421D7nJ/?vd_source=b7b7bdf106a064893c3c79e4a961f383&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV1i4421D7nJ/?vd_source=b7b7bdf106a064893c3c79e4a961f383&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:8560/images/20240719120151.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>树莓派路由器</title>
        <link>http://localhost:8560/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B7%AF%E7%94%B1%E5%99%A8/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:8560/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B7%AF%E7%94%B1%E5%99%A8/</guid>
        <description>&lt;h2 id=&#34;树莓派cm4的&#34;&gt;树莓派CM4的
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:8560/images/20230614212800.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;openwrt-web界面安装中文&#34;&gt;openWrt web界面安装中文
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/da01ce070688&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jianshu.com/p/da01ce070688&lt;/a&gt;&lt;br&gt;
更新包目录：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;opkg update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里一开始我不行，ping1.1.1.1和ping8.8.8.8都ping不通，然后忽然想起自己的科学梯子路由网关是192.168.50.4&lt;br&gt;
改之!!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:8560/images/20230614001635.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;可能还不行&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20230617224422.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
这俩防火墙设置一下&lt;/p&gt;
&lt;p&gt;如果还不行&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20230617231305.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
DNS记得指定一下&lt;/p&gt;
&lt;p&gt;这下就能通了&lt;/p&gt;
&lt;p&gt;PS也可以点配置opkg，然后加一条&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;src/gz openwrt_packages https://mirrors.ustc.edu.cn/openwrt/releases/22.03.5/packages/aarch64_cortex-a72/packages/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把源换为国内&lt;/p&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;opkg install luci-i18n-base-zh-cn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Configuring luci-i18n-base-zh-cn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再回来看web界面就已经是中文了&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20230614001825.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;如果要开启sftp传输服务&#34;&gt;如果要开启sftp传输服务
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/twn39/code/issues/279&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/twn39/code/issues/279&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开启sftp的话可以很方便用WinSCP登录，文件管理神器&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20230614002052.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
那么如何启用 sftp 服务呢？先安装对应的软件：&lt;/p&gt;
&lt;p&gt;opkg install vsftpd openssh-sftp-server&lt;br&gt;
设置系统开启后自动启动 sftp 服务：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/etc/init.d/vsftpd enable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动 sftp 服务：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; /etc/init.d/vsftpd start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样 Openwrt 就已经启用了 sftp 服务了，可以使用客户端进行文件的传输。&lt;/p&gt;
&lt;h2 id=&#34;装网卡驱动&#34;&gt;装网卡驱动
&lt;/h2&gt;&lt;p&gt;我的CM4拓展板子是微雪的这个&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20230617234921.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.waveshare.net/wiki/CM4-DUAL-ETH-MINI&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.waveshare.net/wiki/CM4-DUAL-ETH-MINI&lt;/a&gt;&lt;br&gt;
有两个网口ETH0是原生ETH1是PCIe转出来的，需要安装RTL8111H芯片的网卡驱动，查了一下软件包里是有的&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://openwrt.org/packages/pkgdata/kmod-r8169&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://openwrt.org/packages/pkgdata/kmod-r8169&lt;/a&gt;&lt;br&gt;
那么就好办了&lt;br&gt;
安装就行了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; opkg install kmod-r8169
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成以重启openwrt我们看到这里已经读到了eth1口&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20230614003210.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;设置路由器wan口&#34;&gt;设置路由器WAN口
&lt;/h2&gt;&lt;p&gt;添加新端口，设备选装好驱动以后出现的eth1，协议我选pppoe因为我拿路由拨号&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:8560/images/20230614003850.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;如果要自己加安装包&#34;&gt;如果要自己加安装包：
&lt;/h2&gt;&lt;p&gt;放到一个tmp目录里&lt;br&gt;
CD到tmp目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;opkg install *.ipk
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于扩容挂载点&#34;&gt;关于扩容挂载点
&lt;/h2&gt;&lt;p&gt;参考资料：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/e83459242afb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jianshu.com/p/e83459242afb&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/ls0111/article/details/128769859&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/ls0111/article/details/128769859&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PS我选的是树莓派cpu对应的ext4文件系统的固件，SQUASHFS就不碰了不熟悉&lt;br&gt;
首先安装安装cfdisk，注意这里要先更新下opkg&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;opkg update
opkg install cfdisk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后打开cfdisk&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cfdisk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是我打不开&lt;br&gt;
比如我的这块硬盘是内置EMMC硬盘, 显示名称是/dev/mmcblk0.&lt;br&gt;
一般的内置硬盘应该是/dev/sda之类的.&lt;/p&gt;
&lt;p&gt;使用cfdisk命令，进入分区页面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cfdisk /dev/mmcblk0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果普通是内置硬盘&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cfdisk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:8560/images/20230617234233.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
按照参考资料中的教程一路继续&lt;br&gt;
做到格式化新分区就可以了，注意mmcblk0p3要替换成自己的盘符&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkfs.ext4 /dev/mmcblk0p3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fdisk -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df -h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令，查看是否成功创建新分区。&lt;/p&gt;
&lt;p&gt;然后在Luci web界面里面增加挂载点：&lt;br&gt;
我是直接从OpenWrt官网下的，不是修改版，所以木有这个选项。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;opkg update
opkg install block-mount
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启路由，界面会有挂载点出现，进入&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20230614222923.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;挂载刚才格式化的硬盘以后&lt;br&gt;
&lt;img src=&#34;http://localhost:8560/images/20230614223908.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;复制这段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir -p /tmp/introot
mkdir -p /tmp/extroot
mount --bind / /tmp/introot
mount /dev/sda1 /tmp/extroot
tar -C /tmp/introot -cvf - . | tar -C /tmp/extroot -xf -
umount /tmp/introot
umount /tmp/extroot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mount /dev/sda1 /tmp/extroot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要改为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mount /dev/mmcblk0p3 /tmp/extroot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:8560/images/20230617234310.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;br&gt;
满血了！！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>树莓派上架设TimeMachine服务</title>
        <link>http://localhost:8560/posts/%E6%A0%91%E8%8E%93%E6%B4%BEtimemachine/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:8560/posts/%E6%A0%91%E8%8E%93%E6%B4%BEtimemachine/</guid>
        <description>&lt;p&gt;{% asset_img 20211013_002640.png 800 %}&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令
&lt;/h2&gt;&lt;p&gt;前半参考：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/335259509&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;从此Mac上的文件再也不会丟了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;后半参考：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/d9b180f6d397&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;如何自己搭建一个Time Machine服务器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;挂载硬盘目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mount /dev/sda2 /mnt/WinSource
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.安装netatalk和avahi（自己感觉avahi不装也行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install netatalk avahi-daemon -y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.创建账户wintm来访问TimeMachine，&lt;strong&gt;至少别用root，root访问不能！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;useradd -c &amp;quot;Time machine&amp;quot; -m -s /bin/bash wintm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后设置密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo passwd wintm
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;p&gt;3.配置netatalk&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo nano /etc/netatalk/AppleVolumes.default
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个文件似乎一行代表一个服务&lt;br&gt;
可以在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# The line below sets some DEFAULT, starting with Netatalk 2.1.
:DEFAULT: options:upriv,usedots

# By default all users have access to their home directories.
~/			&amp;quot;Home Directory&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面加上一行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/mnt/WinSource/TimeMachine WinMachine allow:wintm options:tm
#挂在硬盘里的文件夹           afp服务名   允许wintm用户登陆   开启timemachine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.重启服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo service netatalk restart
sudo service avahi-daemon restart
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;一些坑&#34;&gt;一些坑
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;试图直接使用root账户连接，在这里卡了很久，还尝试在&lt;strong&gt;AppleVolumes.default&lt;/strong&gt;设置里写上例如&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;/mnt/WinSource/TimeMachine WinMachine allow:root rwlist:root  options:tm&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;翻到这篇：&lt;a class=&#34;link&#34; href=&#34;https://www.it610.com/article/1297957643536637952.htm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;[NAS之旅]-基于Centos7搭建Netatalk为Windows增加AFP协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;才忽然醒悟，&lt;strong&gt;root用户是禁止登录AFP服务&lt;/strong&gt;的，得嘞，新开个专门的用户吧&lt;/p&gt;
&lt;p&gt;提到了新建一个用户来跑timemachine：&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/d9b180f6d397&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;如何自己搭建一个Time Machine服务器&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一开始习惯将硬盘挂载到&lt;code&gt;/root/WinSource&lt;/code&gt;，然鹅这似乎导致即便mac上TimeMachine连接上了也报错没法开始备份，想想也是wintm用户没有权限进root。。总结为避免不必要的麻烦以后硬盘不挂&lt;code&gt;/root&lt;/code&gt;里，这里我挂进了&lt;code&gt;/mnt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ps:当时还试图对&lt;code&gt;/root/WinSource&lt;/code&gt;使用chown&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo chown -R wintm:wintm /root/WinSource
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;见这篇：&lt;a class=&#34;link&#34; href=&#34;https://aaron67.cc/2017/01/14/rpi-as-time-capsule/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;用树莓派实现 Time Capsule&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;无解，chown改不了&lt;code&gt;WinSource&lt;/code&gt;目录的所有者，root强而有力，认输&lt;/p&gt;
&lt;h2 id=&#34;补充连接&#34;&gt;补充连接
&lt;/h2&gt;&lt;p&gt;NetaTalk官方文档和下载：&lt;a class=&#34;link&#34; href=&#34;http://netatalk.sourceforge.net/3.1/htmldocs/afp.conf.5.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://netatalk.sourceforge.net/3.1/htmldocs/afp.conf.5.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://openwrt.org/zh/docs/guide-user/services/nas/netatalk_configuration#afp_netatalk_%e5%88%86%e4%ba%ab%e9%85%8d%e7%bd%ae_%e5%8f%88%e5%90%8d_apple_time_machine&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AFP Netatalk 分享配置 (又名 Apple Time Machine).&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.maxisvest.com/%e4%bd%bf%e7%94%a8netatalk%e6%89%93%e9%80%a0%e4%b8%80%e6%ac%be%e5%b1%9e%e4%ba%8e%e8%87%aa%e5%b7%b1%e7%9a%84Time-Machine%e5%9c%a8%e7%ba%bf%e5%a4%87%e4%bb%bd%e6%9c%8d%e5%8a%a1%e5%99%a8/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;使用netatalk打造一款属于自己的Time-Machine在线备份服务器&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
