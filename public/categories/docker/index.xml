<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Docker on WinNote</title>
        <link>http://localhost:1313/categories/docker/</link>
        <description>Recent content in Docker on WinNote</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>winotmk</copyright>
        <lastBuildDate>Wed, 25 Sep 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/categories/docker/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>calibre_web的pdf封面提取问题</title>
        <link>http://localhost:1313/posts/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/</link>
        <pubDate>Wed, 25 Sep 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/</guid>
        <description>&lt;img src="http://pictures.winotmk.com/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/2025-03-06-14-40-56_199d9b99.png" alt="Featured image of post calibre_web的pdf封面提取问题" /&gt;&lt;p&gt;在用&lt;code&gt;johngong/calibre-web:latest&lt;/code&gt;这个镜像 &lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/r/johngong/calibre-web&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hub.docker.com/r/johngong/calibre-web&lt;/a&gt;&lt;br&gt;
作为自己nas上的图书馆时发现pdf文件无法生成封面，&lt;br&gt;
&lt;/p&gt;
&lt;p&gt;断断续续排查了两周，百思不得解，尝试过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置imagemagick的&lt;code&gt;policy.xml&lt;/code&gt;文件(&lt;code&gt;/etc/Imagemagick/policy.xml&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;使用lscr.io/linuxserver/calibre-web:latest的镜像&lt;/li&gt;
&lt;li&gt;自己重新构建镜像&lt;/li&gt;
&lt;li&gt;重新安装calibre-web包和重装imagemagick包&lt;br&gt;
都解决不了，总之是十分折腾，最后认为可能是&lt;code&gt;johngong/calibre-web:latest&lt;/code&gt;可能是里少了一个&lt;code&gt;imagemagick-pdf&lt;/code&gt;包&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;最终有效的解决方法的折腾流程&#34;&gt;最终有效的解决方法的折腾流程
&lt;/h2&gt;&lt;p&gt;我尝试上传pdf文件，然后打开日志（日志级别设置为DEBUG）&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/2025-03-06-14-41-10_803172c2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-41-10&#34;
	
	
&gt;&lt;br&gt;
查看文件：/config/calbre-web/calbre-web.log&lt;br&gt;
有这么一行：&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/2025-03-06-14-41-18_9e3752b4.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-41-18&#34;
	
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[2024-09-25 12:10:22,144]  WARN {cps.uploader:237} Cannot extract cover image, using default: no decode delegate for this image format `PDF&#39; @ error/constitute.c/ReadImage/746
[2024-09-25 12:10:22,145]  WARN {cps.uploader:238} On Windows this error could be caused by missing ghostscript
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PDF转就转不出来&lt;br&gt;
所以找到了：&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/2025-03-06-14-41-27_d93c03ad.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-41-27&#34;
	
	
&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/ImageMagick/ImageMagick/issues/6148&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ImageMagick/ImageMagick/issues/6148&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apk add --no-cache imagemagick imagemagick-pdf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完以后，再次尝试上传pdf格式的书，就看见封面辣！！&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/2025-03-06-14-41-37_10ffb4fc.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-41-37&#34;
	
	
&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;johngongcalibre-web的一些设置&#34;&gt;johngong/calibre-web的一些设置
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/gshang2017/docker/issues/133&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/gshang2017/docker/issues/133&lt;/a&gt;&lt;br&gt;
如果一编辑图书的元数据就卡死，可用尝试：&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/2025-03-06-14-41-57_941353e5.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-41-57&#34;
	
	
&gt;&lt;br&gt;
这两条设置为true,则&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/2025-03-06-14-42-04_5c2fe52c.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-42-04&#34;
	
	
&gt;&lt;br&gt;
这里不会出现google等选项，家里的nas没有梯子环境，反而会导致卡死，所以禁用google吧。。也没啥用&lt;/p&gt;
&lt;h2 id=&#34;弯路&#34;&gt;弯路
&lt;/h2&gt;&lt;p&gt;这里想记一下这个弯路，在calibre-web的FAQ里赫然记着有关pdf文件转不出封面的解决办法，说要改&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/2025-03-06-14-42-17_22504034.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-42-17&#34;
	
	
&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/janeczku/calibre-web/wiki/FAQ#what-to-do-if-cover-pictures-are-not-extracted-from-pdf-files&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/janeczku/calibre-web/wiki/FAQ#what-to-do-if-cover-pictures-are-not-extracted-from-pdf-files&lt;/a&gt;&lt;br&gt;
所以可以有&lt;code&gt;/etc/Imagemagick/policy.xml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;policymap&amp;gt;
    &amp;lt;policy domain=&amp;quot;coder&amp;quot; rights=&amp;quot;read | write&amp;quot; pattern=&amp;quot;{MSVG,MVG,PS,PDF,RSVG,SVG,XPS}&amp;quot; /&amp;gt;
&amp;lt;/policymap&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是最容易找到的一种解法，但我自己试了无用，没有上面的装&lt;code&gt;apk add imagemagick-pdf&lt;/code&gt;好使&lt;/p&gt;
&lt;h2 id=&#34;尝试出来的另一种pdf封面提取可行方法&#34;&gt;尝试出来的另一种PDF封面提取可行方法
&lt;/h2&gt;&lt;p&gt;这样做出来的calibre-web镜像可以实现PDF转换，但是没有电子书格式转换，没有禁用google元数据搜索，没有中文环境，懒得自己做了，还是修修用&lt;code&gt;johngong/calibre-web&lt;/code&gt;包吧&lt;br&gt;
为了试验，我用&lt;code&gt;FROM ubuntu:latest&lt;/code&gt;作为镜像基底，然后：&lt;/p&gt;
&lt;h3 id=&#34;装calibre-web&#34;&gt;装calibre-web
&lt;/h3&gt;&lt;p&gt;安装calibre-web：&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/2025-03-06-14-42-29_e301016f.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-42-29&#34;
	
	
&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/janeczku/calibre-web?tab=readme-ov-file#installation&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/janeczku/calibre-web?tab=readme-ov-file#installation&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/janeczku/calibre-web/wiki/Dependencies-in-Calibre-Web-Linux-and-Windows&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/janeczku/calibre-web/wiki/Dependencies-in-Calibre-Web-Linux-and-Windows&lt;/a&gt;&lt;br&gt;
这里也有提到&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://chenjiehua.me/others/calibre-web-personal-book-store.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://chenjiehua.me/others/calibre-web-personal-book-store.html&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install calibreweb
pip install calibreweb[metadata]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;装imagemagick&#34;&gt;装imagemagick
&lt;/h3&gt;&lt;p&gt;然后安装imagemagick&lt;br&gt;
官方：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://imagemagick.org/script/download.php&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://imagemagick.org/script/download.php&lt;/a&gt;&lt;br&gt;
也有提到：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/echohye/p/17727865.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/echohye/p/17727865.html&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt install imagemagick
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;装完后&lt;code&gt;convert&lt;/code&gt;和&lt;code&gt;magick&lt;/code&gt;命令应当是可用的&lt;/p&gt;
&lt;h3 id=&#34;手动装imagemagick&#34;&gt;手动装imagemagick
&lt;/h3&gt;&lt;p&gt;或者我用上面官方的magick文件手动配貌似也行：&lt;br&gt;
先把magick文件放入根目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./magick --appimage-extract
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.appimage.org/user-guide/troubleshooting/fuse.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.appimage.org/user-guide/troubleshooting/fuse.html&lt;/a&gt;&lt;br&gt;
提到了可以用&lt;code&gt;--appimage-extract&lt;/code&gt;直接释放出软件包来&lt;br&gt;
会发现释放出来文件在&lt;code&gt;/squashfs-root&lt;/code&gt;目录里&lt;br&gt;
设置环境变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export MAGICK_HOME=&amp;quot;/squashfs-root/usr&amp;quot;
export PATH=&amp;quot;$MAGICK_HOME/bin:$PATH&amp;quot;
export LD_LIBRARY_PATH=&amp;quot;${LD_LIBRARY_PATH:+$LD_LIBRARY_PATH:}$MAGICK_HOME/lib&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后imagemagick应该就能用了。。&lt;/p&gt;
&lt;h3 id=&#34;其他&#34;&gt;其他
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;lscr.io/linuxserver/calibre-web:latest&lt;/code&gt;&lt;br&gt;
这个镜像也不小，但功能还算完整，上传pdf可直接显示封面，但不是中文环境，而且部署到我的nas上后死活传不了新书说什么无法写入，懒得深究了，弃之&lt;/p&gt;
</description>
        </item>
        <item>
        <title>给docker容器内配置中文环境(minecraft开服相关)</title>
        <link>http://localhost:1313/posts/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/</link>
        <pubDate>Thu, 15 Aug 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/</guid>
        <description>&lt;img src="http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-38-55_dd26bed1.png" alt="Featured image of post 给docker容器内配置中文环境(minecraft开服相关)" /&gt;&lt;p&gt;最近找到个整合包（因为懒得一个个翻bbs&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/read/cv7403697/?spm_id_from=333.999.collection.opus.click&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/read/cv7403697/?spm_id_from=333.999.collection.opus.click&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-37-14_5daf4b61.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-37-14&#34;
	
	
&gt;&lt;br&gt;
这包里的mod和之前自己开的服务器高度相似，太棒啦，从1.7.10直升1.12.2，基本还都是熟悉的味道&lt;br&gt;
才知道mcbbs已经无了，然后才可发现mc百科已经这么好用了，连接直连发布curseforge和github，省去搬运步骤，也蛮好的！&lt;br&gt;
服务端有了，想通过docker容器部署到我的群晖NAS上，DS720+扩容了根16G内存条放着也是放着&lt;/p&gt;
&lt;h2 id=&#34;选取docker镜像&#34;&gt;选取docker镜像
&lt;/h2&gt;&lt;p&gt;docker hub里有官方镜像，用的是这个，体积精简，只运行环境jre就够了&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/_/openjdk/tags?page=1&amp;amp;page_size=&amp;amp;name=8u342&amp;amp;ordering=&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hub.docker.com/_/openjdk/tags?page=1&amp;page_size=&amp;name=8u342&amp;ordering=&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-37-24_d9e14fdf.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-37-24&#34;
	
	
&gt;&lt;br&gt;
所以直接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull openjdk:8u342-jre-slim
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后直接这样运行就好了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -it -d \
-p 25565:25565 \
-v E:\game\MC\1.12.2mohist_服务端:/mc \
-w /mc \
--name MC1122 \
openjdk:8u342-jre-slim \
java -Xms2G -Xmx8G -XX:+UseG1GC -XX:+AggressiveOpts -XX:+UseCompressedOops -jar Mohist-1.12.2-c950429-server.jar nogui
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然长，但是总的来说挺简单，用&lt;code&gt;openjdk:8u342-jre-slim&lt;/code&gt;镜像运行&lt;code&gt;java&lt;/code&gt;命令罢了，但是！&lt;br&gt;
出现了一个人让人感觉不爽的小问题，服务端的log输出以及游戏内服务端来的输出都是英文的，这在之前直接windows运行时不是这样的，所以第一反应是语言环境问题&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-37-36_07788262.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-37-36&#34;
	
	
&gt;&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-37-45_13b3dd1e.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-37-45&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;设置环境变量&#34;&gt;设置环境变量
&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;docker run&lt;/code&gt;的时候加上个参数&lt;code&gt;-e LANG=&amp;quot;zh_CN.UTF-8&amp;quot;&lt;/code&gt;，类似&lt;code&gt;export  LANG=zh_CN.UTF-8&lt;/code&gt;&lt;br&gt;
确定环境变量生效了：&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-37-53_a6720241.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-37-53&#34;
	
	
&gt;&lt;br&gt;
但没解决问题，反而似乎导致启动的时候不认识中文的mod文件名了&lt;/p&gt;
&lt;p&gt;在查找这个之后：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/myli92/article/details/139909499?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22139909499%22%2C%22source%22%3A%22unlogin%22%7D&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;docker 容器设置中文环境&lt;/a&gt;&lt;br&gt;
发现单纯设置&lt;code&gt;LANG&lt;/code&gt;的变量不行，容器里就没有中文字符集的&lt;/p&gt;
&lt;h3 id=&#34;查看已有语言&#34;&gt;查看已有语言
&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;locale -a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-38-02_afbf7a7b.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-38-02&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;安装中文环境&#34;&gt;安装中文环境
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/star1210644725/article/details/108747049&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;使用DockerFile的方式快速构建一个基础镜像，解决中文环境问题&lt;/a&gt;&lt;br&gt;
所以安装中文环境的命令可以是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install -y language-pack-zh-hans
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但这样不行！因为这个是ubuntu的命令，查看我的docker镜像的信息发现是以debian基底的&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-38-12_22f7f27f.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-38-12&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;看到:&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/forever_008/article/details/103720389&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Debian系统安装中文包&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dpkg-reconfigure locales
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后再选&lt;code&gt;zh_CN.UTF-8&lt;/code&gt;，可行，但是集成到镜像里没那么好使，还好有别的方法&lt;/p&gt;
&lt;h2 id=&#34;制作新镜像&#34;&gt;制作新镜像
&lt;/h2&gt;&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/wyazyf/article/details/90676364&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;dockerfile文件中给debian设置中文支持&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;dockerfile&#34;&gt;dockerfile
&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;FROM openjdk:8u342-jre-slim
RUN apt-get clean &amp;amp;&amp;amp; apt-get update &amp;amp;&amp;amp; apt-get install -y locales &amp;amp;&amp;amp;  localedef -c -f UTF-8 -i zh_CN zh_CN.utf8
WORKDIR /mc
ENV LANG zh_CN.UTF-8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存为dockerfile文件然后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t jre8u342_ch .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-38-29_a81e5d6e.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-38-29&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;测试运行&#34;&gt;测试运行
&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;docker run -it -d \
-p 25565:25565 \
-v E:\game\MC\1.12.2mohist_服务端:/mc \
--name MC1122 \
jre8u342_ch:latest \
java -Xms2G -Xmx8G -XX:+UseG1GC -XX:+AggressiveOpts -XX:+UseCompressedOops -jar Mohist-1.12.2-c950429-server.jar nogui
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为dockerfile里已经设置过&lt;code&gt;WORKDIR&lt;/code&gt;了所以不需要&lt;code&gt;-w&lt;/code&gt;参数&lt;/p&gt;
&lt;p&gt;这下不会报英文了&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-38-45_6edc5591.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-38-45&#34;
	
	
&gt;&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-38-55_dd26bed1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-38-55&#34;
	
	
&gt;&lt;br&gt;
游戏里也是中文环境的返回信息&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-39-04_802db859.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-39-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;部署到群晖&#34;&gt;部署到群晖
&lt;/h2&gt;&lt;p&gt;先把做好的镜像打包出来，方便传到群晖NAS里&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker save -o jre8u342_ch.tar jre8u342_ch:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先导入这个镜像&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-39-12_9a72b1a7.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-39-12&#34;
	
	
&gt;&lt;br&gt;
然后简单配置一下端口和mc服务器目录就可以了,和上面的&lt;code&gt;docker run&lt;/code&gt;其实是一样的&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-39-21_b14c7daa.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-39-21&#34;
	
	
&gt;&lt;br&gt;
端口的&lt;code&gt;25565&lt;/code&gt;是游戏端口&lt;code&gt;25575&lt;/code&gt;用作管理，下面会提到&lt;/p&gt;
&lt;h2 id=&#34;服务器远程管理&#34;&gt;服务器远程管理
&lt;/h2&gt;&lt;p&gt;用容器托管运行了，上哪去敲&lt;code&gt;/op xxxx&lt;/code&gt;和&lt;code&gt;/stop&lt;/code&gt;之类的管理命令呢？&lt;br&gt;
可以用rcon方案！&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://wiki.vg/RCON&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wiki.vg/RCON&lt;/a&gt;&lt;br&gt;
具体就是用这个软件：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/Tiiffi/mcrcon&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Tiiffi/mcrcon&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;安装和服务端配置&#34;&gt;安装和服务端配置：
&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;git clone https://github.com/Tiiffi/mcrcon.git
cd mcrcon
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后服务端也要配置一下，在&lt;code&gt;server.properties&lt;/code&gt;里的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enable-rcon=false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enable-rcon=true
rcon.password=your_passwd
rcon.port=25575
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;用法&#34;&gt;用法：
&lt;/h3&gt;&lt;p&gt;先连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mcrcon -H 服务器地址 -p your_passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后就可以一样敲各种minecraft管理命令了&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-39-34_c1b2c621.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-39-34&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;好了不说了博主我要去挖矿开荒了&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-39-41_25bad8ab.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-39-41&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/2025-03-06-14-39-48_4e5af823.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-39-48&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考
&lt;/h2&gt;&lt;p&gt;debian文档，第 8 章 国际化和本地化：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.debian.org/doc/manuals/debian-reference/ch08.zh-cn.html#_rationale_for_utf_8_locale&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.debian.org/doc/manuals/debian-reference/ch08.zh-cn.html#_rationale_for_utf_8_locale&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类似的打包好的docker环境MC服务器镜像有：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/itzg/docker-minecraft-server/tree/master&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/itzg/docker-minecraft-server/tree/master&lt;/a&gt;&lt;br&gt;
对我来说功能有点多，只是参考参考&lt;/p&gt;
</description>
        </item>
        <item>
        <title>用容器来运行streamlit</title>
        <link>http://localhost:1313/posts/240724_%E7%94%A8%E5%AE%B9%E5%99%A8%E6%9D%A5%E8%BF%90%E8%A1%8Cstreamlit/</link>
        <pubDate>Wed, 24 Jul 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/240724_%E7%94%A8%E5%AE%B9%E5%99%A8%E6%9D%A5%E8%BF%90%E8%A1%8Cstreamlit/</guid>
        <description>&lt;img src="http://pictures.winotmk.com/240724_%E7%94%A8%E5%AE%B9%E5%99%A8%E6%9D%A5%E8%BF%90%E8%A1%8Cstreamlit/2025-03-06-14-16-24_bf12f74b.png" alt="Featured image of post 用容器来运行streamlit" /&gt;&lt;p&gt;&lt;br&gt;
一开始玩这个的时候就在想用docker跑，因为实在不想在本机里搭各种乱七八糟的环境，也懒得用Anaconda那样的中间环境，总感觉本地跑个模型才用得上那种大玩意儿，于是在dockerhub上找了找&lt;br&gt;
一些已有的可用镜像：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/r/aminehy/docker-streamlit-app&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hub.docker.com/r/aminehy/docker-streamlit-app&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/r/samdobson/streamlit&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hub.docker.com/r/samdobson/streamlit&lt;/a&gt;&lt;br&gt;
就是镜像build都好几年前了，实测目前有些新的例程都跑不了，还是自己做个镜像吧&lt;/p&gt;
&lt;h2 id=&#34;制作dockerfile&#34;&gt;制作dockerfile
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.streamlit.io/deploy/tutorials/docker&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.streamlit.io/deploy/tutorials/docker&lt;/a&gt;&lt;br&gt;
好在官网已给出方案&lt;br&gt;
这是我微改后的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# app/Dockerfile

FROM python:3.9-slim

WORKDIR /app

RUN apt-get update &amp;amp;&amp;amp; apt-get install -y \
    build-essential \
    curl \
    software-properties-common \
    git \
    &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*

RUN git clone https://github.com/streamlit/streamlit-example.git .

RUN pip3 install -r requirements.txt

EXPOSE 8501

HEALTHCHECK CMD curl --fail http://localhost:8501/_stcore/health

CMD [&amp;quot;streamlit&amp;quot;, &amp;quot;run&amp;quot;, &amp;quot;main.py&amp;quot;, &amp;quot;--server.port=8501&amp;quot;, &amp;quot;--server.address=0.0.0.0&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
 &lt;!-- more --&gt;
&lt;p&gt;主要就最后一行并没有用&lt;code&gt;ENTRYPOINT&lt;/code&gt;，因为记得这个不是必须，用&lt;code&gt;CMD&lt;/code&gt;的好处是非常方便的就能修改&lt;code&gt;docker run&lt;/code&gt;时要运行的内容&lt;/p&gt;
&lt;h2 id=&#34;构建和使用镜像&#34;&gt;构建和使用镜像
&lt;/h2&gt;&lt;p&gt;打开CMD，CD到这个Dockerfile保存的目录下&lt;br&gt;
&lt;code&gt;docker build -t streamlit_winotmk:latest . &lt;/code&gt;点不要落下&lt;/p&gt;
&lt;p&gt;然后就可用来运行任意py的app文件了&lt;br&gt;
&lt;code&gt;docker run -ti --rm -p 8501:8501 -v $(pwd):/app streamlit_winotmk:latest streamlit run name_main_file.py&lt;/code&gt;&lt;br&gt;
&lt;code&gt;$(pwd)&lt;/code&gt;换成宿主机的目录，记得暴露8501的默认端口&lt;br&gt;
我这里目录是&lt;code&gt;C:\Cloud\docker\streamlit\demo3\examples&lt;/code&gt;&lt;br&gt;
所以直接:&lt;br&gt;
&lt;code&gt;docker run -ti --rm -p 8501:8501 -v C:\Cloud\docker\streamlit\demo3\examples:/app streamlit_winotmk:latest streamlit run intro.py&lt;/code&gt;&lt;br&gt;
保持运行并想下次继续用可以&lt;br&gt;
&lt;code&gt;docker run -ti -d -p 8501:8501 -v $(pwd):/app --name MystreamlitAPP streamlit_winotmk:latest&lt;/code&gt;&lt;br&gt;
*用容器跑起来的一些例程APP：&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240724_%E7%94%A8%E5%AE%B9%E5%99%A8%E6%9D%A5%E8%BF%90%E8%A1%8Cstreamlit/2025-03-06-14-30-24_1488ee48.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-30-24&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240724_%E7%94%A8%E5%AE%B9%E5%99%A8%E6%9D%A5%E8%BF%90%E8%A1%8Cstreamlit/2025-03-06-14-30-30_e5ad57f1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-30-30&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>软件和网站收集</title>
        <link>http://localhost:1313/posts/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/</link>
        <pubDate>Wed, 19 Jun 2024 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/</guid>
        <description>&lt;img src="http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-00-54_27831b0d.png" alt="Featured image of post 软件和网站收集" /&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;收集一些看到的好玩的可能以后会用到的软件/服务，软件类大多可以docker部署&lt;br&gt;
不定期更新&lt;br&gt;
24.8.6更新&lt;/p&gt;
&lt;h2 id=&#34;a网站推荐&#34;&gt;A.网站推荐
&lt;/h2&gt;&lt;h3 id=&#34;开源大世界&#34;&gt;开源大世界
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;开源大世界 专注于应用级的开源软件、开源资料的情报收集汇总整理。&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://kydsj.vip/doku.php?id=wiki:%E7%BD%91%E7%AB%99%E7%9B%AE%E5%BD%95#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%85%E5%8A%A9%E8%AE%BE%E8%AE%A1&amp;#43;&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kydsj.vip/doku.php?id=wiki:网站目录#计算机辅助设计+&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://kydsj.vip/doku.php?id=wiki:%E8%87%AA%E6%89%98%E7%AE%A1-%E7%94%B5%E5%AD%90%E4%B9%A6%E5%92%8C%E7%BB%BC%E5%90%88%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%B3%BB%E7%BB%9F&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kydsj.vip/doku.php?id=wiki:自托管-电子书和综合图书馆系统&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;很多开源软件项目分享，分类详细品种丰富&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-01-55_4d9d03dd.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-01-55&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;linuxserverio&#34;&gt;linuxserver.io
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;LinuxServer.io 文档之家！我们的目标是确保所有镜像都正确记录所有相关信息，以帮助我们的用户入门。除了每个镜像的单独设置指南外，还有与运行 Docker 容器有关的一般信息和最佳实践&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://docs.linuxserver.io/images/docker-calibre-web/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.linuxserver.io/images/docker-calibre-web/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-02-06_fd4d1573.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-02-06&#34;
	
	
&gt;&lt;/p&gt;
 &lt;!-- more --&gt;
&lt;h3 id=&#34;webpagetestorg&#34;&gt;webpagetest.org
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.webpagetest.org&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;www.webpagetest.org&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;感觉是很强的网站性能分析工具&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-02-15_13fb5752.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-02-15&#34;
	
	
&gt;&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-02-23_6d0e9f56.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-02-23&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;又拍云&#34;&gt;又拍云
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.upyun.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.upyun.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-02-36_fd9b61fd.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-02-36&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;autodl&#34;&gt;autodl
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.autodl.com/market/list&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.autodl.com/market/list&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-02-43_397aa052.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-02-43&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;b影音文件资料整理&#34;&gt;B.影音/文件/资料整理
&lt;/h2&gt;&lt;h3 id=&#34;emby&#34;&gt;emby
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-02-51_659eb527.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-02-51&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;任何设备上的个人媒体&lt;br&gt;
将您家里的所有视频、音乐和照片集中到一处从未如此简单。您的个人 Emby 服务器会自动即时转换和流式传输您的媒体，以便在任何设备上播放&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/MediaBrowser/Emby?tab=readme-ov-file&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/MediaBrowser/Emby?tab=readme-ov-file&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://emby.media/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://emby.media/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-04-13_32817139.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-04-13&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;jellyfin&#34;&gt;jellyfin
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-04-23_0bfeeb91.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-04-23&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;jellyfin是一套多媒体应用程序软件套装，旨在组织、管理和共享数字媒体文件&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/jellyfin/jellyfin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jellyfin/jellyfin&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://jellyfin.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://jellyfin.org/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-04-30_ef2fe342.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-04-30&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;calibre&#34;&gt;calibre
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Calibre-Web 是一款网络应用程序，它使用有效的Calibre数据库提供简洁直观的界面来浏览、阅读和下载电子书&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/janeczku/calibre-web&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/janeczku/calibre-web&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://calibre-ebook.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://calibre-ebook.com/&lt;/a&gt;&lt;br&gt;
目前自用的docker镜像：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/r/johngong/calibre-web&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hub.docker.com/r/johngong/calibre-web&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-04-43_60f56831.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-04-43&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;nextcloud&#34;&gt;Nextcloud
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-04-54_ce7d37d8.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-04-54&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Nextcloud是一套用于建立网络硬盘的客户端－服务器软件。其功能与Dropbox相近，但Nextcloud是自由及开放源代码软件，每个人都可以在私人服务器上安装并执行它。&lt;br&gt;
与Dropbox等专有服务相比，Nextcloud的开放架构让用户可以利用应用程序的方式在服务器上新增额外的功能，并让用户可以完全掌控自己的资料。&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/nextcloud&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nextcloud&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://nextcloud.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://nextcloud.com/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-05-04_b18aec3d.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-05-04&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;found&#34;&gt;Found
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-05-13_8b1e549a.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-05-13&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;高效设计师必备的文件浏览器 Found，一键预览三维模型、序列帧、HDR&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.aalab.com.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.aalab.com.cn/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;c工具类&#34;&gt;C.工具类
&lt;/h2&gt;&lt;h3 id=&#34;matomo&#34;&gt;matomo
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-05-21_e0dc38f8.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-05-21&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Matomo 是领先的免费/自由开放分析平台。&lt;/p&gt;
&lt;p&gt;Matomo 是一款功能齐全的 PHP MySQL 软件程序，您可以下载并安装在自己的网络服务器上。在五分钟的安装过程结束时，您将获得一个 JavaScript 代码。只需将此标签复制并粘贴到您希望跟踪的网站上，即可实时访问您的分析报告。&lt;/p&gt;
&lt;p&gt;Matomo 旨在成为 Google Analytics 的免费软件替代品，目前已在 1,400,000 多个网站上使用。隐私功能已内置&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/matomo-org/matomo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/matomo-org/matomo&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://matomo.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://matomo.org/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;upverter&#34;&gt;Upverter
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Upverter 是一个模块化的、基于网络的电子电路设计工具，可以完成所有工作——PCB 设计、原理图、自动布线、3D 预览和按照您的确切规格构建订单——用户不再需要为开源项目付费。&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://upverter.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://upverter.com/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-05-31_08710f39.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-05-31&#34;
	
	
&gt;&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-05-38_3d053ff2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-05-38&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;manim&#34;&gt;manim
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-05-45_a8c347bb.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-05-45&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.manim.community/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.manim.community/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以做出3B1B那样好看的数学动画（可以用来做视频的工具)&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/2025-03-06-14-06-11_1a64b4d5.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-03-06-14-06-11&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>群晖上用容器搭建SVN服务器</title>
        <link>http://localhost:1313/posts/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
        <pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
        <description>&lt;img src="http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-24-37_b1d8f5bc.png" alt="Featured image of post 群晖上用容器搭建SVN服务器" /&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;事先：我是用路由拨号所以家里已经有外网直连IP，且配置了DDNS和端口转发，所以一个域名即可连上NAS&lt;br&gt;
另外我的群晖是DS720+，是块X86intel的CPU，所以和PC一样用X86的容器镜像就可以，如果是ARM机NAS应该是不通用的&lt;/p&gt;
&lt;p&gt;所用镜像：https://hub.docker.com/r/garethflowers/svn-server&lt;br&gt;
备选镜像（看起来也很不错，拉取次数也过1M：https://hub.docker.com/r/elleflorio/svn-server&lt;/p&gt;
&lt;p&gt;SVN网站：https://subversion.apache.org/&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.51cto.com/u_12701820/6544028&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.51cto.com/u_12701820/6544028&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;准备镜像&#34;&gt;准备镜像
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-25-08_639c0ca7.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-25-08&#34;
	
	
&gt;&lt;br&gt;
由于在群晖的ContainerManager里直接添加镜像不能，应该是要配个docker的镜像站加速或者整个NAS在梯子环境里，懒得整了，我这次选择PC上保存镜像包再拖来NAS里用的形式，个人感觉更方便些&lt;/p&gt;
&lt;p&gt;先在PC上拉个镜像，直接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull garethflowers/svn-server:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后把镜像打包成文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker save -o svn-server.tar garethflowers/svn-server:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;p&gt;就能得到一个&lt;code&gt;svn-server.tar&lt;/code&gt;的文件了，把这个文件上传到ContainerManager里&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-25-38_13b3756a.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-25-38&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-25-46_4273e443.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-25-46&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;然后左边的TAG里选容器》新增，选择刚上传的svn-server&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-26-01_7194985a.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-26-01&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;配置镜像&#34;&gt;配置镜像
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-26-14_4d37cb36.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-26-14&#34;
	
	
&gt;&lt;br&gt;
镜像用法说明，基本上配置个端口和映射库就行&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-26-23_899aa97e.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-26-23&#34;
	
	
&gt;&lt;br&gt;
&lt;code&gt;/SVN_library/SVN_Folder&lt;/code&gt;是我专门创建的新的NAS文件夹&lt;/p&gt;
&lt;p&gt;之后下一步容器就能启动起来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-26-33_ea608804.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-26-33&#34;
	
	
&gt;&lt;br&gt;
打开终端机》通过命令启动》用&lt;code&gt;/bin/sh&lt;/code&gt; 来开一个交互的shell&lt;br&gt;
然后我输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;svnadmin create WinSVN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来建我的第一个SVN仓库名为&lt;code&gt;WinSVN&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（以下部分参考: &lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1650131&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cloud.tencent.com/developer/article/1650131&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后找到&lt;code&gt;/SVN_library/SVN_Folder/WinSVN/conf&lt;/code&gt;，里面是SVN的配置文件了&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-26-48_18f7ff0c.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-26-48&#34;
	
	
&gt;&lt;br&gt;
编辑&lt;code&gt;svnserve.conf&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-26-57_620c4c5f.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-26-57&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;anon-access = none    #取消匿名访问&lt;br&gt;
auth-access = write    #授权用户有可写权限&lt;br&gt;
password-db = passwd    #指定用户配置文件，后面会用到&lt;/p&gt;
&lt;p&gt;编辑&lt;code&gt;passwd&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-27-07_4751d042.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-27-07&#34;
	
	
&gt;&lt;br&gt;
添加了自己的账户，至于分区权限我暂时用不到&lt;/p&gt;
&lt;p&gt;记得重启容器，服务器部分好像就差不多了&lt;/p&gt;
&lt;p&gt;最后别忘记路由器上配个3690端口转发来远程访问这个仓库，我用的是ikuai的路由OS&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-27-18_a3f37742.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-27-18&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;测试连接&#34;&gt;测试连接
&lt;/h2&gt;&lt;p&gt;pc端新建个文件夹，右键SVN CheckOut&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-27-27_806109de.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-27-27&#34;
	
	
&gt;&lt;br&gt;
地址可以输入&lt;code&gt;svn://DDNS的域名:3690/WinSVN&lt;/code&gt;，输入上面&lt;code&gt;passwd&lt;/code&gt;文件里设置好的用户名和密码就好了！！&lt;/p&gt;
&lt;p&gt;之后就是svn客户端的基本用法了，随便放一个文件尝试上传&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-27-37_504ade86.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-27-37&#34;
	
	
&gt;&lt;br&gt;
很快就传好了，至此这个SVN仓库宣告可用！&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2025-02-28-00-27-44_56447933.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-27-44&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Docker01.1_eci价格计算表</title>
        <link>http://localhost:1313/posts/docker01.1_%E4%BB%B7%E6%A0%BC%E8%AE%A1%E7%AE%97%E8%A1%A8/</link>
        <pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/docker01.1_%E4%BB%B7%E6%A0%BC%E8%AE%A1%E7%AE%97%E8%A1%A8/</guid>
        <description>&lt;p&gt;计费文档：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://help.aliyun.com/document_detail/447697.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://help.aliyun.com/document_detail/447697.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;定价标准：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vCPU单价（vCPU）：0.000049 元/秒&lt;br&gt;
内存单价（GiB）： 0.00000613 元/秒&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;所以可知：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;规格&lt;/th&gt;
          &lt;th&gt;秒&lt;/th&gt;
          &lt;th&gt;分钟&lt;/th&gt;
          &lt;th&gt;小时&lt;/th&gt;
          &lt;th&gt;天&lt;/th&gt;
          &lt;th&gt;月&lt;/th&gt;
          &lt;th&gt;年&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;每1u&lt;/td&gt;
          &lt;td&gt;0.00004900&lt;/td&gt;
          &lt;td&gt;0.00294&lt;/td&gt;
          &lt;td&gt;0.1764&lt;/td&gt;
          &lt;td&gt;4.2336&lt;/td&gt;
          &lt;td&gt;127.008&lt;/td&gt;
          &lt;td&gt;1545.264&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;每1G内存&lt;/td&gt;
          &lt;td&gt;0.00000613&lt;/td&gt;
          &lt;td&gt;0.0003678&lt;/td&gt;
          &lt;td&gt;0.022068&lt;/td&gt;
          &lt;td&gt;0.529632&lt;/td&gt;
          &lt;td&gt;15.88896&lt;/td&gt;
          &lt;td&gt;193.31568&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;eci价格计算：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;实例规格&lt;/th&gt;
          &lt;th&gt;秒&lt;/th&gt;
          &lt;th&gt;分钟&lt;/th&gt;
          &lt;th&gt;小时&lt;/th&gt;
          &lt;th&gt;天&lt;/th&gt;
          &lt;th&gt;月&lt;/th&gt;
          &lt;th&gt;年&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;0.25u	0.5G&lt;/td&gt;
          &lt;td&gt;0.00001532&lt;/td&gt;
          &lt;td&gt;0.0009189&lt;/td&gt;
          &lt;td&gt;0.055134&lt;/td&gt;
          &lt;td&gt;1.323216&lt;/td&gt;
          &lt;td&gt;39.69648&lt;/td&gt;
          &lt;td&gt;482.97384&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;0.5u	1G&lt;/td&gt;
          &lt;td&gt;0.00003063&lt;/td&gt;
          &lt;td&gt;0.0018378&lt;/td&gt;
          &lt;td&gt;0.110268&lt;/td&gt;
          &lt;td&gt;2.646432&lt;/td&gt;
          &lt;td&gt;79.39296&lt;/td&gt;
          &lt;td&gt;965.94768&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2u	4G&lt;/td&gt;
          &lt;td&gt;0.00012252&lt;/td&gt;
          &lt;td&gt;0.0073512&lt;/td&gt;
          &lt;td&gt;0.441072&lt;/td&gt;
          &lt;td&gt;10.585728&lt;/td&gt;
          &lt;td&gt;317.57184&lt;/td&gt;
          &lt;td&gt;3863.79072&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2u	8G&lt;/td&gt;
          &lt;td&gt;0.00014704&lt;/td&gt;
          &lt;td&gt;0.0088224&lt;/td&gt;
          &lt;td&gt;0.529344&lt;/td&gt;
          &lt;td&gt;12.704256&lt;/td&gt;
          &lt;td&gt;381.12768&lt;/td&gt;
          &lt;td&gt;4637.05344&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;4u	8G&lt;/td&gt;
          &lt;td&gt;0.00024504&lt;/td&gt;
          &lt;td&gt;0.0147024&lt;/td&gt;
          &lt;td&gt;0.882144&lt;/td&gt;
          &lt;td&gt;21.171456&lt;/td&gt;
          &lt;td&gt;635.14368&lt;/td&gt;
          &lt;td&gt;7727.58144&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;64u	256G&lt;/td&gt;
          &lt;td&gt;0.00470528&lt;/td&gt;
          &lt;td&gt;0.2823168&lt;/td&gt;
          &lt;td&gt;16.939008&lt;/td&gt;
          &lt;td&gt;406.536192&lt;/td&gt;
          &lt;td&gt;12196.08576&lt;/td&gt;
          &lt;td&gt;148385.7101&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一秒0.0047元很便宜吗？一月要1.2w！可以说被安排得明明白白了&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行</title>
        <link>http://localhost:1313/posts/docker01/</link>
        <pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/posts/docker01/</guid>
        <description>&lt;style type=&#34;text/css&#34; rel=&#34;stylesheet&#34;&gt;
.nav-number { 
    display:none !important;
}
.post-toc .nav-item {
    white-space: normal !important;
}
&lt;/style&gt;
&lt;p&gt;一口气步子迈得有大，慢慢记录一下,如果你碰巧看到这个文章，希望这个文章的某些部分对你有帮助，来源我已尽量在文章中标出，还有很多部分是自己敲的&lt;/p&gt;
&lt;p&gt;了解ECI弹性容器：https://www.aliyun.com/product/eci&lt;br&gt;
了解阿里云NAS文件存储：https://www.aliyun.com/product/nas&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要用eci来运行hexo？&lt;/strong&gt;&lt;br&gt;
因为好玩，同时来学习从pull到发布到运行整个docker镜像的流程，也想给自己的hexo博客找个新家，酷酷的那种&lt;br&gt;
本博客之前是由树莓派上的hexo生成，部署到github上的&lt;br&gt;
最近在捣鼓docker，一时想不起来有什么灵活小巧的服务拿来用docker玩，那么想着干脆把树莓派上hexo这部分服务做成镜像，需要用的时候拿出来用用想必是极好的（这么一来好像树莓派又要吃灰了）&lt;br&gt;
恰巧最近又在琢磨阿里云ECI容器服务，所以理论上是可以用我自己打包好的镜像的&lt;br&gt;
最后成品的结构大致如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-09-02_461c3121.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-09-02&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这里挂了3个镜像：&lt;br&gt;
&lt;strong&gt;1.node.js+git+ssh+hexo&lt;/strong&gt;&lt;br&gt;
主要是此镜像——由node.js+hexo组成的运行hexo环境，用过的都了解hexo是基于node.js的，每次我们生成文章的时候都会&lt;code&gt;hexo g -d&lt;/code&gt;，而运行这套需要一个环境容器&lt;br&gt;
git和ssh主要是部署在github上用的，同时我习惯用VSCode的SSH FS来管理远程文件和写博客，主要是ssh连接，也方便我拿PuTTY和WinSCP远程登录管理&lt;br&gt;
&lt;strong&gt;2.vsftpd&lt;/strong&gt;&lt;br&gt;
一个常用的ftp服务，我是在本地些完再上传的，用这个是因为我发现如果要给文章插入图片，我还需要手动用ssh上传到hexo对应目录里。而用VSCode的SSH FS可以帮我自动同步本地工作目录和云上即将生成静态网页的hexo目录，非常方便！&lt;br&gt;
&lt;strong&gt;3.ddns&lt;/strong&gt;&lt;br&gt;
因为容器是即用即开，用完就释放的，每次开会新分配一个弹性IP做为外网接口，但是不想每次都去复制这个新的ip地址，那么就要用到动态域名解析，刚好我在阿里云上购买过一个我自己的域名，所以ddns这部分服务就拉出来做个镜像&lt;/p&gt;
&lt;p&gt;还挂了一个NAS盘：&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-09-26_46c6e19a.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-09-26&#34;
	
	
&gt;&lt;br&gt;
挂载以后：&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-09-35_bc212f63.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-09-35&#34;
	
	
&gt;&lt;br&gt;
可见我的hexo，主题，文章，图片等等都存放在里面，服务容器可以随便释放拉取，数据不会受到影响，几百M的NAS容量价格抹零后可以忽略不计&lt;/p&gt;
&lt;p&gt;文章后面（第三部分）会说如何按我的需求构建定制这几个镜像，并上传到阿里云容器镜像ARK仓库以方便调用&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;vsftpd&lt;/strong&gt;还有&lt;strong&gt;ddns&lt;/strong&gt;可以与主镜像&lt;strong&gt;node.js+hexo&lt;/strong&gt;合并成一个大镜像吗？&lt;br&gt;
&lt;strong&gt;当然可以&lt;/strong&gt;，但我实际做了几次以后发现把ftp，ddns这样常用的服务功能单独拿出来会方便得多的多，毕竟我想起别得服务，也可以给他们挂上ftp等常用服务，我也可以选择不挂，这样容器的优势就体现出来了。我可以把单一的服务都做成单独的小镜像，需要哪个挂哪个，性能消耗也很小&lt;/p&gt;
&lt;p&gt;整套下来有这些部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;docker基本操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已经启动的本地容器修改端口，启动容器时即启动服务等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;打包制作自己的docker镜像(dockerfile)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docker镜像打包并上传到阿里云镜像库ARK&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;eci容器创建模板和eci命令行工具使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hexo本地编辑环境设置————如何用VSCode舒服的写MD文档&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;附表：&lt;br&gt;
群晖搭建私有镜像仓库和dockerengine设置&lt;br&gt;
eci价格计算表&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-docker-基本操作&#34;&gt;1. docker 基本操作
&lt;/h2&gt;&lt;p&gt;博主吐槽一下，总觉得一些类似run，commit操作完全可以做成一个美观好用的UI控制软件，但是docker destop就是不做，然后大家都默认敲命令行是方便的，好用的。十分不解，可能需要ui的不会写ui，熟练使用命令行的也不需要什么ui吧，诶&lt;br&gt;
——后面随着对docker了解的深入，明白它不是虚拟机，用得还是linux内核，这么一想，处处真是浓浓的linux味，现在能提供一个windows下的Docker Desktop桌面程序，已经非常得不错了！&lt;br&gt;
资料网站：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/cli/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方命令大全&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://chunchengwei.github.io/ruan-jian/ji-yu-docker-de-hexo-bo-ke-da-jian/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;基于Docker的Hexo博客搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个基本操作写得还行下次爬一篇下来吧：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yingclin.github.io/2018/docker-basic.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;[小抄] Docker 基本命令&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;11-运行容器&#34;&gt;1.1 运行容器
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -it -d --name [container-name] -p 8088:80 [image-name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里是将容器内的80端口映射到宿主机的8088端口&lt;/p&gt;
&lt;p&gt;参数说明&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-d&lt;/code&gt; 表示后台运行容器&lt;br&gt;
&lt;code&gt;-t&lt;/code&gt; 为docker分配一个伪终端并绑定到容器的标准输入上&lt;br&gt;
&lt;code&gt;-i&lt;/code&gt; 是让容器的标准输入保持打开状态&lt;br&gt;
&lt;code&gt;-p&lt;/code&gt; 指定映射端口&lt;/p&gt;
&lt;p&gt;还能这么写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --name mssql -e &#39;ACCEPT_EULA=Y&#39; -e &#39;SA_PASSWORD=xxxx&#39; \
     -p 1433:1433  \
     -d mssql-2019-with-cimb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;\&lt;/code&gt;应该是可以换行表述&lt;br&gt;
&lt;code&gt;-e&lt;/code&gt; 定义环境变量（通常制作镜像的时候应该已经写好了，或者在容器内做好自动脚本，run时候再写毕竟是不方便的）&lt;/p&gt;
&lt;h3 id=&#34;12-将此容器-commit-保存为新镜像&#34;&gt;1.2 将此容器 commit 保存为新镜像：
&lt;/h3&gt;&lt;p&gt;格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker commit container-id new-name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;container-id也可以是已有容器的名字，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker commit node-test nodehexo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nodehexo这里是新镜像名&lt;/p&gt;
&lt;h3 id=&#34;13-启动docker引擎时自动运行docker容器&#34;&gt;1.3 启动docker引擎时自动运行docker容器：
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/londa/article/details/97611947&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/londa/article/details/97611947&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ps:上面链接文章还有:修改docker容器的挂载路径，修改docker默认的存储位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run --restart=always
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有时候，我们创建容器时忘了添加参数 &lt;code&gt;--restart=always&lt;/code&gt; ，当 Docker 重启时，容器未能自动启动，&lt;/p&gt;
&lt;p&gt;现在要添加该参数怎么办呢，方法有二：&lt;/p&gt;
&lt;p&gt;1、Docker 命令修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker container update --restart=always 容器名字
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我实际运行时，可以支持同时配置多个容器id，比如（其中container关键字可以忽略不写）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker update 87cd61ad7f7c f488b0479f24 2109903220ce 1fb346ea1a46 --restart=no
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、直接改配置文件&lt;/p&gt;
&lt;p&gt;首先停止容器，不然无法修改配置文件&lt;/p&gt;
&lt;p&gt;配置文件路径为：&lt;code&gt;/var/lib/docker/containers/&lt;/code&gt; 容器ID&lt;/p&gt;
&lt;p&gt;在该目录下找到一个文件 hostconfig.json ，找到该文件中关键字 RestartPolicy&lt;/p&gt;
&lt;p&gt;修改前配置：&lt;code&gt;&amp;quot;RestartPolicy&amp;quot;:{&amp;quot;Name&amp;quot;:&amp;quot;no&amp;quot;,&amp;quot;MaximumRetryCount&amp;quot;:0}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;修改后配置：&lt;code&gt;&amp;quot;RestartPolicy&amp;quot;:{&amp;quot;Name&amp;quot;:&amp;quot;always&amp;quot;,&amp;quot;MaximumRetryCount&amp;quot;:0}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后启动容器。&lt;/p&gt;
&lt;h3 id=&#34;14-有关dockerfile&#34;&gt;1.4 有关dockerfile
&lt;/h3&gt;&lt;p&gt;dockerfile是用来构建镜像的脚本&lt;br&gt;
主要参考这几篇：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.runoob.com/docker/docker-dockerfile.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.runoob.com/docker/docker-dockerfile.html&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://developer.aliyun.com/article/484262&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://developer.aliyun.com/article/484262&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://juejin.cn/s/docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;docker容器启动时自动启动脚本&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;编写dockerfile&#34;&gt;编写dockerfile
&lt;/h4&gt;&lt;p&gt;我的第一个dockerfile：&lt;br&gt;
简单做个测试，在之前做的镜像上加了条启动命令&lt;br&gt;
&lt;strong&gt;Dockerfile&lt;/strong&gt; （文件没有后缀)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## Set the base image to CentOS  基于nodehexo
FROM nodehexo:V4
COPY ddnsstart.sh /ddnsstart.sh
ENTRYPOINT [&amp;quot;/bin/bash&amp;quot;, &amp;quot;/ddnsstart.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很简单:&lt;br&gt;
&lt;code&gt;FROM&lt;/code&gt;基于&lt;code&gt;nodehexo:V4&lt;/code&gt;镜像构建&lt;br&gt;
&lt;code&gt;COPY&lt;/code&gt;就是拷贝构建目录下的&lt;code&gt;ddnsstart.sh&lt;/code&gt;到之后构建好的镜像根目录下&lt;br&gt;
&lt;code&gt;ENTRYPOINT&lt;/code&gt;会在用新镜像开启容器时再执行，这里会在执行&lt;code&gt;/bin/bash&lt;/code&gt;里执行&lt;code&gt;/ddnsstart.sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一个dockerfile只能有一条&lt;code&gt;ENTRYPOINT&lt;/code&gt;，多个也只执行最后一个,&lt;code&gt;CMD&lt;/code&gt;也是如此&lt;br&gt;
如果 Dockerfile 中如果存在多个 &lt;code&gt;CMD&lt;/code&gt; 指令，仅最后一个生效。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;CMD&lt;/code&gt;还有些写法，比如还可以&lt;br&gt;
&lt;code&gt;CMD service ssh start &amp;amp;&amp;amp; service XXX start &amp;amp;&amp;amp; tail -f /etc/passwd&lt;/code&gt;一起执行多道指令&lt;br&gt;
这在构建镜像的时候会被自动转换为类似：&lt;br&gt;
&lt;code&gt;CMD [&amp;quot;/bin/sh&amp;quot;, &amp;quot;service ssh start&amp;quot;,&amp;quot;service XXX start&amp;quot;,&amp;quot;tail -f /etc/passwd&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tail -f /etc/passwd&lt;/code&gt;作用在于防止docker容器开启后立即关闭见下面段落&lt;/p&gt;
&lt;p&gt;CMD格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CMD &amp;lt;shell 命令&amp;gt; 
CMD [&amp;quot;&amp;lt;可执行文件或命令&amp;gt;&amp;quot;,&amp;quot;&amp;lt;param1&amp;gt;&amp;quot;,&amp;quot;&amp;lt;param2&amp;gt;&amp;quot;,...] 
CMD [&amp;quot;&amp;lt;param1&amp;gt;&amp;quot;,&amp;quot;&amp;lt;param2&amp;gt;&amp;quot;,...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认是 &lt;code&gt;bin/sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ddnsstart.sh文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
root/ddnsAPP/ddns -c root/ddnsAPP/config.json
echo &amp;quot;更新mcwrite.winotmk.com解析&amp;quot;
service ssh start
tail -f /etc/passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里都是简单的shell命令了&lt;br&gt;
&lt;code&gt;root/ddnsAPP/ddns -c root/ddnsAPP/config.json&lt;/code&gt;是执行ddns更新，解析新的ip到域名上，因为我这个镜像打算放到阿里云ECI里跑，每次新拉的IP当然都不一样（一直占着一个IP会产生费用，没必要）&lt;/p&gt;
&lt;p&gt;同时我还执行了启动ssh服务，有的时候会用上ssh，因为我把网盘挂载到了容器内&lt;br&gt;
&lt;code&gt;tail -f /etc/passwd&lt;/code&gt;这里起到的比较重要的占着进程的作用，详见下面：&lt;/p&gt;
&lt;p&gt;*关于 &lt;code&gt;CMD&lt;/code&gt; 或 &lt;code&gt;entrypoint&lt;/code&gt; 构建后 &lt;code&gt;docker run -dit&lt;/code&gt; 为何容器依然秒退&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/344939968&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zhihu.com/question/344939968&lt;/a&gt;&lt;br&gt;
是因为使用了CMD或者entrypoint去service *** start命令作为容器启动命令，主进程执行完结束了，容器也就结束了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dockerfile 写清楚 entrypoint 和 cmd，启动脚本如果立刻会退出，那么在最后添加 tail -f 某个日志文件。或者 监听某个端口或者进程。&lt;br&gt;
方法1: 设置容器启动时就启动服务ENTRYPOINT [&amp;ldquo;flask&amp;rdquo;, &amp;ldquo;run&amp;rdquo;, &amp;ldquo;-h&amp;rdquo;, &amp;ldquo;0.0.0.0&amp;rdquo;, &amp;ldquo;-p&amp;rdquo;, &amp;ldquo;80&amp;rdquo;]&lt;br&gt;
方法2:CMD service apache2 start &amp;amp;&amp;amp; tail -F /var/log/apache2/error.log再极端点 sleep infinite&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;用dockerfile构建镜像&#34;&gt;用dockerfile构建镜像
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;docker build -t &amp;lt;新镜像名字:标签&amp;gt; .&lt;/code&gt;&lt;br&gt;
比如&lt;code&gt;docker build -t nodehexo:V5 .&lt;/code&gt;&lt;br&gt;
请不要忘记最后一个&lt;code&gt;.&lt;/code&gt;，这表示在当前目录下构建&lt;br&gt;
用这条指令前先&lt;code&gt;CD&lt;/code&gt;到dockerfile文件所放置的目录&lt;br&gt;
比如我先&lt;code&gt;CD ./dockerbuild&lt;/code&gt;，因为我的文件放在&lt;code&gt;用户/dockerbuild&lt;/code&gt;目录下面&lt;br&gt;
然后就拥有了属于构建的镜像！&lt;/p&gt;
&lt;h4 id=&#34;141-entrypoint与cmd的区别&#34;&gt;1.4.1 ENTRYPOINT与CMD的区别
&lt;/h4&gt;&lt;p&gt;Docker 的 ENTRYPOINT 和 CMD 参数探秘&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://aws.amazon.com/cn/blogs/china/demystifying-entrypoint-cmd-docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://aws.amazon.com/cn/blogs/china/demystifying-entrypoint-cmd-docker/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;142-dockerfile构建镜像时如何选择from镜像以减小镜像体积&#34;&gt;1.4.2 dockerfile构建镜像时如何选择FROM镜像以减小镜像体积
&lt;/h4&gt;&lt;p&gt;busybox：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/hknaruto/article/details/70229896&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/hknaruto/article/details/70229896&lt;/a&gt;&lt;br&gt;
alpine：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/_/alpine&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hub.docker.com/_/alpine&lt;/a&gt;&lt;br&gt;
alpine包管理器APK：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://wangchujiang.com/linux-command/c/apk.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wangchujiang.com/linux-command/c/apk.html&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://wiki.alpinelinux.org/wiki/Alpine_Package_Keeper&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wiki.alpinelinux.org/wiki/Alpine_Package_Keeper&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;15-将已有镜像打包带走使用将打包来的镜像&#34;&gt;1.5 将已有镜像打包带走/使用将打包来的镜像
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/348849578&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/348849578&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;将镜像保存为本地文件&#34;&gt;将镜像保存为本地文件
&lt;/h4&gt;&lt;p&gt;可以使用Docker save命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker save -o mssql-2019-with-cimb.tar mssql-2019-with-cimb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会得到一个&lt;code&gt;mssql-2019-with-cimb.tar&lt;/code&gt;文件，就可以随身携带啦&lt;/p&gt;
&lt;p&gt;从文件载入镜像&lt;/p&gt;
&lt;h4 id=&#34;从文件载入镜像&#34;&gt;从文件载入镜像
&lt;/h4&gt;&lt;p&gt;使用Docker load命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker load --input mssql-2019-with-cimb.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;16-docker挂载本地目录&#34;&gt;1.6 docker挂载本地目录
&lt;/h3&gt;&lt;p&gt;有关volume:https://docs.docker.com/storage/volumes/&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/get-started/05_persisting_data/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/get-started/05_persisting_data/&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/zz00008888/article/details/131924286&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/zz00008888/article/details/131924286&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Docker中，可以使用“-v”选项来挂载本地目录。该选项需要两个参数，分别是本地目录路径和容器内目录路径。例如，以下命令将本地目录“/home/user/app”挂载到容器内的“/app”目录中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -v /home/user/app:/app my_image
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这将使得容器可以访问本地目录中的文件，并且任何对该目录的更改也会反映在容器中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker挂载本地目录到已有容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了在容器启动时挂载本地目录外，还可以在运行时将本地目录挂载到正在运行的容器中。要实现这一点，可以使用“docker cp”命令将本地目录复制到容器中，并使用“docker exec”命令在容器中执行命令。例如，以下命令将本地目录“/home/user/data”挂载到正在运行的容器中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker cp /home/user/data my_container:/data
docker exec -it my_container bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在容器中，可以访问挂载的目录“/data”，并且任何对该目录的更改也会反映在本地文件系统中。&lt;/p&gt;
&lt;h3 id=&#34;17-其他一些操作&#34;&gt;1.7 其他一些操作
&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# ****************************** 容器 ****************************** #
# 查看正在运行的容器
$ docker ps
# 查看所有容器
$ docker ps -a
# 启动/停止某个容器
$ docker start/stop id/name
# 以交互方式启动一个容器
$ docker start -i id/name
# 进入某个容器(使用exit退出后容器也跟着停止运行)
$ docker attach id/name
# 启动一个伪终端以交互式的方式进入某个运行的容器（使用exit退出后容器不停止运行）
$ docker exec -it id/name
# 删除某个容器
$ docker rm id/name
# 复制ubuntu容器并且重命名为test且运行，然后以伪终端交互式方式进入容器，运行bash
$ docker run --name test -ti ubuntu /bin/bash

# ****************************** 镜像 ****************************** #
# 查看本地镜像
$ docker images
# 删除某个镜像
$ docker rmi id/name
# 基于当前目录下的Dockerfile，创建一个名为name:flag的镜像
$ docker build -t name:flag .
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-已启动容器操作&#34;&gt;2. 已启动容器操作
&lt;/h2&gt;&lt;h3 id=&#34;21-win10下docker给已存在的容器添加端口映射的方法&#34;&gt;2.1 win10下docker给已存在的容器添加端口映射的方法
&lt;/h3&gt;&lt;p&gt;博主再吐槽一下，这个调试阶段如此常用的修改容我端口，改起来却像游戏作弊，不觉得这个要做简单很难，怕只是没做&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://mdnice.com/writing/25822ca29531424d9b68d7feb8273a82&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mdnice.com/writing/25822ca29531424d9b68d7feb8273a82&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/Taysuesue/article/details/126706394&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/Taysuesue/article/details/126706394&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/kingsonfu/p/11578073.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/kingsonfu/p/11578073.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看容器已映射的端口（dockerdeskUI内也可看见）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker port 容器ID/容器名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先停止容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker stop {容器的名称或者 id }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看容器完整的 &lt;code&gt;hash_of_the_container&lt;/code&gt; 数值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker inspect {容器的名称或者 id } | grep Id

# 比如：
docker inspect cbe26510c276 | grep Id
# 会得到如下结果：
# &amp;quot;Id&amp;quot;: &amp;quot;cbe26510c276fa9a4487a8c2af8cbb49410f2a5305149d2b26eb8ce37c777d00&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如果主机是linux（mac应该也行没测）&lt;/strong&gt;&lt;br&gt;
打开 hostconfig.json 配置文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim /var/lib/docker/containers/{hash_of_the_container}/hostconfig.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;记得还要改 config.v2.json，改法同下面的win10&lt;br&gt;
&lt;strong&gt;如果是win10&lt;/strong&gt;&lt;br&gt;
1.先找到容器的配置文件，首先我的电脑地址栏输\wsl$\进入到网络文件夹上,在一步一步找到容器目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\\wsl$\docker-desktop-data\data\docker\containers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.点击进入相应容器ID文件夹，打开后修改其中的 &lt;code&gt;config.v2.json&lt;/code&gt; 和 &lt;code&gt;hostconfig.json&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hostconfig.json&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;PortBindings&amp;quot;:{&amp;quot;22/tcp&amp;quot;:[{&amp;quot;HostIp&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;HostPort&amp;quot;:&amp;quot;50022&amp;quot;}],&amp;quot;3306/tcp&amp;quot;:[{&amp;quot;HostIp&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;HostPort&amp;quot;:&amp;quot;53306&amp;quot;}],&amp;quot;6379/tcp&amp;quot;:[{&amp;quot;HostIp&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;HostPort&amp;quot;:&amp;quot;56379&amp;quot;}]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;HostPort&lt;/code&gt;字面意思就是宿主机的端口，所以即：&lt;br&gt;
容器内22&amp;gt;外部5022访问&lt;br&gt;
容器内3306&amp;gt;外部53306访问&lt;br&gt;
容器内6379&amp;gt;外部56379访问&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;config.v2.json&lt;/strong&gt; 有两处需要添加，只修改一处不生效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;ExposedPorts&amp;quot;:{&amp;quot;22/tcp&amp;quot;:{},&amp;quot;3306/tcp&amp;quot;:{},&amp;quot;6379/tcp&amp;quot;:{}}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;Ports&amp;quot;:{&amp;quot;22/tcp&amp;quot;:[{&amp;quot;HostIp&amp;quot;:&amp;quot;0.0.0.0&amp;quot;,&amp;quot;HostPort&amp;quot;:&amp;quot;50022&amp;quot;}],&amp;quot;3306/tcp&amp;quot;:[{&amp;quot;HostIp&amp;quot;:&amp;quot;0.0.0.0&amp;quot;,&amp;quot;HostPort&amp;quot;:&amp;quot;53306&amp;quot;}],&amp;quot;6379/tcp&amp;quot;:[{&amp;quot;HostIp&amp;quot;:&amp;quot;0.0.0.0&amp;quot;,&amp;quot;HostPort&amp;quot;:&amp;quot;56379&amp;quot;}]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不过我实际只改了这里的&lt;code&gt;&amp;quot;ExposedPorts&amp;quot;&lt;/code&gt;貌似就行了&lt;/p&gt;
&lt;p&gt;然后重启&lt;strong&gt;docker&lt;/strong&gt;，注意不只是重启容器，我一开始只重启容器发现白改了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 重启 docker
service docker restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者在系统右下角，点击Restart重启整个 Docker 服务，然后再重启 Container 即可正常使用&lt;/p&gt;
&lt;h3 id=&#34;22-docker容器内服务开机自启动实现方案以ssh服务为例&#34;&gt;2.2 docker容器内服务开机自启动实现方案（以ssh服务为例）
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;font color=red&gt;注意，2.2这段内容随着对docker和linux了解的深入觉得有不妥，但是作为学习的过程还是保留&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_38603541/article/details/124028994&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/qq_38603541/article/details/124028994&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为我后续打算用类似vscode里的remote-ssh来管理容器内，也想用winscp等好用的工具可以接进来，还是有必要开个ssh&lt;br&gt;
&lt;strong&gt;解决方案&lt;/strong&gt;&lt;br&gt;
1、正常我们在linux操作系统内设置服务自启动的方法一般都是使用systemctl。&lt;/p&gt;
&lt;p&gt;systemctl enable ssh&lt;br&gt;
2、但是，一般在docker容器内我们一般不这么干，因为容器内没有systemctl权限……&lt;/p&gt;
&lt;p&gt;3、我们依然还是使用脚本的形式将ssh设为自启，只不过这个的这个脚本和我们使用Dockerfile的脚本不一样。&lt;/p&gt;
&lt;p&gt;4、在 /root 目录下新建一个 start_ssh.sh文件，并给予该文件可执行权限。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;touch /root/start_ssh.sh
 
vim /root/start_ssh.sh
 
chmod +x /root/start_ssh.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、start_ssh.sh 脚本的内容，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
 
LOGTIME=$(date &amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;)
echo &amp;quot;[$LOGTIME] startup run...&amp;quot; &amp;gt;&amp;gt;/root/start_ssh.log
service ssh start &amp;gt;&amp;gt;/root/start_ssh.log
#service mysql start &amp;gt;&amp;gt;/root/star_mysql.log   //其他服务也可这么实现
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、将start_ssh.sh脚本添加到启动文件中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim /root/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7、在 .bashrc 文件末尾加入如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# startup run
if [ -f /root/start_ssh.sh ]; then
      . /root/start_ssh.sh
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8、保存后，等下次重启容器的时候，添加的服务也就跟着重启了。&lt;/p&gt;
&lt;p&gt;docker容器在启动的时候，会自动执行的是~/.bashrc文件，所以，环境变量需要配置在该文件内，这样镜像启动时，可自动执行该文件，使环境变量生效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=red&gt;正确的理解是：&lt;/font&gt;&lt;/strong&gt;&lt;br&gt;
/root/.bashrc会在容器启动的时候自动执行这句十分欠妥，&lt;br&gt;
准确的来讲是&lt;strong&gt;root用户登录bash的时候会执行，每次开新的bash shell也会执行一遍&lt;/strong&gt;&lt;br&gt;
如果dockerfile内定义了ENTRYPOINT或者CMD执行类似：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ENTRYPOINT [ &amp;quot;/bin/bash&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;service apache2 start&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么对于容器来说PID 1号进程就是bash（apache是bash的子进程），也确实会跑一遍.bashrc内的内容，但是这不代表所有容器启动时一定会启动bash shell，也可能直接是个java进程，也可能是dumb-int，更多时候可能是sh shell，这应该都不会触发.bashrc&lt;br&gt;
所以如果想要在容器启动时自动启动一个服务，推荐写在dockerfile里，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;COPY start.sh /
ENTRYPOINT [ &amp;quot;sh&amp;quot;,&amp;quot;/start.sh&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后再在start.sh里写上你需要启动的服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh
service ssh restart
service apache2 restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以及如果确实有很多个服务需要启，考虑使用类似docker compose启多个镜像，每个镜像跑单个服务&lt;/p&gt;
&lt;h4 id=&#34;221-拓展bashrc-etcbashrc-etcprofile三个文件的区别&#34;&gt;2.2.1 拓展：~/.bashrc /etc/bashrc /etc/profile三个文件的区别
&lt;/h4&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/q/1010000003793341&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://segmentfault.com/q/1010000003793341&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-打包制作自己的docker镜像dockerfile&#34;&gt;3 打包制作自己的docker镜像(dockerfile)
&lt;/h2&gt;&lt;p&gt;dockerfile是告诉docker engine如何构建镜像的脚本&lt;/p&gt;
&lt;h3 id=&#34;31-nodejsgithexo镜像&#34;&gt;3.1 node.js+git+hexo镜像
&lt;/h3&gt;&lt;p&gt;其实这部分镜像做了两遍，第一遍直接拉的官方node镜像，然后发现ssh不好装，走了很多弯路，随着对docker了解的加深，最后我自己做了dockerfile重构了这部分镜像&lt;/p&gt;
&lt;h4 id=&#34;311-dockerfile&#34;&gt;3.1.1 Dockerfile
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;i class=&#34;fas fa-file&#34;&gt;&lt;/i&gt;dockerfileV02（可以没有后缀）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#这个包将包含：node-v29.5.0  git ssh hexo
#hexo环境目录/hexo/Winblog
FROM debian:stable-slim
LABEL maintainer=&amp;quot;winotmk&amp;quot; web=&amp;quot;md.winotmk.com&amp;quot; Ver=&amp;quot;02&amp;quot;
#ADD有自动解压功能
ADD node-v20.5.0-linux-x64.tar.xz /
    #移动node二进制文件到目录
RUN mkdir -p /usr/local/nodejs &amp;amp;&amp;amp;\
    mv node-v20.5.0-linux-x64 /usr/local/nodejs &amp;amp;&amp;amp;\
    #mk hexo目录
    mkdir -p /hexo/Winblog &amp;amp;&amp;amp;\
    apt-get update &amp;amp;&amp;amp;\
    #安装SSH 安装GIT
    apt-get install -y --no-install-recommends openssh-server git-core &amp;amp;&amp;amp;\
    apt-get autoremove -y &amp;amp;&amp;amp;\
    apt-get clean
#node和npm环境变量
ENV PATH=&amp;quot;/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH&amp;quot;
#安装hexo
WORKDIR /hexo/Winblog
RUN npm install -g hexo-cli
#hexo环境变量
ENV PATH=&amp;quot;$PATH:/hexo/Winblog/node_modules/.bin&amp;quot;
#更新ssh设置
COPY sshd_config /etc/ssh/
#环境变量设置
COPY .profile /root/
#设置启动脚本
COPY hexo_debian_service_start.sh /service_start.sh
CMD [&amp;quot;/bin/bash&amp;quot;,&amp;quot;/service_start.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基本上都是些安装命令以及配置环境变量&lt;br&gt;
安装了&lt;code&gt;hexo&lt;/code&gt;,&lt;code&gt;git&lt;/code&gt;,&lt;code&gt;ssh&lt;/code&gt;,&lt;code&gt;node&lt;/code&gt;&lt;br&gt;
这是优化过了的第二版，主要是第二版使用了&lt;code&gt;ADD&lt;/code&gt;，它基本和&lt;code&gt;COPY&lt;/code&gt;一样，都可以把某个构建目录下的文件打入正在生成的镜像里，但当用ADD在执行 &amp;lt;源文件&amp;gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &amp;lt;目标路径&amp;gt;。说白了ADD会帮我自动解压&lt;br&gt;
在这里我还设置了ssh（但是没有配置root密码）&lt;/p&gt;
&lt;p&gt;而我的第一版开头：&lt;br&gt;
&lt;strong&gt;&lt;i class=&#34;fas fa-file&#34;&gt;&lt;/i&gt;dockerfileV01&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM debian:stable-slim

COPY node-v20.5.0-linux-x64.tar.xz /node-v20.5.0-linux-x64.tar.xz
RUN apt-get update &amp;amp;&amp;amp;\
    apt-get install -y xz-utils --no-install-recommends &amp;amp;&amp;amp;\
    tar -xvf node-v20.5.0-linux-x64.tar.xz &amp;amp;&amp;amp;\
    mkdir -p /usr/local/nodejs &amp;amp;&amp;amp;\
    mv node-v20.5.0-linux-x64 /usr/local/nodejs &amp;amp;&amp;amp;\
    #删除xz包
    apt-get purge -y xz-utils &amp;amp;&amp;amp; \
    apt-get autoremove -y &amp;amp;&amp;amp; \
    apt-get clean &amp;amp;&amp;amp; \
    #删除node-v20.5.0-linux-x64.tar.xz包
    rm node-v20.5.0-linux-x64.tar.xz

#node和npm环境变量
ENV PATH=&amp;quot;/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当时不知道&lt;code&gt;ADD&lt;/code&gt;的功能，使用 &lt;code&gt;COPY&lt;/code&gt;拷贝整个.tar.xz包结果debian还没有.xz包解压功能，需要安装&lt;code&gt;xz-utils&lt;/code&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_43502175/article/details/129547250&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;详见&lt;/a&gt;，凭空多出好几行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要用二进制包安装呢node.js呢？&lt;/strong&gt;&lt;br&gt;
因为实测如果用&lt;code&gt;apt-get install nodejs&lt;/code&gt;安装，&lt;br&gt;
或者&lt;code&gt;curl -fsSL https://deb.nodesource.com/setup_19.x | bash - &amp;amp;&amp;amp;\ apt-get install -y nodejs&lt;/code&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nodesource/distributions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;命令出处&lt;/a&gt;，&lt;br&gt;
安装出来镜像体积就是会楞大出好几百MB&lt;/p&gt;
&lt;h4 id=&#34;312-nodejsgithexo镜像copy的文件&#34;&gt;3.1.2 node.js+git+hexo镜像COPY的文件
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;i class=&#34;fas fa-file&#34;&gt;&lt;/i&gt;.profile&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ~/.profile: executed by Bourne-compatible login shells.

if [ &amp;quot;$BASH&amp;quot; ]; then
  if [ -f ~/.bashrc ]; then
    . ~/.bashrc
  fi
fi

mesg n 2&amp;gt; /dev/null || true

export PATH=&amp;quot;/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH&amp;quot;
export PATH=&amp;quot;$PATH:/hexo/Winblog/node_modules/.bin&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了防止镜像上云后莫名其妙的原因导致环境变量出问题，脚本里再跑一遍，这俩&lt;code&gt;export PATH&lt;/code&gt;其实dockerfile里设置过&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sshd_config是什么&lt;/strong&gt;&lt;br&gt;
ssh的设置&lt;br&gt;
参考：https://blog.csdn.net/weixin_34910922/article/details/125193597&lt;br&gt;
主要改了两条&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#vim /etc/ssh/sshd_config
PermitRootLogin yes #root登陆权限
PasswordAuthentication yes #密码权限
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等于我们预先改好了配置文件，在构建的时候再把配置放入容器里面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;i class=&#34;fas fa-file&#34;&gt;&lt;/i&gt;hexo_debian_service_start.sh&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
. ~/.profile
LOGTIME=$(date &amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;)
echo &amp;quot;[$LOGTIME] startup run...&amp;quot; &amp;gt;&amp;gt;/start_ssh.log
service ssh start &amp;gt;&amp;gt;/start_ssh.log
tail -f /start_ssh.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动脚本，主要启动了ssh服务，并且用&lt;code&gt;tail -f&lt;/code&gt;让这个容器一直运行以方便我们来连接&lt;/p&gt;
&lt;h4 id=&#34;313-开始构建镜像&#34;&gt;3.1.3 开始构建镜像
&lt;/h4&gt;&lt;p&gt;先&lt;code&gt;CD&lt;/code&gt;到Dockerfile所在的目录&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-10-57_85fedbc9.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-10-57&#34;
	
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t hexo_debian:V02 -f dockerfileV02 .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;格式是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t 镜像名:tag -f Dockerfile文件名 .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意&lt;code&gt;.&lt;/code&gt;不要落下！&lt;/p&gt;
&lt;p&gt;这样我们的镜像就做好了！&lt;/p&gt;
&lt;p&gt;本节参考资料：&lt;br&gt;
二进制手动安装node参考：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/nodejs/help/wiki/Installation&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nodejs/help/wiki/Installation&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.51cto.com/u_13460811/4901015&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.51cto.com/u_13460811/4901015&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一些关于dockerfile指令的说明：&lt;br&gt;
较详细： &lt;a class=&#34;link&#34; href=&#34;https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://yeasy.gitbook.io/docker_practice/image/dockerfile/copy&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_35528657/article/details/127244194&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/qq_35528657/article/details/127244194&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.runoob.com/docker/docker-dockerfile.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.runoob.com/docker/docker-dockerfile.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在dockerfile里用apt-get包管理的建议：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://ubuntu.com/blog/we-reduced-our-docker-images-by-60-with-no-install-recommends&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ubuntu.com/blog/we-reduced-our-docker-images-by-60-with-no-install-recommends&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.metricfire.com/blog/how-to-build-optimal-docker-images/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.metricfire.com/blog/how-to-build-optimal-docker-images/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;hexo所需环境安装说明：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://hexo.io/zh-cn/docs/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://hexo.io/zh-cn/docs/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;314-测试镜像功能&#34;&gt;3.1.4 测试镜像功能
&lt;/h4&gt;&lt;p&gt;来启个容器试试！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -it -d -p 22:22 --name hexo_debian hexo_debian:V02
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里开放了22端口来方便验证ssh服务和登录ssh没有问题&lt;br&gt;
启动成功！&lt;br&gt;
容器内执行来验证服务状态都正常：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh
node -v
git -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-11-11_3d59334a.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-11-11&#34;
	
	
&gt;&lt;br&gt;
可以看见一切正常！&lt;/p&gt;
&lt;h4 id=&#34;315-设置和再打包镜像&#34;&gt;3.1.5 设置和再打包镜像
&lt;/h4&gt;&lt;h5 id=&#34;设置&#34;&gt;设置
&lt;/h5&gt;&lt;p&gt;毕竟自用镜像，我习惯直接把比如ssh密钥之类全都配置好，再&lt;code&gt;commit&lt;/code&gt;为一个新镜像，以后就再也不用输密码了，这样确实不安全，但是自己的hexo博客而已，何必为难自己呢&lt;br&gt;
接下来设置root密码和重启ssh服务&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-11-21_0c7fd65b.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-11-21&#34;
	
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;passwd root
#然后敲自己设置的密码
service ssh restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试使用PuTTY进行SSH &lt;a class=&#34;link&#34; href=&#34;mailto:root@127.0.0.1&#34; &gt;root@127.0.0.1&lt;/a&gt;登录：&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-11-33_fdc9ecda.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-11-33&#34;
	
	
&gt;&lt;br&gt;
成功!!!&lt;br&gt;
接下来配置git和ssh，要生成新的ssh公钥&lt;br&gt;
详见：https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-11-48_647a6186.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-11-48&#34;
	
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t ed25519 -C &amp;quot;github邮箱@qq.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到密钥默认在&lt;code&gt;/root/.ssh/id_ed25519.pub&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-12-13_dd9d9ecb.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-12-13&#34;
	
	
&gt;&lt;br&gt;
在Github的头像点Setting然后点右上角击&lt;strong&gt;New SSH key&lt;/strong&gt;，把id_ed25519.pub内容粘贴进即可！&lt;br&gt;
测试SSH连接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-12-23_9f4a79cd.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-12-23&#34;
	
	
&gt;&lt;br&gt;
这样就连上了！&lt;br&gt;
需要进行一个小设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.email &amp;quot;you@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样以后使用&lt;code&gt;hexo d&lt;/code&gt;的时候就能无脑部署了&lt;/p&gt;
&lt;h5 id=&#34;再打包&#34;&gt;再打包
&lt;/h5&gt;&lt;p&gt;为了存下我们配置好的连接，制作成最终镜像方便eci云上调用，把现有容器再commit一次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker commit hexo_debian hexo_debian:V02-configured
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成了！得到了&lt;code&gt;hexo_debian:V02-configured&lt;/code&gt;作为我最后准备上传至ECI云的镜像&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;316-附一些命令参考&#34;&gt;3.1.6 附一些命令参考
&lt;/h4&gt;&lt;h5 id=&#34;如何用ssh连接-docker-容器&#34;&gt;如何用ssh连接 docker 容器
&lt;/h5&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_34910922/article/details/125193597&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/weixin_34910922/article/details/125193597&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.修改root密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ passwd root
输入密码：123456(自己决定)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.安装Openssh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update # 更新源
sudo apt-get upgrade # 更新系统软件
apt-get install -y openssh-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.修改ssh配置,允许root登录&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_43343144/article/details/102494830&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/weixin_43343144/article/details/102494830&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;【非常重要】在/etc/ssh/ssh_config中没有PermitRootLogin yes选项的话，就要在sshd_config文件中寻找！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim /etc/ssh/sshd_config
PermitRootLogin yes #root登陆权限
PasswordAuthentication yes #密码权限
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.启动ssh服务/重启服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;service ssh start
service ssh restart
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;安装hexo&#34;&gt;安装hexo
&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;npm install hexo-cli -g
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;ssh远程登录这个镜像&#34;&gt;SSH远程登录这个镜像
&lt;/h5&gt;&lt;p&gt;之前在本机docker内已经配好了ssh服务，讲道理应该启动则开启ssh但是不知为啥没有自动启动，以后再研究吧&lt;br&gt;
打开Workbench远程连接，启动ssh&lt;br&gt;
由于我启用ECI时开通了弹性公网IP，所以我可以通过这个IP:22用ssh来登录&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-14-08_59350d93.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-14-08&#34;
	
	
&gt;&lt;br&gt;
使用PuTTY工具登录成功！！&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-13-59_dd471be1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-13-59&#34;
	
	
&gt;&lt;br&gt;
多么令人振奋的一刻&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;32-vsftpd镜像&#34;&gt;3.2 vsftpd镜像
&lt;/h3&gt;&lt;p&gt;这个镜像比较简单，只跑ftp服务，主要在写作的时候方便上传图片&lt;/p&gt;
&lt;h4 id=&#34;321-dockerfile&#34;&gt;3.2.1 Dockerfile
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;i class=&#34;fas fa-file&#34;&gt;&lt;/i&gt;vsftpd_dockerfileV01&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#这个包将包含：vsftp（root登录）
FROM debian:stable-slim
LABEL maintainer=&amp;quot;winotmk&amp;quot; web=&amp;quot;md.winotmk.com&amp;quot; Ver=&amp;quot;01&amp;quot;
RUN apt-get update &amp;amp;&amp;amp;\
    apt-get install -y vsftpd --no-install-recommends &amp;amp;&amp;amp;\
    apt-get autoremove -y &amp;amp;&amp;amp;\
    apt-get clean &amp;amp;&amp;amp;\
    echo &amp;quot;root:yourpasswd&amp;quot; | chpasswd
COPY ftpusers /etc/
COPY vsftpd.conf /etc/
COPY service_start.sh /service_start.sh
CMD [&amp;quot;/bin/bash&amp;quot;,&amp;quot;/service_start.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比较简单的dockerfile，就装了个vsftpd服务，然后拷贝了一些设置文件&lt;br&gt;
如果要在dockerfile里配置用户密码可以这么写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;root:yourpasswd&amp;quot; | chpasswd
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;322-vsftpd镜像copy的文件&#34;&gt;3.2.2 vsftpd镜像COPY的文件
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;i class=&#34;fas fa-file&#34;&gt;&lt;/i&gt;service_start.sh&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
LOGTIME=$(date &amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;)
echo &amp;quot;[$LOGTIME] startup run...&amp;quot; &amp;gt;&amp;gt;/start_vsftpd.log
service vsftpd start &amp;gt;&amp;gt;/start_vsftpd.log
tail -f /start_vsftpd.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单的服务启动脚本，使用&lt;code&gt;tail -f&lt;/code&gt;来维持住进程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;i class=&#34;fas fa-file&#34;&gt;&lt;/i&gt;ftpusers&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;root&lt;/code&gt;前加个&lt;code&gt;#&lt;/code&gt;以启用root登录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# /etc/ftpusers: list of users disallowed FTP access. See ftpusers(5).

#root
daemon
bin
sys
sync
games
man
lp
mail
news
uucp
nobody
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;i class=&#34;fas fa-file&#34;&gt;&lt;/i&gt;vsftpd.conf&lt;/strong&gt;&lt;br&gt;
ftp设置文件，这个文件内容很多只些下修改的部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;listen=NO
listen_ipv6=YES
anonymous_enable=NO
local_enable=YES
write_enable=YES
dirmessage_enable=YES
use_localtime=YES
connect_from_port_20=YES
pam_service_name=vsftpd
utf8_filesystem=YES
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;*关于修改vsftpd的端口&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://askubuntu.com/questions/37058/how-to-change-vsftpd-default-port&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://askubuntu.com/questions/37058/how-to-change-vsftpd-default-port&lt;/a&gt;&lt;br&gt;
&lt;code&gt;vsftpd.conf&lt;/code&gt;里的设置不是完全设置，可以自己增加字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;listen_port=234
ftp_data_port=235
pasv_min_port=30000
pasv_max_port=31000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来设置端口&lt;br&gt;
注意FTP默认20传输数据，21用来listen，所以改得话干脆两个都改吧&lt;/p&gt;
&lt;p&gt;*这里遇到过一个小坑坑&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-14-45_1313f14d.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-14-45&#34;
	
	
&gt;&lt;br&gt;
构建器报错，一直卡在&lt;code&gt;Starting FTP server: vsftpdvsftpd failed - probably invalid config. ... (warning).&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-15-01_61908eb5.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-15-01&#34;
	
	
&gt;&lt;br&gt;
自己在容器内运行&lt;code&gt;service vsftpd start&lt;/code&gt;的时候同样如此，一般这样是因为&lt;code&gt;vsftpd.conf&lt;/code&gt;文件设置错了，可神奇的是我只要打开dockerDesktop的Files文件管理把&lt;code&gt;vsftpd.conf&lt;/code&gt;打开再保存一下就可以成功运行&lt;code&gt;service vsftpd start&lt;/code&gt;&lt;br&gt;
我发现这个文件的格式是UTF-8 CRLF&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-15-30_14a47584.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-15-30&#34;
	
	
&gt;&lt;br&gt;
修改为LF&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-15-38_b5d21031.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-15-38&#34;
	
	
&gt;&lt;br&gt;
即可顺利启动vsftpd服务&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Dreamcho/p/10805690.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/Dreamcho/p/10805690.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果要在dockerfile里加用户：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/u010275850/article/details/120587850&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/u010275850/article/details/120587850&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;33-ddns镜像&#34;&gt;3.3 ddns镜像
&lt;/h3&gt;&lt;p&gt;这个镜像更简单？只在启动的时候跑一个ddns&lt;br&gt;
但是我却在这里卡了很久&lt;br&gt;
原因之一是因为一开始选用的ddns软件本地跑得好好的，在阿里云上总是报错，log显示已经修改了a记录但是自己去一看啥也没有，很是困惑，所以换了个软件实现&lt;br&gt;
最开始使用的是这个软件，配置方便&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/NewFuture/DDNS&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/NewFuture/DDNS&lt;/a&gt;&lt;br&gt;
参考：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/biao0309/article/details/117202951&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/biao0309/article/details/117202951&lt;/a&gt;&lt;br&gt;
无奈阿里云上即便是用官方提供的镜像&lt;code&gt;newfuture/ddns&lt;/code&gt;也会报错（恼&lt;/p&gt;
&lt;p&gt;所以我改用ddns-go:&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/jeessy2/ddns-go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/jeessy2/ddns-go&lt;/a&gt;&lt;br&gt;
先贴上官方镜像的层：&lt;br&gt;
&lt;strong&gt;jeessy/ddns-go&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-16-07_a03a145f.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-16-07&#34;
	
	
&gt;&lt;br&gt;
我们的新镜像将基于官方镜像来做&lt;/p&gt;
&lt;h4 id=&#34;331-dockerfile&#34;&gt;3.3.1 dockerfile
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;i class=&#34;fas fa-file&#34;&gt;&lt;/i&gt;ddns-go_dockerfileV01&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM jeessy/ddns-go
LABEL maintainer=&amp;quot;winotmk&amp;quot; web=&amp;quot;md.winotmk.com&amp;quot; Ver=&amp;quot;01&amp;quot;
COPY ddns_start.sh /
COPY ddns_go_config.yaml /
ENV DDNS_URL=
ENTRYPOINT [ &amp;quot;sh&amp;quot;,&amp;quot;/ddns_start.sh&amp;quot; ]
CMD [ &amp;quot;&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里做了一个变量&lt;code&gt;$DDNS_URL&lt;/code&gt;来定义我想要dns的域名(当然这个域名我得拥有)&lt;br&gt;
ENTRYPOINT和CMD的设置会覆盖掉的之前镜像内的设置&lt;br&gt;
我不确定CMD [ &amp;quot;&amp;quot; ]是否有必要，但总之我想使官方镜像里的CMD失效，从结果上来看管用&lt;/p&gt;
&lt;h4 id=&#34;332-ddns镜像copy的文件&#34;&gt;3.3.2 ddns镜像COPY的文件
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;i class=&#34;fas fa-file&#34;&gt;&lt;/i&gt;ddns_go_config.yaml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dnsconf:
    - ipv4:
        enable: true
        gettype: url
        url: https://myip4.ipip.net,https://ddns.oray.com/checkip,https://ip.3322.net,https://4.ipw.cn
        netinterface: &amp;quot;&amp;quot;
        cmd: &amp;quot;&amp;quot;
        domains:
            - null.winotmk.com
      ipv6:
        enable: false
        gettype: netInterface
        url: https://speed.neu6.edu.cn/getIP.php,https://v6.ident.me,https://6.ipw.cn
        netinterface: &amp;quot;&amp;quot;
        cmd: &amp;quot;&amp;quot;
        ipv6reg: &amp;quot;&amp;quot;
        domains:
            - &amp;quot;&amp;quot;
      dns:
        name: alidns
        id: 阿里云的AccessKey ID
        secret: 阿里云的AccessKey secret
      ttl: &amp;quot;&amp;quot;
user:
    username: &amp;quot;&amp;quot;
    password: &amp;quot;&amp;quot;
webhook:
    webhookurl: &amp;quot;&amp;quot;
    webhookrequestbody: &amp;quot;&amp;quot;
    webhookheaders: &amp;quot;&amp;quot;
notallowwanaccess: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个是ddns-go的配置文件，第一次启动会在本地:9876打开个web界面，保存设置后会在root中生成这个文件，这里我直接引入这个文件是希望后面能用&lt;code&gt;sed&lt;/code&gt;命令对文件的&lt;code&gt;domains&lt;/code&gt;字段进行修改&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;i class=&#34;fas fa-file&#34;&gt;&lt;/i&gt;ddns_start.sh&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh
LOGTIME=$(date &amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;)
echo &amp;quot;[$LOGTIME] startup run...&amp;quot; &amp;gt;&amp;gt;/start_ddns.log
cd /
if [ &amp;quot;$DDNS_URL&amp;quot; = &amp;quot;&amp;quot; ]  
then  
    echo &amp;quot;DDNS_URL is not set!&amp;quot; &amp;gt;&amp;gt;/start_ddns.log 
    tail -f /start_ddns.log 
else    
    sed -i &amp;quot;s/null.winotmk.com/$DDNS_URL/g&amp;quot; ddns_go_config.yaml
    #chmod 777 ddns_go_config.yaml
    sleep 3
    /app/ddns-go -l :9876 -f 300 -c /ddns_go_config.yaml
    echo &amp;quot;已执行更新[$DDNS_URL]解析&amp;quot; &amp;gt;&amp;gt;/start_ddns.log
    tail -f /start_ddns.log
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个脚本里会判断&lt;code&gt;$DDNS_URL&lt;/code&gt;是否为空，空的话直接输出需要&lt;code&gt;$DDNS_URL&lt;/code&gt;设置&lt;br&gt;
如果不为空的话会通过&lt;code&gt;sed&lt;/code&gt;替换字符，这里设置文件内默认写得是&lt;code&gt;null.winotmk.com&lt;/code&gt;&lt;br&gt;
用这种方式去直接修改设置文件，是因为我没找到这个软件是否能直接用环境变量来定义解析到的域名&lt;/p&gt;
&lt;p&gt;关于用sed替换congif.json设置内的字段：&lt;br&gt;
如何使用sed:&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/article-11367-1.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://linux.cn/article-11367-1.html&lt;/a&gt;&lt;br&gt;
如何在sed命令内使用变量&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/muahao/p/6874412.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/muahao/p/6874412.html&lt;/a&gt;&lt;br&gt;
判断变量是否为空的方法：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1721905&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cloud.tencent.com/developer/article/1721905&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-docker镜像打包并上传到阿里云镜像库ark&#34;&gt;4 docker镜像打包并上传到阿里云镜像库ARK
&lt;/h2&gt;&lt;p&gt;将自己的镜像上传至阿里云：&lt;br&gt;
阿里云提供容器镜像服务，我自己玩开通个人实例即可&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://cr.console.aliyun.com/cn-shanghai/instances&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cr.console.aliyun.com/cn-shanghai/instances&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-16-41_03b9efc6.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-16-41&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;建立一个自己的仓库，然后就能看到示例说明，我们就能把自己的镜像上传了&lt;/p&gt;
&lt;h3 id=&#34;41-将镜像推送到registry&#34;&gt;4.1 将镜像推送到Registry
&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ docker login --username=*****@qq.com registry.cn-shanghai.aliyuncs.com
$ docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/******:[镜像版本号]
$ docker push registry.cn-shanghai.aliyuncs.com/******:[镜像版本号]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tag&lt;/code&gt;是类似复制一份且重命名镜像，&lt;code&gt;push&lt;/code&gt;是上传（不知道为什么要重命名&lt;/p&gt;
&lt;p&gt;针对上面的3个镜像，分别是：&lt;code&gt;node.js+git+hexo&lt;/code&gt;,&lt;code&gt;vsftpd&lt;/code&gt;,&lt;code&gt;ddns-go&lt;/code&gt;&lt;br&gt;
我分别tag成了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;registry-vpc.cn-shanghai.aliyuncs.com/******:debian_V02_configured #应该写成:hexo_debian_V02_configured的，漏了。。算了
registry-vpc.cn-shanghai.aliyuncs.com/******:vsftpd_debian_V01
registry-vpc.cn-shanghai.aliyuncs.com/******:ddns_go_V01
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再分别&lt;code&gt;push&lt;/code&gt;即可&lt;/p&gt;
&lt;h3 id=&#34;42-在阿里云上使用容器实例eci运行镜像&#34;&gt;4.2 在阿里云上使用容器实例（ECI）运行镜像
&lt;/h3&gt;&lt;p&gt;阿里云ECI提供这个服务，你可以直接用现有的镜像也可以自己上传（就是上一步镜像服务里上传的镜像）按秒收费！不过作为hexo这种启用&amp;gt;生成&amp;gt;部署&amp;gt;关闭的服务来说，花不了几毛钱&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-16-51_c8efac34.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-16-51&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;然后就能看到我们上传的镜像&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-16-59_7422cb6f.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-16-59&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-eci容器创建模板和eci命令行工具使用&#34;&gt;5 eci容器创建模板和eci命令行工具使用
&lt;/h2&gt;&lt;p&gt;参考文章这两篇足够:&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/aliyuneci/eci-client-doc/blob/main/eci_run.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/aliyuneci/eci-client-doc/blob/main/eci_run.md&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://help.aliyun.com/document_detail/186961.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://help.aliyun.com/document_detail/186961.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;51-eci简介&#34;&gt;5.1 eci简介
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.aliyun.com/product/eci&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.aliyun.com/product/eci&lt;/a&gt;&lt;br&gt;
ECI是 Serverless 和容器化的弹性计算服务。您无需管理底层 ECS 服务器，只需要提供打包好的镜像，即可运行容器，与阿里云容器服务无缝对接并仅为容器实际运行消耗的资源付费。&lt;/p&gt;
&lt;p&gt;博主：比ECS云服务器灵活得多，本地用docker制作好镜像以后，上传，随启随用，用完就释放，成本可以很低,但如果连开一个月，并不会比ECS划算，详见本站&lt;a class=&#34;link&#34; href=&#34;https://winotmk.github.io/Docker01.1_%E4%BB%B7%E6%A0%BC%E8%AE%A1%E7%AE%97%E8%A1%A8/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ECI价格计算附表&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;52-用模板创建eci&#34;&gt;5.2 用模板创建eci
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-17-18_4d97b3f6.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-17-18&#34;
	
	
&gt;&lt;br&gt;
询问过阿里云客服，说在web控制面版里的这个功能已经下线了&lt;br&gt;
不过没关系，我们还有命令行工具！&lt;br&gt;
安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo bash -c &amp;quot;$(curl -s https://eci-docs.oss-cn-beijing.aliyuncs.com/eci-client/1.0/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后配置你的阿里云信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;eci config set-context \
--access-key-id **** \
--access-secret **** \
--region-id cn-shanghai \
--security-group-id sg-**** \
--v-switch-id vsw-****
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要指定自己的&lt;code&gt;access-key-id&lt;/code&gt;和&lt;code&gt;access-secret&lt;/code&gt;，地区以及安全组和虚拟交换机&lt;br&gt;
建议这些东西在web上的控制台里准备好，会直观很多&lt;/p&gt;
&lt;p&gt;然后就可以直接创建一个容器了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;eci run -n myeci centos:7 sleep 3600
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指令很像&lt;code&gt;docker run&lt;/code&gt;喝！很好，很有精神&lt;/p&gt;
&lt;p&gt;我们还可以编写yaml模板文件&lt;br&gt;
然后执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;eci run -f eci.yaml -w 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的事，如果使用了&lt;code&gt;-f xxxx.yaml&lt;/code&gt;模板文件，除了-f和-w选项以外，其他选项都将被忽略，因为这些选项都是针对实例中某个容器的，如果模板中定义了多个容器，ECI将不知道这些选项应该作用于哪个容器&lt;br&gt;
那么我自己的启动模板是这样的：&lt;br&gt;
&lt;strong&gt;&lt;i class=&#34;fas fa-file&#34;&gt;&lt;/i&gt;hexo_debian_eci.yaml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ContainerGroupName: eci-hexo
Cpu: &amp;quot;0.5&amp;quot;
Memory: &amp;quot;1&amp;quot;
Container:
- Name: hexo
  Image: registry-vpc.cn-shanghai.aliyuncs.com/****:debian_V02_configured
  Command: [&amp;quot;/bin/bash&amp;quot;,&amp;quot;/service_start.sh&amp;quot;]
  ImagePullPolicy: IfNotPresent
  Cpu: &amp;quot;0.5&amp;quot;
  Memory: &amp;quot;1&amp;quot;
  VolumeMount:
  - Name: hexo
    MountPath: /hexo
    ReadOnly: false
- Name: vsftpd
  Image: registry-vpc.cn-shanghai.aliyuncs.com/****:vsftpd_debian_V01
  Command: [&amp;quot;/bin/bash&amp;quot;,&amp;quot;/service_start.sh&amp;quot;]
  ImagePullPolicy: IfNotPresent
  VolumeMount:
  - Name: hexo
    MountPath: /hexo
    ReadOnly: false
- Name: ddns
  Image: registry-vpc.cn-shanghai.aliyuncs.com/****:ddns_go_V01
  ImagePullPolicy: IfNotPresent
  EnvironmentVar:
  - FieldRefFieldPath: &amp;quot;&amp;quot;
    Key: DDNS_URL
    Value: mdwrite.winotmk.com
Volume:
- Name: hexo
  Type: NFSVolume
  NFSVolume:
    Server: ****.cn-shanghai.nas.aliyuncs.com
    Path: /
    ReadOnly: false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是不是挺像&lt;code&gt;docker compose&lt;/code&gt;~&lt;/p&gt;
&lt;p&gt;cpu只给了0.5,Memory 1G，足够了，之前这套可是在树莓派3B上跑得溜溜得呢&lt;br&gt;
对于阿里云ECI，CPU和Memory直接和成本挂钩，能少就少吧&lt;/p&gt;
&lt;p&gt;这里启了上面做好的3个镜像，分别实现hexo，ftp，还有ddns&lt;br&gt;
&lt;code&gt;Command:&lt;/code&gt;写法目测类似dockerfile里的&lt;code&gt;CMD&lt;/code&gt;，我习惯做好启动sh脚本就是为了方便这里再调用&lt;br&gt;
最后一段声明了我的一个阿里云NAS卷，卷里的内容就是我的hexo目录&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-17-56_bc212f63.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-17-56&#34;
	
	
&gt;&lt;br&gt;
然后把它挂到hexo和ftp镜像上就好了&lt;/p&gt;
&lt;p&gt;值得一提的是ddns镜像还写了个环境变量&lt;code&gt;DDNS_URL&lt;/code&gt;值为&lt;code&gt;mdwrite.winotmk.com&lt;/code&gt;，这会修改&lt;code&gt;ddns-go&lt;/code&gt;的解析配置&lt;/p&gt;
&lt;p&gt;然后执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;eci run -f hexo_debian_eci.yaml -w 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不出意外的话会返回一个eci的id编号，打开web会发现已经创建成功了！&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-18-19_748517aa.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-18-19&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;6-hexo本地编辑环境设置如何用vscode舒服的写md文档&#34;&gt;6 hexo本地编辑环境设置————如何用VSCode舒服的写MD文档
&lt;/h2&gt;&lt;h3 id=&#34;61-vscodessh-fs插件配置&#34;&gt;6.1 VSCodeSSH FS插件配置
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-18-33_e39a872e.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-18-33&#34;
	
	
&gt;&lt;br&gt;
简单配置一下服务器地址和用户密码就可以把远程目录映射到工作区里，很方便&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-18-42_2bdf1198.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-18-42&#34;
	
	
&gt;&lt;br&gt;
这里可以看到&lt;code&gt;/root/hexo/Winblog&lt;/code&gt;目录下是我挂载的阿里云NAS网盘了&lt;/p&gt;
&lt;h3 id=&#34;62-markdown-paste插件配置&#34;&gt;6.2 Markdown Paste插件配置
&lt;/h3&gt;&lt;p&gt;一个很方便的在VScode里直接粘图的插件&lt;/p&gt;
&lt;h4 id=&#34;配置&#34;&gt;配置：
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-18-51_08d61cb4.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-18-51&#34;
	
	
&gt;&lt;br&gt;
会用时间来命名图片&lt;br&gt;
然后会将图片放入MD文件目录下的&lt;code&gt;images&lt;/code&gt;下&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-19-01_bae3735a.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-19-01&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;然后文件》首选项》键盘快捷方式&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-19-19_690acbb0.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-19-19&#34;
	
	
&gt;&lt;br&gt;
我将快捷键设置为&lt;code&gt;ctrl+alt+a&lt;/code&gt;&lt;br&gt;
配置完成！&lt;/p&gt;
&lt;h4 id=&#34;使用&#34;&gt;使用：
&lt;/h4&gt;&lt;p&gt;截图我习惯用Sinpaste，按F1就能截图&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-19-36_68b61e41.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-19-36&#34;
	
	
&gt;&lt;br&gt;
然后点右下角复制按钮&lt;br&gt;
在VScode的markdown文档里&lt;code&gt;ctrl+alt+a&lt;/code&gt;就能粘图了！&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-19-45_282c0fc0.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-19-45&#34;
	
	
&gt;&lt;br&gt;
图片文件会自动保存!&lt;/p&gt;
&lt;h3 id=&#34;62-vscode的sftp插件配置&#34;&gt;6.2 VSCode的SFTP插件配置
&lt;/h3&gt;&lt;p&gt;先把images文件夹单独放到工作区里&lt;br&gt;
然后在Ctrl+Shift+P打开命令面板，运行SFTP: config命令&lt;br&gt;
sftp.json目录下会出现一个名为的基本配置文件.vscode&lt;br&gt;
&lt;img src=&#34;http://pictures.winotmk.com/Docker01/2025-02-28-00-19-58_4d3f4080.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;2025-02-28-00-19-58&#34;
	
	
&gt;&lt;br&gt;
然后编辑&lt;br&gt;
&lt;strong&gt;&lt;i class=&#34;fas fa-file&#34;&gt;&lt;/i&gt;sftp.json&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;Hexo_images&amp;quot;,
    &amp;quot;host&amp;quot;: &amp;quot;mdwrite.winotmk.com&amp;quot;,
    &amp;quot;protocol&amp;quot;: &amp;quot;ftp&amp;quot;,
    &amp;quot;port&amp;quot;: 21,
    &amp;quot;username&amp;quot;: &amp;quot;root&amp;quot;,
    &amp;quot;password&amp;quot;: &amp;quot;****&amp;quot;,
    &amp;quot;remotePath&amp;quot;: &amp;quot;/hexo/Winblog/source/images&amp;quot;,
    &amp;quot;useTempFile&amp;quot;: false,
    &amp;quot;openSsh&amp;quot;: false,
    &amp;quot;uploadOnSave&amp;quot;: false, 
    &amp;quot;watcher&amp;quot;: {
      &amp;quot;files&amp;quot;: &amp;quot;**/*&amp;quot;,
      &amp;quot;autoUpload&amp;quot;: true,
      &amp;quot;autoDelete&amp;quot;: true
    },
    &amp;quot;syncOption&amp;quot;: {
      &amp;quot;delete&amp;quot;: true
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;watcher&amp;quot;&lt;/code&gt;是用来设置自动更新的&lt;br&gt;
这样我们在md里粘了图，就会自动上传到到ftp目录上&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://marketplace.visualstudio.com/items?itemName=Natizyskunk.sftp#remote-explorer&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://marketplace.visualstudio.com/items?itemName=Natizyskunk.sftp#remote-explorer&lt;/a&gt;&lt;br&gt;
开启watcher模式，实现增加文件时自动上传目录同步&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/Natizyskunk/vscode-sftp/blob/master/FAQ.md#automatically-sync-both-ways-without-user-interaction&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/Natizyskunk/vscode-sftp/blob/master/FAQ.md#automatically-sync-both-ways-without-user-interaction&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
